<html><head>

<title>MaskTools</title>
<link rel="stylesheet" type="text/css" href="../../avisynth.css">
<!--
Automatically generated, don't change:
$Id: masktools.htm,v 1.1 2010/02/27 14:50:14 wilbertd Exp $
--></head>
<body>
<h1>MaskTools</h1>
<h2>Pøehled</h2>
<b>autor:</b>  kurosu and Manao
<br><b>verze:</b>      1.5.8
<br><b>stáhnout:</b>   <a href="http://manao4.free.fr/">http://manao4.free.fr/</a>,
<a href="http://www.avisynth.org/warpenterprises/">http://www.avisynth.org/warpenterprises/</a><br>
<b>kategorie:</b>  Rùzné pluginy<br>
<b>poadavky:</b> YV12 Barevné prostøedí<br>
<b>license:</b> GPL
<hr>
<h2>Obsah
</h2>
<ul>
  <li><a href="#masktools">
I) O pluginu MaskTools</a>
    <ul>
      <li><a href="#simple">1) Obecnì</a></li>
      <li><a href="#description">2) Popis</a></li>
    </ul>
  </li>
  <li><a href="#functions">II) Popis funkcí</a></li>
  <li><a href="#examples">III) Nìkterá praktická pouití</a>
    <ul>
      <li><a href="#msharpen">1) MSharpen</a></li>
      <li><a href="#msoften">2) MSoften</a></li>
      <li><a href="#rainbow">3) Redukce duhy</a></li>
      <li><a href="#fxtoon">4) Supervzorkovanı fxtoon</a></li>
      <li><a href="#warpsharp">5) Warpsharp pro tmavı jas (luma)</a></li>
      <li><a href="#deinterlacer">6) Pseudo-deinterlacer (barevnost bude stále
problematická)</a></li>
      <li><a href="#rect_overlay">7) Nepravoúhlá pøekrıvání</a></li>
      <li><a href="#backgournd">8) Náhrada pozadí</a></li>
      <li><a href="#mftoon">9) Kmf-Toon ;-)</a></li>
    </ul>
  </li>
  <li><a href="#todo">IV) Na dopracování</a></li>
  <li><a href="#disclaimer">V) Odmítnutí záruk (nepøeskakujte tuto èást, ale nenutím vás
to nauèit se)</a></li>
  <li><a href="#revisions">VI) Revize</a></li>
  <li><a href="#developer">VII) Pro vıvojáøe</a></li>
</ul>
<h2><a name="masktools"></a>I) O pluginu MaskTools
</h2>
<h3><a name="simple"></a>1) Obecnì
</h3>
<p>Po zpracování mùete potøebovat zachovat jen èást vıstupu. Øeknìme,
máte
klip nazvanı smooth, kterı je vısledkem vyhlazování (blur() napøíklad)
klipu nazvaného source.<br>
Vìtšina šumu z klipu source v klipu smooth zmizela, Ale také má detaily.
Proto by jste mohli chtít zachovat jen filtované pixely a zahodit ty, ve kterıch je
velkı rozdíl barev nebo svìtlosti. To je to co dìlá napøíklad MSmooth od D.
Grafta. Nyní uvaujme, e zapíšete pixely obrazu ze smooth,
které chcete zachovat jako bílé pixely, a ty druhé z klipu source jako èerné
pixely. Získáne to co se nazıvá maskou. MaskTools jsou o vytváøení,
pøemìnách a manipulaci s takovımi maskami pro kadou komponentu barevného prostøedí YV12.</p>
<h3><a name="description"></a>2) Popis
</h3>
<p>Tento plugin pro Avisynth 2.5, kterı je urèen jen pro YV12 nabízí nìkolik funkcí manipulace
s klipy
jako maskami:
</p>
<ul>
  <li><a href="#binarize">Binarize</a> bude binarizovat vstupní obraz
podle prahové hodnoty a pøíkazu.</li>
  <li><a href="#combmask">CombMask</a> vytváøí masku, která dává oblasti, kde se nachází
prokládání (combing).</li>
  <li><a href="#dedgemask">DEdgeMask / DEdgeMask2</a> vytváøí masku hran
klipu, pouitím vymezení prahovıch hodnot (dané hodnoty je zapínají nebo vypínají).</li>
  <li><a href="#edgemask">EdgeMask</a> vytváøí masku hran
klipu, pouitím vymezení prahovıch hodnot - thresholding (dané hodnoty je zapínají nebo vypínají).
    Podobná s DEdgeMask s pøeddefinovanımi jádry.</li>
  <li><a href="#expand">Expand</a> 'expanduje' vysoké hodnoty v ploše,
vkládáním maximální hodnoty v okolí 3x3 kolem
vstupního pixelu do vıstupu.
    Opaèná funkce se nazıvá <a href="#expand">Inpand</a>.</li>
  <li><a href="#fitplane">FitY2UV/FitY2U/FitY2V</a> mìní velikost plochy Y a nahrazuje
UV/U/V plochy vısledkem zmìny velikosti (mùete zadat svùj filtr zmìny velikosti,
dokonce takovı, kterı není
    vestavìn v AviSynthu); opaèné funkce jsou FitU2Y a
FitV2Y.</li>
  <li><a href="#inflate">Inflate</a> 'nafoukne' vysoké hodnoty v ploše,
vloením do vıstupní
    plochy buï prùmìr 8 sousedù, pokud je vyšší ne
pùvodní hodnota, jinak pùvodní hodnotu. Opaèná funkce
    se nazıvá <a href="#expand"> Deflate</a> (vìnováno Philu Katzovi).</li>
  <li><a href="#invert">Invert</a> invertuje pixel (t.j. out = 255 - in);
toto mùe bıt také pouito pro
    aplikaci 'solarize' efektu na obraz.</li>
  <li><a href="#logic">Logic</a> vykoná nejtypiètìjší logické operace
(ve skuteènosti, ty samé jako nabízí MMX mnemonics, tøebae jsou C funkce stále
dostupné, hlavnì
    kvùli omezení rozmìrù obrazu).</li>
  <li><a href="#LUT">RGBLUT/YV12LUT/YV12LUTxy</a> jsou tabulky, umoòující aplikovat
rychle funkci na všechny pixely obrazu.</li>
  <li><a href="#maskedmerge">MaskedMerge</a> vezme 3 klipy a pouije
váené slouèení mezi prvním a druhım klipem podle masky reprezentované
klipem3.</li>
  <li><a href="#motionmask">MotionMask</a> vytvoøí masku pohybu v
obrazu.</li>
  <li>OverlayMask porovná 2 klipy zaloené na prahovıch hodnotách jasu a
barevnosti, a øíká zda jsou pixely blízké nebo ne (podobné tomu co dìlá
    ColorKeyMask).</li>
  <li><a href="#convolution">YV12Convolution</a> vám umoní convole (svinout)
obraz maticí podle vaší volby.</li>
  <li>YV12Layer je ekvivalent k OverLay.</li>
  <li><a href="#subtract">YV12Substract</a> je stejná jako Subtract, také pracuje
v YV12, ale *mìla by* bıt
    trochu rychlejší (protoe má MMX optimalizaci).</li>
</ul>
<p>Dále, všechny funkce berou 3 parametry: Y, U a V (kromì FitPlane
funkcí, kde jména jasnì øíkají co je zpracováno). Podle
jejich hodnoty (value), jsou aplikovány rùzné operace na kadou plochu:</p>
<ul>
  <li>value = 3 udìlá skuteèné zpracování filtrem,</li>
  <li>value = 2 zkopíruje 2.video plochu (je-li pouitelná) do vıstupu
odpovídající plochy</li>
  <li>value = 1 to nezpracuje (t.j., nejèastìji, nechá to s 1.plochou klipu
    nebo smetím - provìøte to sami)</li>
  <li>value = [-255...0] zaplní vıstup plochy zápornou hodnotou (t.j. aby jsme mìli
šedé
    úrovnì, pouijte U=128,V=128)</li>
</ul>
<p>Posledním bodem je schopnost nìkterıch funkcí zpracovat jen èást
snímku:</p>
<ul>
  <li>toto chování je nastaveno parametry (offX, offY) (pozice
poèáteèního
    bodu) a (w,h) (šíøka a vıška zpracované oblasti); filtry by mìli
upravovat tyto parametry, tak e zpracovaná oblast je uvnitø 2 obrazù</li>
  <li>v pøípadì filtru (kromì YV12Layer) pouívajícího 2 klipy, musí mít 2 klipy
    stejné rozmìry</li>
  <li>ve všech pøípadech, musí bıt rozmìry obrazu dìlitelné minimálnì 8 (nìkdy 16) aby
    se zapnulo vyuití MMX funkcí (t.j. práce plnou rychlostí)</li>
</ul>
<p>Toto bylo zamıšleno pro modularitu a atomické operace (nebo uiteèné, jak je to
moné), a ne právì pro rychlost. Stala se z toho nafouklá a pomalá vìc. Nechám na vás
rozhodnutí zda je toto tvrzení zcela pravdivé, nebo trochu ménì... Pøíklady v kapitole
III) jsou s nejvìtší pravdìpodobností mnohem rychleji aplikovány pùvodními filtry.<br>
</p>
<h2><a name="functions"></a>II) Popis funkcí
</h2>
<h3><a name="binarize"></a>Binarize
</h3>
<p><code>Binarize</code> (<var>clip, int "threshold", bool
"upper"</var>)<br>
<br>
Filtr <code> Binarize</code> umoòuje základní vymezení prahovıch hodnot (thresholding) obrazu. Jestlie
<var>upper</var>=true, pixel jeho hodnota je striktnì vìtší ne prahová hodnota threshold
bude nastavena na nulu, jinak na 255. Naproti tomu, jestlie
<var>upper</var>=false, pixel jeho hodnota je striktnì vìtší ne <var>
threshold</var> bude nastaveno na 255, jinak na nulu.<br>
<br>
Vıchozí hodnoty jsou <var>threshold </var>= 20 and <var>upper </var>= true.
</p>
<h3><a name="combmask"></a>CombMask
</h3>
<p><code>CombMask</code> (<var>clip, int "thY1", int
"thY2"</var>)
</p>
<p>Tento filtr produkuje masku zobrazující oblasti, které jsou prokládané (combed). Prahové hodnoty
fungují jako u jinıch
filtrù: je-li po vıpoètu hodnoty prokládání tato hodnota ní ne
<var>thY1</var>, nastaví se pixel
na 0, kdy je nad <var>thY2</var>, nastaví se na 255, a mezitím je nastavená
hodnota prokládání podìlena 256.
</p>
<p>Hodnota prokládání je (vyšší_pixel - pixel)*(niší_pixel - pixel). Tedy, není
to normalizováno
do rozsahu 0..255, protoe, kdyby to tak bylo, by byla blízko 1 nebo 2, ne
víc. To znamená
mùete pouít prahovou hodnotu vyšší ne 255, dokonce, i kdyby nemìly bıt uiteèné.
</p>
<p>Vıchozí jsou <var>thY1</var> = 10 a <var>thY2</var> = 10 ( tedy vytvoøení
binární masky ).
</p>
<h3><a name="dedgemask"></a>DEdgeMask / DEdgeMask2
</h3>
<p><code>DEdgeMask</code> (<var>clip, int "thY1", int
"thY2", int "thC1", int "thC2", string
"matrix", float "divisor", bool "setdivisor", bool "vmode"</var>)<br>
<code>DEdgeMask2</code> (<var>clip source, clip low_thres, clip high_thres, string
"matrix", float "divisor", bool "setdivisor", bool "vmode"</var>)<br>
<br>
Tento filtr vytváøí masku hran obrazu. Algoritmus nalezení hran
pouívá konvoluèní jádro, a vısledek konvoluce je pak
vymezen pomocí prahovıch hodnot
<var> thY1</var> a <var> thY2</var> ( jas - luma ) a <var> thC1</var> a <var>
thC2</var> ( barevnost - chroma ). Vymezení nastane takto ( r je vısledek
konvoluce )
:
</p>
<ul>
  <li>r &lt;= th1 dává 0.</li>
  <li>th1 &lt; r &lt;= th2 dává r.</li>
  <li>th2 &lt; r dává 255.</li>
</ul>
<p>Za úèelem vytvoøení binární masky, musíte nastavit th1=th2.</p>
<p>Volba konvoluèního jádra se provede <var>maticí - matrix</var>.
matice musí bıt 3 na 3, její koeficienty jsou celoèíselné, oddìlené
jednou mezerou. Proto øetìzece "-1 -1 -1 -1 8 -1 -1 -1 -1" a "0 -1 0 -1 0 1
0 1 0" dají jádra "laplace" a "sobel" filtru
<a href="#edgemask">EdgeMask</a>.</p>
<p>Koeficienty musí bıt celoèíselné, <var> divisor</var> je pouit pro oèištìní vısledku
konvoluce. Tento vısledek bude jednoduše podìlen parametrem
<var>divisor</var>. Jestlie <var> divisor</var> není definovanı, vyjde se ze
souètu kladnıch koeficientù matice, èím se umoní klasická
normalizace. Mùe bıt buï desetinnı nebo celoèíselnı, z nich ten druhı je rychlejší.<br>
<var>setdivisor </var> je pøítomen jen pro zpìtnou kompatibilitu. Nepouívejte ho.
<br>
A nakonec <var>vmode</var> umoní vytváøet masku støedìnou na 128 místo nuly.
Vıchozí hodnoty jsou : <var>thY1 </var>= 0, <var>thY2 </var>= 20, <var>thC1 </var>= 0,
<var>thC2
</var>= 20, <var>matrix </var>= "-1 -1 -1 -1 8 -1 -1 -1 -1" a <var>vmode</var>=false.</p>
<p>DEdgemask2 v zásadì pracuje jako DEdgeMask, kromì toho, e místo 2 nízkıch / vysokıch prahovıch hodnot
bere 2 další klipy. Kadı klip obsahuje lokální prahové hodnoty pro kadı pixel.
Øeknìme, e chcete adaptivní prahové hodnoty beroucí lokální kontrast do své hodnoty. Dobrá, lokální min &amp; max
lze získat pøes inpand() a expand(). Rozdíl mùe bıt vytvoøen pomocí YV12LUTxy nebo YV12Subtract.
A voila, máte prahovı klip obsahující lokální kontrasty.</p>
<h3><a name="edgemask"></a>EdgeMask</h3>
<p><code>EdgeMask</code> (<var>clip, int "thY1", int
"thY2", int
"thC1", int "thC2", string "type"</var>)<br>
<br>
Tento filtr vytváøí masku hran v obrazu. Algoritmus nalezení hran
pouívá konvoluèní jádro, a vısledek konvoluce je pak
vymezen prahovımi hodnotami
<var> thY1</var> a <var> thY2</var> ( jas ) a <var> thC1</var> a <var>
thC2</var> ( barevnost ). Vymezení prahovıch hodnot nastane takto ( r je vısledek
konvoluce ) :
</p>
<ul>
  <li> r &lt;= th1 dává 0.</li>
  <li> th1 &lt; r &lt;= th2 dává r.</li>
  <li> th2 &lt; r dává 255.</li>
</ul>
<p>Aby se vytvoøila binární maska, musíte nastavit th1=th2.</p>
<p>Volba konvoluènho jádra se provede parametrem <var> type</var> :</p>
<ul>
  <li><var> type</var> = "roberts" :<br>
    <table border="1" width="15%">
      <tbody><tr>
        <td align="center" height="5%" valign="middle" width="25%">2</td>
        <td align="center" height="5%" valign="middle" width="25%">-1</td>
      </tr>
      <tr>
        <td align="center" height="5%" valign="middle" width="25%">-1</td>
        <td align="center" height="5%" valign="middle" width="25%">0</td>
      </tr>
    </tbody></table>
  </li>
  <li><var> type</var> = "sobel" :<br>
    <table border="1" width="15%">
      <tbody><tr>
        <td align="center" height="5%" valign="middle" width="25%">0</td>
        <td align="center" height="5%" valign="middle" width="25%">-1</td>
        <td align="center" height="5%" valign="middle" width="25%">0</td>
      </tr>
      <tr>
        <td align="center" height="5%" valign="middle" width="25%">-1</td>
        <td align="center" height="5%" valign="middle" width="25%">0</td>
        <td align="center" height="5%" valign="middle" width="25%">1</td>
      </tr>
      <tr>
        <td align="center" height="5%" valign="middle" width="25%">0</td>
        <td align="center" height="5%" valign="middle" width="25%">1</td>
        <td align="center" height="5%" valign="middle" width="25%">0</td>
      </tr>
    </tbody></table>
  </li>
  <li><var> type</var> = "laplace" :<br>
    <table border="1" width="15%">
      <tbody><tr>
        <td align="center" height="5%" valign="middle" width="25%"> -1/8</td>
        <td align="center" height="5%" valign="middle" width="25%"> -1/8</td>
        <td align="center" height="5%" valign="middle" width="25%"> -1/8</td>
      </tr>
      <tr>
        <td align="center" height="5%" valign="middle" width="25%"> -1/8</td>
        <td align="center" height="5%" valign="middle" width="25%">1</td>
        <td align="center" height="5%" valign="middle" width="25%"> -1/8</td>
      </tr>
      <tr>
        <td align="center" height="5%" valign="middle" width="25%"> -1/8</td>
        <td align="center" height="5%" valign="middle" width="25%"> -1/8</td>
        <td align="center" height="5%" valign="middle" width="25%"> -1/8</td>
      </tr>
    </tbody></table>
  </li>
  <li><var> type</var> = "special" :<br>
    <table border="1" width="15%">
      <tbody><tr>
        <td align="center" height="5%" valign="middle" width="25%"> -1/4</td>
        <td align="center" height="5%" valign="middle" width="25%">0</td>
        <td align="center" height="5%" valign="middle" width="25%"> -1/4</td>
      </tr>
      <tr>
        <td align="center" height="5%" valign="middle" width="25%">0</td>
        <td align="center" height="5%" valign="middle" width="25%">1</td>
        <td align="center" height="5%" valign="middle" width="25%">0</td>
      </tr>
      <tr>
        <td align="center" height="5%" valign="middle" width="25%"> -1/4</td>
        <td align="center" height="5%" valign="middle" width="25%">0</td>
        <td align="center" height="5%" valign="middle" width="25%"> -1/4</td>
      </tr>
    </tbody></table>
  </li>
  <li><var> type</var> = "roberts" :<br>
    <table border="1" width="15%">
      <tbody><tr>
        <td align="center" height="5%" valign="middle" width="25%">2</td>
        <td align="center" height="5%" valign="middle" width="25%">-1</td>
      </tr>
      <tr>
        <td align="center" height="5%" valign="middle" width="25%">-1</td>
        <td align="center" height="5%" valign="middle" width="25%">0</td>
      </tr>
    </tbody></table>
  </li>
</ul>
<p>A nakonec, existují dvì další moné hodnoty pro <var> type</var> (
"cartoon" a "line" ), které mají chování v této dokumentaci neuvedené.</p>
<p>Vıchozí hodnoty jsou : <var>thY1 </var>= 0, <var>thY2 </var>= 20, <var>thC1 </var>=
0, <var>thC2 </var>= 20 a <var>type </var>= "sobel".</p>
<h3><a name="fitplane"></a>FitY2U / FitY2V / FitY2UV  FitU2Y / FitV2Y /
FitU2V / FitV2U</h3>
<p><code>FitPlane</code> (<var>clip, string resizer</var>) </p>
<p><code>FitPlane</code> má následující inkarnace:<br>
   - jas do barevnosti: <code>FitY2U</code>, <code>FitY2V</code>, <code>
FitY2UV</code><br>
   - barevnost do jasu: <code>FitU2Y</code>, <code> FitV2Y</code><br>
   - barevnost do barevnosti: <code>FitU2V</code>, <code> FitV2U</code></p>
<p>Tímto filtrem mùete rozšíøit (pouít) masku vytvoøenou na jedné ploše do
do jiné plochy.</p>
<h3><a name="expand"></a>Inpand / Expand / Deflate / Inflate
</h3>
<p><code>Inpand</code> (<var>clip</var>)<br>
<code>Expand</code> (<var>clip</var>)<br>
<code>Deflate</code> (<var>clip</var>)<br>
<code>Inflate</code> (<var>clip</var>)
</p>
<p>Tyto filtry umoòují zvìtšit / sníit masku. <code>Expand</code> nahradí
hodnotu pixelu nejvìtší okolní hodnotou.
<code>Inpand</code> ji naopak nahradí nejniší okolní
hodnotou.
<code>Inflate</code> vypoèítá prùmìr okolních pixelù, a
nahradí hodnotu pixelu vypoètenou jen, kdy je tento prùmìr vyšší ne
pùvodní hodnota pixelu.
<code>Deflate</code> Udìlá to samé jen kdy je prùmìr niší ne
pùvodní hodnota.
</p>
<p>Obraz vrácenı funkcemi <code>Expand</code> / <code>Inflate</code> bude
vdy vyšší ne pùvodní obraz. Naopak, obraz vrácenı funkcemi
<code>Inpand</code> / <code>Deflate</code> bude vdy niší.
</p>
<p>Zvìtšení / sníení vytváøené pomocí <code>Deflate</code> /
<code>Inflate</code>
je mìkèí ne to, které vytváøí <code>Expand</code> / <code>Inpand</code>.
</p>
<h3><a name="hysteresymask"></a>HysteresyMask
</h3>
<p><code>HysteresyMask</code> (<var>mask_clip1, mask_clip2</var>)
</p>
<p>Tento filtr vytváøí masku ze dvou masek. Teoreticky, první maska
by mìla bıt uvnitø té druhé, ale mùe to fungovat i pokud tomu tak není ( aèkoli
vısledky budou ménì zajímavé ). Principem filtru je zvìtšení
èástí, které patøí k obìma maskám, uvnitø druhé masky.
</p>
<p>Tento algoritmus je zajímavı protoe umoòuje napøíklad získat
masku hran se všemi zajímavımi hranami, ale bez šumu. Sestavíte dvì
masky hran, jednu s hodnì hranami a šumem, a druhou s málo hranami
a témìø bez šumu. Pak, pouijete tento filtr, a mìli by jste obdret
hrany bez šumu, protoe šum ve druhé masce nebyl.
</p>
<h3><a name="invert"></a>Invert
</h3>
<p><code>Invert</code> (<var>clip, int offX, int offX, int w, int h</var>)
</p>
<p>Tento filtr nahrazuje hodnotu pixelu hodnotou 255-(hodnota pixelu).
</p>
<p>Binarize(upper=false) mohlo by bıt shledáno (ale není zpracováno) jako 
</p>
<p>Invert().Binarize(upper=true)
</p>
<h3><a name="logic"></a>Logic
</h3>
<p><code>Logic</code> (<var>mask_clip1, mask_clip2, string
"mode"</var>)
</p>
<p>Tento filtr produkuje novou masku, která je vısledkem binární operace
mezi dvìma maskami. Operace je zvolena parametrem
<var>mode</var>.
</p>
<ul>
  <li><var>mode</var>="and" : pracuje jen s binárními maskami ( jen
pixel na 0 nebo 255 ). Vıstupní maska je prùnikem dvou masek. To
znamená, e pokud oba odpovídající pixely jsou 255, vıslednı pixel bude
255, jinak 0.</li>
  <li><var>mode</var>="or" : pracuje jen s binárními maskami. Vıstupní
maska je sjednocením dvou masek.  To znamená, e pokud jeden z odpovídajících
pixelù je 255, vıslednı pixel bude 255, jinak 0.</li>
  <li><var>mode</var>="xor" : pracuje jen s binárními maskami. Vıstupní
maska je rozdílem (odlišností) mezi dvìma maskami. To znamená, e pokud ( vıhradnì ) jeden z
odpovídajících pixelù je 255, vıslednı pixel bude
255, jinak 0.</li>
  <li><var>mode</var>="andn" : pracuje jen s binárními maskami. Vıstupní
maska je rozdílem (odeètením) druhé masky od první. To znamená, e
pokud pixel první masky je 255 a druhá je 0, vrátí
255, jinak 0.</li>
  <li><var>mode</var>="min" : vrací pro kadı pixel minimální
hodnotu mezi dvìma pixely vstupních masek. Jako
    <var>mode</var>="and", ale pro nebinární masky.</li>
  <li><var>mode</var>="max" : vrací pro kadı pixel maximální
hodnotu mezi dvìma pixely vstupních masek. Jako
    <var>mode</var>="or", ale pro nebinární masky.</li>
</ul>
<p>Pokud je logickı operátor pouit s nebinární maskou, vısledky jsou
nepøedvídatelné.
</p>
<p>Vıchozí : <var>mode </var>= "and".
</p>
<h3><a name="LUT"></a>RGBLUT / YV12LUT / YV12LUTxy / YUY2LUT
</h3>
<p><code>YV12LUT</code> (<var>clip, string "yexpr", string
"uexpr", string "vexpr"</var>)<br>
<code>YUY2LUT</code> (<var>clip, string "yexpr", string
"uexpr", string "vexpr"</var>)<br>
<code>RGBLUT</code> (<var>clip, string "Rexpr", string
"Gexpr", string "Bexpr", string "AMPFile"</var>)<br>
<code>YV12LUTxy</code> (<var>clipx, clipy, string "yexpr", string
"uexpr", string "vexpr"</var>)
</p>
<p>Tyto filtry aplikují funkci na kadı pixel obrazu. Aby byl umonìn
rychlı vıpoèet, kadá moná hodnota funkce je pøedvypoètena
a uloena v tabulce Look-Up Table ( udtud jména funkcí LUT ). To dìlá tyto filtry slušnì
rychlımi.
<code>RGBLUT</code>  pracuje pøesnì stejnì jako <code>YV12LUT</code>, kromì
toho, e má pøidanı argument <var>AMPFile</var>. Umoní vám naèíst
photoshop barevnı profil. 
</p>
<p>Aby bylo moné aplikovat témìø kadou monou funkci, je toto
dáno øetìzcem, kterı reprezentuje vıraz v obráceném polském zápisu (reverse polish notation).
Principem tohoto zápisu je zapisovat nejdøíve operandy / parametry
operátoru / funkce, a pak operátor / funkci samotnou. Proto, "3 + 7"
se stane "3 7 +", a "sin(3)" se stane "3 sin". Pùjdeme dále ve vysvìtlování,
"3 * 7 + 5" se stane "3 7 * 5 +", a "(3 + 7) * 5" : "3 7 + 5 *".
Nyní rozumíte hlavnímu kladu tohoto zápisu (notation) : ádná potøeba závorek.
</p>
<p>Vıpoèty jsou vedeny v reálnıch èíslech. Kladná èísla pøedstavují
pravdivé tvrzení, zatímco záporná èísla pøedstavují nepravdivé tvrzení.
Symbol "x" v øetìzci je hodnota pixelu pøed pouitím
funkce. Pro <code>YV12LUTxy</code> máte také symbol "y", kterı  pøedstavuje
hodnotu vázaného pixelu v druhém klipu. Symboly musí bıt
oddìleny jednou mezerou.
</p>
<p>Jsou imlementovány nìkteré operátory a funkce :
</p>
<ul>
  <li>+, -, /, *, ^, % jsou operátory plus, minus, dìleno, krát, mocnina
a modulo.</li>
  <li>&amp;, |, °, !&amp; jsou logické operátory and, or, xor, a not. Pokud
je vısledek pravda, pak vrací 1.0, jinak -1.0.</li>
  <li>&lt;, &lt;=, &gt;, &gt;=, =, != jsou relaèní operátory menší ne, menší nebo
rovno, vìtší ne, vìtší nebo rovno, rovná se, nerovná se. Pokud je vısledek
pravda, pak vrátí 1.0, jinak -1.0.</li>
  <li>cos, sin, tan, acos, asin, atan, exp, log, abs jsou funkce kosinus,
sinus, tangens, arckosinus, arcsinus, arctangens, exponenciální, napierùv (pøirozenı)
logaritmus, absolutní hodnota.</li>
  <li>? umoní provést podmínkovı test. Je to trojitı operátor, prvním
operandem bıvá podmínka, druhım hodnota jestli je podmínka pravdivá (true),
tøetím je hodnota jestlie je podmínka nepravdivá (false).</li>
</ul>
<p>Nìkolik pøíkladù :
</p>
<p>* Binarizace obrazu pomocí prahové hodnoty 128 : "x 128 &lt; 0 255
?". Je to pøeloeno jako : "(x &lt; 128) ? 0 : 255".<br>
    * Levels(il, gamma, ih, ol, oh) ( Podívejte se na filtr <a href="http://jourdan.madism.org/corefilters/levels.htm"> Levels</a> ) : "x il - ih il - / 1 gamma / ^
oh
ol - *".
To je pøeloeno jako "(((x - il) / (ih - il)) ^ (1 / gamma)) * (oh - ol)".
</p>
<p>Vıchozí hodnoty jsou : <var>Yexpr</var> = <var>Uexpr</var> = <var>Vexpr</var> =
"x" ( tedy filtr neudìlá nic ).
</p>
<h3><a name="maskedmerge"></a>MaskedMerge
</h3>
<p><code>MaskedMerge</code> (<var>base_clip, overlay_clip, mask_clip</var>)
</p>
<p>Tento filtr aplikuje klip <var>overlay_clip</var> na klip
<var>base_clip</var>, s ohledem na klip
<var>mask_clip</var>. Pøesnìji, s <i>bc</i>, <i> oc</i> a <i> mc</i>
hodnotami tøí pixelù vzatıch z <var>base_clip</var>,
<var>overlay_clip</var>
a <var>mask_clip</var>, bude vısledek :
</p>
<pre>v = ((256 - <i>mc</i>) * <i>bc</i> + <i>mc</i> * <i>oc</i> + 128) / 256</pre>
<p>128 je zde ke sníení chyby pøi zaokrouhlování celoèíselného
dìlení.
</p>
<p>Tedy, kdy je maska 255, pixel bude pixelem z
<var>overlay_clip</var>, kdy je maska 0, pixel bude z
<var>base_clip</var>, a mezitím bude smíchán z obou klipù.
</p>
<h3><a name="motionmask"></a>MotionMask
</h3>
<p><code>MotionMask</code> (<var>clip, int "thY1", int "thY2',
int
"thC1", int "thC2", int "thSD"</var>)
</p>
<p>Tento filtr vytváøí masku pohybu obrazu. Jako u jinıch filtrù
vytváøejících masky, jakmile je pohyb
vypoèítán, je vymezen dvìma prahovımi hodnotami. Tento filtr bude také provìøovat
zmìnu scény, a nevytváøí masku jestlie u je nìjaká detekována.
</p>
<p>Detekce zmìny scény se provádí vıpoètem souètù absolutních rozdílù
v obrazu a jeho pøedchozího. Tento souèet je zprùmìrován a pak porovnán s
<var>thSD</var>. Pokud je to víc ne <var>thSD</var>, je detekována zmìna scény.
</p>
<p>Pohyb je vypoèítán stejnım zpùsobem <a href="http://jourdan.madism.org/%7Emanao/nomosmooth.htm">NoMoSmooth</a>,
co znamená, e pro kadı pixel budeme poèítat absolutní souèet rozdílù
mezi pixelem a jeho okolím, a pixel a okolí v
pøedchozím obrazu. Vısledná hodnota je podìlena èíslem 9, aby
byl vısledek normalizován do rozsahu 0 a 255.
</p>
<p>Tento algoritmus dává pouze pøiblíení (aproximaci) pohybu. Bude dobøe pracovat
na hranách objektu, ale ne uvnitø.
</p>
<p>Vıchozí hodnoty jsou : <var>thY1</var>= 20, <var>thY2</var> = 20, <var>thC1</var> =
10, <var>thC2</var> = 10 a <var>thSD</var> = 10.
</p>
<h3><a name="convolution"></a>YV12Convolution
</h3>
<p><code>YV12Convolution</code> (<var>clip, string "horizontal",
string
"vertical", int "total", bool "automatic", bool
"saturate"</var>)
</p>
<p>Tento filtr vypoèítá konvoluèní souèin mezi obrazem a
jádrem definovanım násobením hodnot <var>horizontal</var> a
<var>vertical</var>. Tyto dva øetìzce pøedstavují vektory. Musí mít lichı poèet
celıch nebo reálnıch èísel, oddìlenıch jednou mezerou. <var>total</var>
je normalizaèní faktor, kterım je vısledek souèinu podìlen.
Jestlie je <var> automatic</var> nastaveno na 'true', total je souètem koeficientù
matice. To znamená, e touto cestou celková svìtlost obrazu není
dotèena.
<var>Saturate</var> umoní vybrat chování filtru, kdy je vısledkem
záporné èíslo.
</p>
<ul>
  <li><var>saturate</var> = true : záporné hodnoty jsou vynulovány.</li>
  <li><var>saturate</var> = false : záporné hodnoty jsou invertovány. </li>
</ul>
<p>Pokud není total definován, je nastaven na souèet koeficientù
konvoluèního jádra, èím se umoní dobrá normalizace jader pro rozmazání (bluring) / zostøení (sharpening).
</p>
<p>Pokud jeden z koeficientù horizontal nebo vertical je reálné èíslo, všechny
vıpoèty budou provedeny jako floats (desetinné), take filtr bude pomalejší.
</p>
<p>Vıchozí hodnoty jsou : <var>horizontal</var> = "1 1 1", <var>vertical</var> =
"1 1 1" a
<var>automatic</var> = false, <var>saturate</var> = true.
</p>
<h3><a name="subtract"></a>YV12Subtract
</h3>
<p><code>YV12Subtract</code> (<var>clip1, clip2, int tol, bool
"widerange"</var>)
</p>
<p>Tento filtr vypoèítá rozdíl mezi dvìma klipy. Existuje nìkolik zpùsobù
vıpoètu tohoto rozdílu, závisejících na hodnotách <var>widerange</var> a
<var>tol</var>.
</p>
<ul>
  <li><var>widerange</var> = true : vypoèítáme rozdíl ( n ) mezi
dvìma klipy, a vrátíme r = 128 + 128 * pow(n / 255,1 /
    <var>tol</var>). Pokud <var>tol</var> &lt; 0, 1 / <var>tol</var> se stane
0.5.</li>
  <li><var>widerange</var> = false :
    <ul>
      <li><var>tol</var> &lt; 0 : vypoèítáme absolutní rozdíl ( n )
mezi dvìma klipy, a vrátíme r = n / 2 + 128.</li>
      <li><var>tol</var> &gt;= 0 : vypoèítáme absolutní rozdíl ( n )
mezi dvìma klipy, a vrátíme 0 pokud n je niší ne tol, jinak n - tol. </li>
    </ul>
  </li>
</ul>
<p>Vıchozí hodnoty jsou : <var>tol</var> = -1 and <var>widerange</var> = false.
</p>
<h2><a name="examples"></a>III) Nìkterá praktická pouití (ne moc testované)
</h2>
<p>Tyto pøíklady nechtìjí vytváøet pøesnì stejné vısledky jako pùvodní filtry, snaí se je
napodobit, navíc jsou o dost pomalejší. Pøes øadu dalších
funkcí, ádná nová myšlenka.
</p>
<p>Poznámky: <br>
- Jsem pøíliš línı aktualizovat syntaxi, obzvláš pokud jde o to jak pracuje mode=2, a
jak bylo aktualizováno EdgeMask (nyní u napøíklad nepotøebuje Binarize)<br>
- Nìkteré filtry popisované jako 'na vytvoøení' u existují (imagereader, úrovnì pro
sevøení, ...).
</p>
<h4><a name="msharpen"></a>1) MSharpen
</h4>
<pre># Sestaví EdgeMask pro clip1, Binarizuje ji a vloí vısledek do clip3
# Aplikuje zostøovací filtr na clip1 a vloí ho do clip2
...
return MaskMerge(clip1, clip2, clip3)</pre>
<p>Zostøené hrany klipu clip2 vyšší ne prahová hodnota dané do Binarize
budou zostøeny a pouity pro nahrazení jejich pùvodních hodnot v klipu clip1.
Mohli by jste také napsat filtr s oddìlenou Look-up table (nejlépe by vypadala
jako zvon), nahradit jí Binarize, a mìli by jste váené zostøení
podle hodnoty hrany: to je HiQ èást ve SmartSmoothHiQ
</p>
<pre>clip2 = clip1.&lt;EdgeEnhancer&gt;(&lt;parameters&gt;)
#U a V plochy nepotøebují filtrování, Y ho potøebuje
#EdgeMask(&lt;...&gt;, &quot;roberts&quot;, Y=3, U=-128, V=-128) pro èernobílou mapu
clip3 = clip1.EdgeMask(15, 60, &quot;roberts&quot;, Y=3, U=1, V=1)
return MaskedMerge(clip1, clip2, clip3)</pre>
<h4><a name="msoften"></a>2) MSoften
</h4>
<p>Nahraïte EdgeEnhancer prostorovım zmìkèovaèem (kaskádová rozmazání?
prostorové zmìkèení MMX?) a pouijte upper=true pro vıbìr blízkıch pixelù v ploše.
</p>
<h4><a name="rainbow"></a>3) Redukce duhy (jak se popisuje v tomto <a href="http://forum.doom9.org/showthread.php?s=&amp;threadid=48167"><cite>vláknì</cite></a>
)
</h4>
<p>Upozornìní, ani toto není zázraèné øešení
</p>
<pre>clip2 = clip1 zmìkèit na maximum (pouitím deen(&quot;m2d&quot;) nebo edeen napøíklad)
#Získejte jasovou mapu hran a zvıraznìte hrany roztaením (zahuštìním)
# -&gt; na širší oblasti, které mají bıt zpracovány
clip3 = clip1.EdgeMask(6, &quot;roberts&quot;, Y=3, U=1, V=1).Inflate(Y=3, U=1, V=1)
#Nyní pouijte jasovou masku hran (edgemask) jako masku barevnosti
clip3 = YtoUV(clip3, clip3).ReduceBy2().Binarize(15, upper=false, Y=1, U=3, V=3)
#Musíme zpracovat barevnost pixelù blízko hran, ale zachovat netknutou Y plochu
return MaskedMerge(clip1, clip2, clip3, Y=1, U=3, V=3)</pre>
<h4><a name="fxtoon"></a>4) Supersampled (supervzorkovanı) fxtoon
</h4>
<p>Netestováno
</p>
<pre>. Pouijte tweak ke ztmavení obrazu nebo pouijte plugin, kterı sníí hodnoty Y
-&gt; clip2
. Sestavte masku hran, Supersamplujte tuto masku, Binarizujte ji vysokou prahovou hodnotou
(sevøení zní lépe), zahustìte (inflate) ji klipem -&gt; clip3
. Pouijte tmavší pixely klipu clip2 podle hodnot klipu clip3</pre>
<h4><a name="warpsharp"></a>5) Warpsharp pro tmavı jas
</h4>
<p>Netestováno
</p>
<pre>. Pouijte warpsharp -&gt; clip2 (nahrazení pixelù)
. Vytvoøte omezovací filtr nebo low-luma bypass filtr -&gt; clip3 (mask)</pre>
<h4><a name="deinterlacer"></a>6) Pseudo-deinterlacer (barevnost bude stále
problematická)
</h4>
<p>Netestováno
</p>
<pre>clip2 = clip1.SeparateFields().SelectEven().&lt;Method&gt;Resize(&lt;parameters&gt;)
clip3 = clip1.&lt;CombingDetector&gt;(&lt;parameters&gt;)
return MaskedMerge(clip1, clip2, clip3, Y=3, U=3, V=3)</pre>
<p>(barevnost dokonce ještì problematiètìjší)
</p>
<h4><a name="rect_overlay"></a>7) Nepravoúhlá pøekrıvání
</h4>
<p>Ve skuteènosti je toto provádìno lépe funkcemi layer a mask...
</p>
<pre>#Jednoduchı hack protoe ImageReader potøebuje celoèíselnou fps...
#Vìtšina zdrojù je nativnì v YUY2/YV12
clip = AviSsource(&quot;test.avi&quot;).ConvertToYV12().assumefps(fps)
#Naètìte obrázek pro pøekrıvání
image = ImageReader(&quot;mask.bmp&quot;, 0, clip.framecount()-1, 24, use_DevIl=false)
#Jednoduchı zpùsob: pøedpokládejme, e èerná je prùhledná&nbsp;
#Jakákoliv jiná barva by byla docela komlikovanìjší*
masktemp = imageYV12.Binarize(17, upper=false, Y=3)
#Nastavíme jasovou masku aby zapadly plochy barevnosti
mask = Mask.FitY2UV()
#Nyní tak máme masku, která nám øíká co chceme zachovat...
#Nahradíme obrazem èásti klipu skryté maskou!
MaskedMerge(clip, image, mask, Y=3, U=3, V=3)
#*øešení: mask = OverlayMask(image, image.BlankClip(&quot;$xxxxxx&quot;), 1, 1)</pre>
<h4><a name="backgournd"></a>8) Náhrada pozadí
</h4>
<p>Tento pøíklad by jistì vypadala lépe v RGB. Abyste se vyhnuly typickım problémùm kvùli
šumu nebo kompresi, radìji pouijte rozmazané verze klipu
a obrazu.
</p>
<pre>source = AviSource(&quot;overlay.avi&quot;).AssumeFPS(24)
#rozmazání (blur) zdroje
clip = source.Blur(1.58).Blur(1.58).Blur(1.58)
#naètìte pozadí pro nahrazení, zachycené z rozmazané sekvence
bgnd = ImageReader(&quot;bgnd.ebmp&quot;, 0, clip.framecount()-1, 24, use_DevIl=false)
#naètìte nové pozadí
new = ImageReader(&quot;new.ebmp&quot;, 0, clip.framecount()-1, 24, use_DevIl=false)
#integrovanı filtr pro vıstupní masku = (clip~overlay?)
mask = OverlayMask(clip, overlay.ConvertToYV12(), 10, 10)
MaskedMerge(source, new.ConvertToYV12(), mask, Y=3, U=3, V=3)</pre>
<h4><a name="mftoon"></a>9) K-mfToon
</h4>
<p>Potøebuje zahrnout více informací (pùvodní url/pøíspìvky) ale prozatím si myslím,
e pùvodní autor filtru mfToon, mf (mf@onthanet.net) na to nebude reagovat
moc vehementnì, zatím to stále není adresováno.<br>
Vıstup funkce uvnitø K-mfToon.avs by mìl bıt identickı s
vıstupem pùvodního mftoon.avs (také zahrnutı), s dvojnásobnou rychlostí.<br>
Poadavky jsou:<br>
- Pro mfToon:<br>
  . naèíst pluginy zvané "MaskTools", "warsharp", "awarsharp" 
</p>
<h2><a name="todo"></a>IV) Na dopracování
</h2>
<p>Nic, vše závisí na zpìtné vazbì<br>
</p>
<h2><a name="disclaimer"></a>V) Odmítnutí záruk
</h2>
<p>Tento plugin je vydáván pod GPL licencí. Musíte souhlasit s podmínkami uvedenımi v
'Copying.txt' pøed pouitím pluginu nebo jeho zdrojového kódu.<br>
<br>
Také se vám doporuèuje pouívat ho ve filantropickém (lidumilném) rozpoloení, t.j. ne ve smyslu "Budu si
tohle tajemství dret pro sebe".<br>
<br>
V neposlední øadì, velmi malá èást všech monıch pouití kadého filtru byla
testována (moná 5% - zbıvá spousta strávenıch hodin pøi ladìní ;-). Proto je
zpìtná vazba velmi vítána (naproti tomu - nedostatek zpìtné vazby - je také skuteèností...)
</p>
<h2><a name="revisions"></a>VI) Revize
</h2>
<p>1.5.8 - 8th August 2005
</p>
<ul>
  <li>Added DEdgeMask2.</li>
</ul>
<p>1.5.7
</p>
<ul>
  <li>Added YUY2LUT.</li>
</ul>
<p>1.5.6</p>
<ul>
  <li>Corrected chroma handling of YV12LUTxy.</li>
</ul>
v1.5.5 - 6 November 2004
<ul>
  <li>Version with binarize working;<br>
    Pentium4 with HT enabled.</li>
</ul>
<p>v1.5.4 - 14 October 2004</p>
<ul>
  <li>A lot of filters which were working in place aren't anymore ( because of an
    AviSynth strangeness which was causing slowdowns ). Before, a filter such as YV12LUT, with U = V = 1, would have had it's chroma left untouched. Now, if you want to preserve the chroma, you have to specify U = V = 2, as it is said in the documentation.</li>
</ul>
<p>1.5.2 - 1.5.3</p>
<ul>
  <li>?</li>
</ul>
<p>1.5.1</p>
<ul>
  <li>Complete rewritting of the documentation ( a huge thanks to Wilbert ).</li>
  <li>DEdgeMask now supports a float divisor. However, if the divisor is integer, it *should* be faster.</li>
  <li>DEdgeMask now has back its parameter "setdivisor", but it's only for backward compatibility with some scripts.</li>
  <li>YV12LUTxy : it's a new filter, implementing the idea presented by Didee on the previous post. The "y" symbol has the value of the collocated pixel in the second clip.</li>
</ul>
<p>1.4.16
</p>
<ul>
  <li>Bugfixes : Logic "min" &amp; "max" modes weren't properly working, it's
corrected.</li>
  <li>Bugfixes : Logic &amp; Subtract weren't using MMX &amp; iSSE
optimizations, due to a very silly bug.
    It's Corrected.</li>
</ul>
<p>1.4.15.3</p>
<ul>
  <li>RGBLUT added : works the same as YV12LUT ( except R, G and B replace Y, U
and V ).</li>
  <li>In addition, you can specify an AMP file ( arbitrary color mapping file
format from photoshop ).</li>
</ul>
<p>1.4.15.2</p>
<ul>
  <li>Bug finally solved on YV12LUT. Silly programming bug, as always...</li>
  <li>In YV12LUT, logical and relationnal operators added ( &lt;, &lt;=, &gt;, &gt;=,
==, !=, &amp;, !&amp;, |, ° ( xor ) )</li>
  <li>In YV12LUT, a ternary operator added : ? ( works as in C )</li>
</ul>
<p>1.4.15.1</p>
<ul>
  <li>In YV12LUT, another bug which was still preventing it from working fine.
Hopefully, it should
    really work now.</li>
</ul>
<p>1.4.15</p>
<ul>
  <li>New Filter : HysteresyMask. It will allow you to build a new edge mask
from two edge masks,
    one only having a few edges ( but we're sure they indeed are edges ), the
other having two
    much edges ( due to a too low thresholding for example ). Look in the
documentation to have
    further explanations.</li>
</ul>
<p>1.4.14.2</p>
<ul>
  <li>Several bugfixes concerning the behavior of negative values for Y, U and
V ( edgemask,
    dedgemask, motionmask, combmask, logic )</li>
  <li>Several bugfixes concerning the use of offX / offY / w and h ( filters
than can use it are :
    maskedmerge, binarize, expand, YV12subtract, yv12lut )</li>
  <li>In YV12LUT, a bug prevented to use it with some filter. It should work
now.</li>
  <li>In YV12Convolution, float coefficients can be used now. If none is used,
all the processing
    will take place with integer, so it will be faster than if you use a float.
Moreover, if<br>
    there is the possibility of overflow ( giving a result over 255 or under 0
) during computation,
    a slower but safe function will be used to saturate computation to 0 and
255.</li>
</ul>
<p>1.4.14.1</p>
<ul>
  <li>Bugfix in YV12LUT to allow the use of negative numbers</li>
</ul>
<p>1.4.14</p>
<ul>
  <li>Bugfix : In YV12Layer, a useless test could prevent the filter to work.
The test has been
    removed</li>
  <li>Bugfix : In DEdgeMask, threshold weren't taken into account. They are
now</li>
  <li>Bugfix : Logic filter is now fully functionnal, in C and MMX</li>
  <li>Added : documentation to Logic filter</li>
  <li>Added : two modes for Logic : "Min" and "Max" ( C, MMX, iSSE )</li>
  <li>Added : In DEdgeMask, the possibility to set the normalization factor</li>
  <li>Corrected : documentation.</li>
</ul>
<p>1.4.13</p>
<ul>
  <li>Bugfix : One more, in the MotionMask ( the last row was not correctly
computed )</li>
  <li>Optimizations : MaskedMerge gives now the same output in MMX and C, so
MMX optimizations
    for it are back by default.</li>
  <li>Added : In EdgeMask, you now can use the laplace kernel. See the
documentation on that
    filter</li>
  <li>Added : 'New' filter, DEdgeMask, which allows you to choose your kernel (
at a cost : 
    speed )</li>
</ul>
<p>1.4.12</p>
<ul>
  <li>Behavior modifications : MotionMask and EdgeMask now also computes pixels
on the borders
    mainly by extending the mask to these pixels.</li>
  <li>Bugfix : Inflate / Inpand / Expand / Deflate, when using negative
parameters for y,u and v, 
    some weird problems could occur.</li>
  <li>Added functionnality : In YV12LUT, the function abs is now defined.</li>
</ul>
<p>1.4.11</p>
<ul>
  <li>Bugfix : EdgeMask, MMX optimizations give different results. They are
disabled by default.
    To activate them, use usemmx = true. They'll be used only with mod 16
resolution</li>
  <li>Bugfix : EdgeMask : first and last lines weren't always
computed. </li>
  <li>Bugfix : MaskedMerge : MMX optimizations darken slightly the picture.
They are disabled by
    default. To activate them, use usemmx = true. They'll be used only with mod
16 resolution.</li>
</ul>
<p>1.4.10</p>
<ul>
  <li>Bugfix : first and last lines were not correctly computed with inflate /
deflate</li>
  <li>Invert is no longer a filter of the Masktools, it has been moved inside
AviSynth.</li>
</ul>
<p>1.4.9</p>
<ul>
  <li>New filter : CombMask. As usual, read further for more documentation</li>
</ul>
<p>1.4.8</p>
<ul>
  <li>YV12Convolution now supports negative coefficients in the matrix. It
allows to use the
    filter has an edge detecter.</li>
  <li>YV12Convolution has now a new parameter : bool saturate, which, if set to
true, 
    or if there is a possibility of getting out of the range [0..255] during
calculation,
    clips each pixel into that range ( which means it's slightly slower )</li>
  <li>A new filter : LUT. Read further for more information on how to use
it.</li>
</ul>
<p>1.4.7</p>
<ul>
  <li>Rename MotionDetection to MotionMask. I know it's kind of silly, but it's
a lot
    more logical that way.</li>
  <li>Add the check of the width for the use MMX in MotionMask</li>
  <li>Slightly modify MMX optimizations in Binarize.</li>
  <li>Add a new filter : YV12Convolution. It allows you to convole the picture
by
    a matrix of (almost) any size. Look further in the readme to learn how to
use it</li>
</ul>
<p>1.4.6</p>
<ul>
  <li>Made the scenechange detection in MotionDetection iSSE optimized (
meaning you
    need an Athlon XP / Pentium IV ). It works with an Athlon XP, it is not
tested with<br>
    an Pentium IV, it is possible to disable it by using usemmx = false in the
paremeters
    of the filter.</li>
  <li>Optimized the calculation of the motion, without using MMX ( just by
avoiding to do 
    3 times the same calculations... ). So the filter should be more or less
three times
    faster.</li>
</ul>
<p>1.4.5</p>
<ul>
  <li>Added MotionDetection filter, no MMX / assembler optimizations for it
yet. Look
    further in the Readme to learn how to use it. It takes the idea of
Sansgrip's filter
    (NoMoSmooth) and outputs the motion mask directly in the correct colorspace
for the
    MaskTools.</li>
</ul>
<p>1.4.4</p>
<ul>
  <li>Reactivated MMX optimizations for MaskedMerge</li>
  <li>Came back to Kurosu's optimizations for Invert</li>
</ul>
<p>1.4.3</p>
<ul>
  <li>Made some MMX optimizations ( binarize, invert )</li>
  <li>Corrected some MMX optimizations ( which means mostly 'disabled some MMX
optimizations' ). It should now work with P4.</li>
</ul>
<p>1.4.2</p>
<ul>
  <li>Fixed bugs concerning the inpand / expand / inflate / deflate
functions</li>
</ul>
<p>1.4.1
</p>
<ul>
  <li>Fixed the dreadly bug "multiple instances of a filter with different
functions needed"</li>
</ul>
<p>1.4.0
</p>
<ul>
  <li>Added an experimental LUT filter. Not tested, debug later.</li>
</ul>
<p>1.3.0 (private version)
</p>
<ul>
  <li>Made usable the FitPlane function (still an overload of work when only
one plane has to be resized) which was previously undocumented;
therefore, added FastFitPlane functions (corresponding FitPlane ones should be
useless now, except for the resizers settings)</li>
  <li>Allowed the specification of a processing area for many filters; however,
this should not produce any noticable speed increase.</li>
  <li>Cleaned YV12Layer (in particular the unusable "Darken"/"Lighten"
modes)</li>
  <li>Added OverlayMask, a function that compares 2 clips, and outputs a mask
of the parts that are identical (slow and far from perfect).</li>
</ul>
<p>1.2.0 (private version)
</p>
<ul>
  <li>YV12Layer: no more useless RGB32 conversion! Approximately the same as
Arithmetic (except a third clip is not used), so that one is gone...</li>
  <li>YV12Substract: hey, why only a C version? Masks are really an underused
feature of AviSynth |-[</li>
</ul>
<p>1.1.0 (private version)
</p>
<ul>
  <li>Older inflate/deflate are renamed expand/inpand while newer functions
replace them</li>
  <li>Logic and Arithmetic functions added (shouldn't produce the expected
results because of no debugging)</li>
  <li>Edgemask now takes 4 thresholds (2 for luma and 2 for chroma). They are
used for:
    setting to 0 or leaving as is a value depending on first threshold, 
setting to 255 or leaving as is a value depending on the second one.</li>
</ul>
<p>1.0.2 (last version - public project dropped):
</p>
<ul>
  <li>Fix the shift for edgemask using sobel and roberts (misplaced MMX
instruction)</li>
  <li>MaskMerge now works (mask cleared before being used... check with
MaskMerge(clip3,clip3) for instance)</li>
</ul>
<p>1.0.1: Initial release
</p>
<h2><a name="developer"></a>VII) Pro vıvojáøe
</h2>
<p>Pøeskoète na V) jestlie vás nezajímá vıvoj dostupnıch nástrojù.<br>
<br>
The project is a VC++ 6 basic project. Each filter has its own folder which
stores the header used by the interface, the source for the function
members, the source for processing functions and its header. Let's look at
EdgeMask:<br>
- EdgeMask.h is included by the interface to know what the filter 'looks like'
(but interface.cpp still holds the definition of the
calling conventions and exported functions)<br>
- EM_func.h describes the different processing functions (they should all have
the same prototype/parameters):<br>
  . Line_MMX and Line_C<br>
  . Roberts_MMX and Roberts_C<br>
  . Sobel_MMX and Sobel_C<br>
- EM_func.cpp, as all &lt;filter's initials&gt;_func.cpp, stores the
implementation of the processing functions, and sometimes their MMX
equivalents.<br>
- EdgeMask.cpp implements the class; the constructor select the appropriate
processing function (MMX? C? Roberts? Line? Sobel?) and uses
it to fill the generic protected function pointer used in GetFrame<br>
<br>
Interface.cpp stores the export function and all of the calling functions
(AVSValue ... Create_&lt;filter&gt;).<br>
<br>
ChannelMode.cpp defines the Channel operating modes. There could be added the
equivalent of a debugprintf.<br>
<br>
This quick walkthrough won't probably help most developers, as the examples of
V) for users, but that's the best I've come with so far. It will improve
of course over time depending on the success of the idea, which main drawback,
speed, will probably make it scarcely used, if ever. &lt;g&gt;
</p>
<p><kbd>$English Date: 2005/10/05 18:12:43 $</kbd>
<p><kbd>Èeskı pøeklad:22.2.2009</kbd>
</p>
</body></html>
