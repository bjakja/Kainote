<html>
<head>
<title>TDeint</title>
<link rel="stylesheet" type="text/css" href="../../avisynth.css">
<!--
Automatically generated, don't change:
$Id: tdeint.htm,v 1.1 2010/02/27 14:50:14 wilbertd Exp $
-->
</head>
<body>
<h1>TDeint</h1>
<h2>Pøehled</h2>
<b>autor:</b>    tritical
<br><b>verze:</b> v1.1<br>
<b>stáhnout:</b>   <a href="http://bengal.missouri.edu/~kes25c/">http://bengal.missouri.edu/~kes25c/</a>,
<a href="http://avisynth.org/warpenterprises/">http://avisynth.org/warpenterprises/</a>
<br><b>kategorie:</b>   Odstraòování prokládání &amp; pulldown
<br><b>požadavky:</b>&nbsp;
<ul>
  <li>YV12 &amp; YUY2 barevné prostøedí</li>
</ul>

<p><b>licence:</b> GPL</p>

<hr size=2 width="100%" align=center>

<!-- #EndTemplate -->
<h2>Popis</h2>
<p>TDeint je dvousmìrový, pohybovì adaptivní, ostrý odstraòovaè prokládání (deinterlacer). Mùže adaptivnì
volit mezi použitím pohybové adptivity po-polích a po-pixelelech, a mùže použít kubickou interpolaci,
jádrovou (kernel) interpolaci (s pøepínáním èasového smìru), nebo jednu ze dvou forem modifikované ELA
interpolace která pomùže snížit "vroubkované" hrany v pohybových oblastech, kde musí být použita interpolace.
TDeint také podporuje uživatelské pøepisování pomocí vstupního souboru, a mùže pracovat jako smart bobber nebo
deinterlacer se stejnou frekvencí snímkù, stejnì jako IVTC post-processor.</p>
<h3>Syntaxe</h3>
<p><code>TDeint</code> (clip, int <var>&quot;mode&quot;</var>, int <var>&quot;order&quot;</var>,
int <var>&quot;field&quot;</var>, int <var>&quot;mthreshL&quot;</var>, int <var>&quot;mthreshC&quot;</var>,
int <var>&quot;map&quot;</var>, string <var>&quot;ovr&quot;</var>, int <var>&quot;ovrDefault&quot;</var>,
int <var>&quot;type&quot;</var>, bool <var>&quot;debug&quot;</var>, int <var>&quot;mtnmode&quot;</var>,
bool <var>&quot;sharp&quot;</var>, bool <var>&quot;hints&quot;</var>, PClip <var>&quot;clip2&quot;</var>,
bool <var>&quot;full&quot;</var>, int <var>&quot;cthresh&quot;</var>, bool <var>&quot;chroma&quot;</var>,
int <var>&quot;MI&quot;</var>, bool <var>&quot;tryWeave&quot;</var>, int <var>&quot;link&quot;</var>,
bool <var>&quot;denoise&quot;</var>, int <var>&quot;AP&quot;</var>, int <var>&quot;blockx&quot;</var>,
int <var>&quot;blocky&quot;</var>, int <var>&quot;APType&quot;</var>, PClip <var>"edeint"</var>,
PClip <var>"emask"</var>, float <var>"blim"</var>, int <var>"metric"</var>, int <var>"expand"</var>,
int <var>"slow"</var>, PClip <var>"emtn"</var>, bool <var>"tshints"</var>, int <var>"opt"</var>)</p>


<h3>PARAMETRY</h3>


<p><var>mode</var>:</p>
<ul>
<p>Nastavuje režim operace.  Režimy -2 a -1 vyžadují progresivní vstup.</p>
<ul>
<li>-2 - dvojitá výška použitím modifikované ELA
<li>-1 - dvojitá výška použitím modifikované ELA-2
<li>&nbsp;0 - výstup se stejnou frekvencí snímkù
<li>&nbsp;1 - dvojnásobná frekvence snímkù (bobbing)
<li>&nbsp;2 - smartbobbing se srovnáváním polí (výstup se stejnou frekvencí snímkù, smíchané snímky ze streamu po bobbingu)
</ul>
<p>výchozí -&nbsp;&nbsp;0  (int)</p>
</ul>


<p><var>order</var>:</p>
<ul>
<p>Nastavuje poøadí polí videa.</p>
<ul>
<li>-1 - použije paritu z Avisynthu
<li>&nbsp;0 - spodní pole první (bottom field first - bff)
<li>&nbsp;1 - horní pole první (top field first - tff)
</ul>
<p>výchozí -&nbsp;&nbsp;-1  (int)</p>
</ul>


<p><var>field</var>:</p>
<ul>
<p>Když je nastaven mode 0 a 1, pole budou interpolována.  Když je vybrán mode -1, nedìlá
toto nastavení nic.</p>
<ul>
<li>-1 - nastaví pole rovno order pokud hints = false nebo na 0 pokud hints = true
<li>&nbsp;0 - interpoluje horní pole (zachovává spodní pole)
<li>&nbsp;1 - interpoluje spodní pole (zachovává horní pole)
</ul>
<p>výchozí -&nbsp;&nbsp;-1  (int)</p>
</ul>


<p><var>mthreshL</var>/<var>mthreshC</var>:</p>
<ul>
<p>Prahové hodnoty pohybu pro jas - luma a barevnost - chroma (mthreshL pro jas, mthreshC pro barevnost). Pokud
rozdíl mezi dvìma pixely je menší než tato hodnota jsou deklarovány jako statické.
Menší hodnoty sníží zbytkové roztøepení, vetší hodnoty zeslabí blikání a
zlepší pøesnost konstrukce polí ve statických oblastech.  Prostorovì (spatially) odpovídající
èásti jasových a barevnostních ploch jsou provázané (pokud link != 0), takže mthreshC a mthreshL
mohou být ponìkud propojeny.  Nastavení obou hodnot na 0 nebo níže vypne pohybovou
adaptaci t.j. každý pixel bude deklarován pohybový) což umožní hloupý bob.</p>
<p>výchozí -&nbsp;&nbsp;<var>mthreshL</var> - 6  (int)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var>mthreshC</var> - 6  (int)</p>
</ul>


<p><var>map</var>:</p>
<ul>
<p>Zobrazuje výstupní mapu místo snímku s odstranìným prokládáním.  Je zde pìt možností.</p>
<ul>
<li>0 - Bez mapy.
<li>1 - hodnota (binární) mapy.  Toto vysílá snímek, ve kterém všechny pixely mají jednu z následujících
        hodnot (indikujících jak má být snímek konstruován):
                 <ul>
                 <li>0   (použije pixel z aktuálního snímku)
                 <li>51  (použije pixel z pøedchozího snímku)
                 <li>102 (použije pixel z následujícího snímku)
                 <li>153 (použije prùmìr z aktuálního/následujícího)
                 <li>204 (použije prùmìr z aktuálního/pøedchozího)
                 <li>230 (použije [1 2 1] prùmìr z pøedch/akt/násl)
                 <li>255 (interpoluje pixely)
                 </ul>
<li>2 - Slouèená mapa.  Toto vysílá snímek, ve kterém všechny statické èásti snímku (hodnoty
        0, 51, 102, 153, 204, a 230 z map=1) byly konstruovány jako by se objevily v
        deinterlovaném snímku a pixely které mají být interpolovány jsou oznaèeny bíle (255).
<li>3 - Vysílá snímek s odstranìným prokládáním a hodnotou (binární) mapy naskládanou vertikálnì (mapa je dole).
<li>4 - Vysílá snímek s odstranìným prokládáním a slouèenou mapou naskládanou vertikálnì (mapa je dole).


</ul>
<p>výchozí -&nbsp;&nbsp;0  (int)</p>
</ul>


<p><var>ovr</var>:</p>
<ul>
<p>Nastavuje jméno a cestu k nadøazovacímu souboru.  Pøi mode=0, mùže být nadøazovací soubor
použit pro ovládání hodnot <var>mthreshL</var>, <var>mthreshC</var>, <var>field</var>, <var>order</var>, a
<var>type</var> pro jednotlivé snímky nebo pro rozsahy snímkù, a také øízení, které snímky jsou
deinterlovány. Pøi mode=1, mùže být použit nadøazovací soubor pro ovládání hodnot <var>mthreshL</var>,
<var>mthreshC</var>, a <var>type</var> pro zadané snímky nebo rozsahy snímkù.</p>
<p>Specifikátory nadøazovacích souborù:</p>
<ul>
<li>+ = oznaèuje snímek, ve kterém má být odstraòováno prokládání (užiteèný jen pøi ovrDefault = 1)
<li>- = oznaèuje snímek, ve kterém nemá být odstraòováno prokládání
<li>f = field
<li>o = order
<li>l = mthreshL
<li>c = mthreshC
<li>t = type
<p>*specifikátory c, f, o, l, t zadávají také požadovanou zmìnu hodnoty, která má být zadána, když jsou použity
(podívejte se na syntaxi nadøazení, aby jste vidìli jak je to provedeno)</p>
</ul>
<p>Syntaxe nadøazení:</p>
<ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;[] = nevyžadováno pro specifikátory +, - </p>
<DL>
  <DT>nadøazení (pøepsání) pro jeden snímek:
  <DD><br>èíslo_snímku specifikátor [zmìnìná_hodnota]
  <DD><br>pøíklady:<ul>
<pre>
245 f 1
345 +
400 -
450 c -1
</pre></ul><br>
  <DT>nadøazení pro rozsah snímkù:
  <DD><br>èíslo_prvního_snímku,èíslo_posledního_snímku specifikátor [zmìnìná_hodnota]
  <DD><br>pøíklady:<ul>
<pre>
100,200 +
346,352 f 0
900,1200 l 5
</pre></ul><br>
<DD>** Rozsah se zahrnuje, to znamená, že i první a poslední snímek rozsahu jsou zahrnuty.
<DD><br>Pøepsání pro rozsah snímkù podle šablony (jen pro specifikátory +,- ):
<DD><br>pøíklady:<ul>
<pre>
100,300 +-+++--+++
400,456 ---+---++
</pre></ul><br>
<DD>** Použije zadanou šablonu na zadaný rozsah snímkù.
</DL>
</ul>
<p>Vìci pro zapamatování (klíèové body/pravidla):</p>
<ul>
<ol>
  <li>Rozsahy se zahrnují
  <li>Pøi mode = 1 (bobbing) všechna nadøazení , kromì mthreshL/mthreshC, a nadøazení type jsou ignorována.
        Také èísla snímkù odpovídají vstupnímu klipu a ne výstupnímu, takže jeden snímek bude dvìma snímky
        na výstupu.
  <li>Zmìnìná hodnota je vždy nastavena zpìt na pùvodní nastavení poté, kdy se nadøazená hodnota dostane mimo
        zadaný rozsah. (t.j. pokud zadáte nadøazenou mthresh pro snímky 600 až 700, po
        snímku 700 je mthresh automaticky nastaven zpìt na svou pùvodní hodnotu, nemusíte ho nastavovat zpátky v
        nadøazovacím souboru!  Pùvodní hodnota je ta, která byla nastavena pøi naètení (t.j. buï výchozí
        nebo ta, která byla nastavena ve vašem skriptu).
  <li>Èísla snímkù musí být v rozsahu daného souboru.
  <li>Èísla snímkù pro zadané specifikátory musí být rostoucí (pokud nejsou, tak prvoøadé budou poslední údaje v
        souboru t.j. pokud zadáte 300,400 c 10 a pak 350,450 c 12, snímky 350 až 400
        použijí 12 a ne 10).
  <li>Èísla snímkù pro specifikátory (+, -) nelze pøekrývat (napø. nedìlejte 300,400 - a pak pozdìji v
        souboru psát 350,500 + nebo se stanou divné vìci.  Další specifikátory nemusí splòovat tento
        požadavek, protože všechny pùsobí na jiné vìci.
  <li>+, - specifikátory nevyžadují žádné zmìny hodnot.
  <li>Mezery jsou dùležité! Podívejte se na pøíklady.
  <li>Jen specifikátory +, - lze použít v zadávací šablonì.
  <li>Mùžete zmìnit více specifikátorù na stejném rozsahu snímkù pokud budete dodržovat pravidla uvedená výše
        (+, - napøíklad rostoucí èísla snímkù).
  <li>Mùžete okomentovat øádek (t.j. bude ignorován) pøidáním znaku '#' nebo ';' na zaèátek øádku.
  <li>Zadání 0 jako koncový_snímek v rozsahu snímkù znamená, že se bere poslední snímek videa.
</ol>
</ul>
<p>Pøíklady nadøazovacích souborù:</p>
<ul>
<p>Pøíklad syntaxe => TDeint(order=1,ovr=&quot;c:\path\myoverridesfile.txt&quot;)</p>
<pre>
100,300 o 0
100,300 f 1
90,250 c 3
40,500 -
505 -
300,700 l -1
#700,3000 f 1 &lt;- okomentování, bude ignorováno
800,1000 -++-
500,1000 c 13
</pre>
</ul>
<p>výchozí -&nbsp;&nbsp;""  (string)</p>
</ul>


<p><var>ovrDefault</var>:</p>
<ul>
<p>Pøi použití nadøazovacího souboru v režimu 0, zadává výchozí akci pro všechny snímky ve videu.
Použití ovrDefault=1 usnadòuje odstranit prokládání jen v nìkolika zadaných snímcích ve videu.  Když je mode = 1,
neudìlá toto nastavení nic.</p>
<ul>
<li>0 - ve všech snímcích nespecifikovaných v nadøazovacím souboru jako '-', se odstraní prokládání
<li>1 - ve všech snímcích nespecifikovaných v nadøazovacím souboru jako '+' se odstraní prokládání a jsou jednoduše vráceny jaké jsou
</ul>
<p>výchozí -&nbsp;&nbsp;0  (int)</p>
</ul>


<p><var>type</var>:</p>
<ul>
<p>Nastavuje typ použité interpolace.  Kubická je nejrychlejší, modifikovaná ELA a ELA2 dají
hladší, ménì "vroubkované", hrany a jsou nejpomalejší (ELA2 je rychlejší), a jádrová (kernel) interpolace
významnì více sníží blikání než kubická nebo ela, když se interpolace použije v témìø statických
oblastech.  Modifikované ELA a ELA2 pracují nejlépe s animovaným materiálem... nejsou tak skvìlé u
živých zdrojù (obèas ale jsou, vyzkoušejte sami).</p>
<ul>
<li>0 - kubická interpolace
<li>1 - modifikovaná ELA interpolace
<li>2 - kernel (jádrová) interpolace (mùže být normální nebo ostrá, ovládaná nastavením ostrosti)
<li>3 - modifikovaná ELA-2 interpolace
<li>4 - blend (smíchaná) interpolace
<li>5 - dvousmìrná blend interpolace

</ul>
<p>výchozí -&nbsp;&nbsp;2  (int)</p>
</ul>


<p><var>debug</var>:</p>
<ul>
<p>Zapne ladící výstup, který pro každý snímek zapíše hodnoty <var>order</var>, <var>field</var>,
<var>mthreshL</var>, <var>mthreshC</var>, a <var>type</var> , pokud je ve snímku odstraòováno prokládání.  Pokud
ve snímku není odstraòováno prokládání (kvùli uživatelskému pøepsání, <var>hints</var>, nebo <var>full</var>=false),
prostì øekne, že ve snímku se prokládání neodstraòuje a uvede specifický dùvod. Pokud je výstupní snímek složen (weaved),
ladící výstup oznámí, se kterým polem bylo aktuální pole spojeno (weaved) (PREV nebo NEXT).  Ladící
informace je výstup využívající OutputDebugString().  Pro zobrazení výstupu mùžete použít
<a href="http://www.sysinternals.com/Utilities/DebugView.html">DebugView</a> ze Sysinternals.</p>
<p>výchozí -&nbsp;&nbsp;false  (bool)</p>
</ul>


<p><var>mtnmode</var>:</p>
<ul>
<p>Ovládá zda je použita kontrola pohybu po 4 polích nebo po 5 polích.  5 polová zabrání více
artefaktùm a mùže pracovat s duplikovanými prokládanými snímky; nicménì, je docela pomalejší než 4 polová
kontrola pohybu.  Režimy 2 a 3 jsou jako 0 a 1 kromì toho, že v oblastech, kde by byl použit prùmìr pøedchozího a následujícího
pole). T.j. není použit žádný prùmìr).</p>
<ul>
<li>0 - 4 polová kontrola
<li>1 - 5 polová kontrola
<li>2 - 4 polová kontrola (žádné prùmìry, nahrazuje nejpodobnìjším polem)
<li>3 - 5 polová kontrola (žádné prùmìry, nahrazuje nejpodobnìjším polem)
</ul>
<p>výchozí -&nbsp;&nbsp;1  (int)</p>
</ul>


<p><var>sharp</var>:</p>
<ul>
<p>Ovládá zda je použito ostré nebo normální jádro pøi použití jádrové interpolace (<var>type</var> = 2).
Ostré jádro zahrnuje více pixelù a vytváøí ostøejší výsledek, ale je mírnì pomalejší.</p>
<ul>
<li>true - použije ostré jádro
<li>false - použije normální jádro
</ul>
<p>výchozí -&nbsp;&nbsp;true  (bool)</p>
</ul>


<p><var>hints</var>:</p>
<ul>
<p>Ète údaje (hints) z telecide nebo tfm udávající, které snímky jsou prokládané a které nejsou, pokud jsou údaje
pøítomny ve video streamu.  Aby to takto pracovalo potøebujete nastavit post=1 v telecide nebo PP=1 v tfm
a vložit TDeint hned za nì.  TDeint neovlivní údaje (dokud má vaše video šíøku
minimálnì 64 pixelù) v pøípadì jakýchkoli filtrù umístìných dále, které potøebují tyto údaje èíst.  Pokud je hints nastaven na true,
ale žádné údaje z telecide nebo tfm nejsou ve video stremu detekovány, pak bude odstraòováno prokládání u všech snímkù
(TDeint bude pracovat jako pøi hints=false).  Pokud nezadáte hodnotu pro hints výslovnì, pak
TDeint zkontroluje jestli jsou údaje hints ve streamu pøítomny pøi naètení a nastaví hints na true pokud pøítomny jsou
nebo false pokud pøítomny nejsou (t.j. je nastaven automaticky).</p>
<p>**Poznámka:  pro IVTC post-processing se ètením údajù hints se doporuèuje použít TDeint v
následující podobì s použitím parametru clip2.</p>
<ul>
<pre>
orig = last
fieldmatcher()
TDeint(clip2 = orig)
</pre><br>
<li>true - ète hints pokud jsou pøítomny
<li>false - neète hints
</ul>
<p>výchozí -&nbsp;&nbsp;automaticky detekováno pøi naètení  (bool)</p>
</ul>


<p><var>clip2</var>:</p>
<ul>
<p>Pokud používáte tdeint jako postprocessor pro telecide nebo tfm pøes údaje parametru hints (nebo jakéhokoli srovnávaèe polí),
mùže nastat nesprávné odstranìní prokládání kvùli skuteènosti, že telecide mìní poøadí polí v pùvodním
streamu (je to konec koncù srovnávaè snímkù).  To mùže zpùsobit problémy v nìkterých pøípadech protože TDeint
opravdu potøebuje mít pùvodní stream.  Aby jste s tím mohli pracovat, mùžete zadat druhý klip "clip2"
pro TDeint aby provedl skuteèné odstranìní prokládání.</p>
<p>Ve skriptu je jak by to mìlo vypadat:</p>
<pre>
mpeg2source(&quot;c:\mysource.d2v&quot;)
orig = last
telecide(guide=1, order=1, hints=true, post=1)
tdeint(order=1, clip2=orig)
</pre>
<p>Tedy TDeint ète výstupní klip z telecide jako obvykle.  Když hints ukazují na prokládaný
snímek, provádí odstranìní prokládání ve snímku pomocí klipu clip2.  Tato metoda také zachová hints
ve výstupním streamu takže jakékoli další filtry, které pozdìji potøebují budou stále pracovat.</p>
<p>Pøidáním full=false, máme další zpùsob použití TDeint jako post-processoru
použije svou vlastní detekci roztøepení snímku jako následující (toto také umožòuje aby to pracovalo
s jakýmkoli srovnávaèem snímkù, ne jen telecide nebo tfm):</p>
<pre>
mpeg2source(&quot;c:\mysource.d2v&quot;)
orig = last
fieldmatcherofchoice()
tdeint(order=1, full=false, clip2=orig)
</pre>
<p>výchozí -&nbsp;&nbsp;NULL  (PClip)</p>
</ul>


<p><var>full</var>:</p>
<ul>
<p>Když je full nastaveno na true, tak jsou všechny snímky zpracovány jako obvykle.  Když full=false, tak jsou všechny snímky
nejdøív kontrolovány zda jsou roztøepené.  Pokud snímek není roztøepený, tak je vrácen jaký je.
Pokud je snímek roztøepený, tak je zpracován jako obvykle.  Parametry, které ovlivòují detekci roztøepeného snímku
jsou <var>cthresh</var>, <var>chroma</var>, <var>blockx</var>, <var>blocky</var>, a
<var>MI</var>. full=false umožní TDeint aby byl ivtc post-processorem bez potøeby údajù hints.</p>
<ul>
<li>true - normální zpracování
<li>false - kontroluje nejdøív všechny vstupní snímky na roztøepení
</ul>
<p>výchozí -&nbsp;&nbsp;true  (bool)</p>
</ul>


<p><var>cthresh</var>:</p>
<ul>
<p>Prahová hodnota oblasti s roztøepením použitá pro detekci roztøepených snímkù.  Je jako dthresh nebo dthreshold
v telecide() a fielddeinterlace().  Zásadnì ovlivòuje jak "silné" nebo "viditelné" roztøepení
musí být, aby bylo detekováno.  Dobré hodnoty jsou od 6 do 12. Pokud víte, že váš zdroj má hodnì roztøepených
snímkù, nastavte ho blíže ke spodní hranici (6-7). Pokud víte, že váš zdroj má velmi málo roztøepených snímkù
nastavte ho výše (10-12).  Jít níže než 5 až 6 nebo mnohem výše než 12 se nedoporuèuje.</p>
<p>výchozí -&nbsp;&nbsp;6  (int)</p>
</ul>


<p><var>blockx</var>:</p>
<ul>
<p>Nastavení velikosti bloku v ose x, použitého k detekci roztøepení snímku.  Souvisí to s
velikostí oblasti, ve které je vyžadován poèet <var>MI</var> pixelù, aby byl snímek detekován jako
roztøepený.  Podívejte se na popis parametru <var>MI</var> pro více informací.  Možné
hodnoty jsou jakékoliv èíslo, které je mocninou 2 poèínaje 4 až do 2048 (napø. 4, 8, 16, 32, ... 2048).</p>
<p>výchozí -&nbsp;&nbsp;16  (int)</p>
</ul>


<p><var>blocky</var>:</p>
<ul>
<p>Nastavení velikosti bloku v ose y, použitého k detekci roztøepení snímku.  Souvisí to s
velikostí oblasti, ve které je vyžadován poèet <var>MI</var> pixelù, aby byl snímek detekován jako
roztøepený.  Podívejte se na popis parametru <var>MI</var> pro více informací.  Možné
hodnoty jsou jakékoliv èíslo, které je mocninou 2 poèínaje 4 až do 2048 (napø. 4, 8, 16, 32, ... 2048).</p>
<p>výchozí -&nbsp;&nbsp;16  (int)</p>
</ul>


<p><var>chroma</var>:</p>
<ul>
<p>Zahrnuje roztøepení barevnosti (chroma) do rozhodování o tom zda je snímek roztøepený.  Použijte ho jen když
máte jeden z takových podivných zdrojù, kde mùže být barevnost doèasnì oddìlená od jasu (luma)
(t.j. barevnost se v poli hýbe, ale jas ne).  Jinak to vìtšinou pøi pøijetí øešení nadìlá
spíš škodu.</p>
<ul>
<li>true - zahrne roztøepení barevnosti
<li>false - nezahrne
</ul>
<p>výchozí -&nbsp;&nbsp;false  (bool)</p>
</ul>


<p><var>MI</var>:</p>
<ul>
<p>Poèet požadovaných roztøepených pixelù uvnitø nìkterých blokù s velikostmi <var>blockx</var> na <var>blocky</var>
ve snímku, aby byl snímek považovaný za roztøepený.  Zatímco <var>cthresh</var> ovládá jak "viditelné"
nebo "silné" musí roztøepení být, toto nastavení ovládá kolik roztøepení musí být v každé lokalizované oblasti (blok o velokosti
<var>blockx</var> na <var>blocky</var> ) snímku.  Minimální nastavení = 0, maximální nastavení =
<var>blockx</var> x <var>blocky</var> (bod ve kterém žádné snímky nikdy nebudou detekovány jako roztøepené).</p>
<p>výchozí -&nbsp;&nbsp;64  (int)</p>
</ul>


<p><var>tryWeave</var>:</p>
<ul>
<p>Pokud je nastaven na true, když TDeint odstraòuje prokládání ve snímku, vypoèítá nejdøív které pole (pøedchozí nebo následující)
je nejpodobnìjší aktuálnímu poli.  To pak pøipojí (weave) pro vytvoøení nového snímku a kontroluje tento
nový snímek na roztøepení.  Pokud nový snímek není roztøepený, tak ho vrátí. Pokud je, tak v nìm
odstraní prokládání s použitím obvyklé pohybové adaptaci po-pixelech.  V podstatì toto nastavení umožní TDeint
zkusit použít pohybovou adaptaci po polích místo po-pixelech kde je to možné.</p>
<p>výchozí -&nbsp;&nbsp;false  (bool)</p>
</ul>


<p><var>link</var>:</p>
<ul>
<p>Ovládá jak jsou tøi plochy (Y, U, a V) provázány pøi tvorbì mapy roztøepení. Možná nastavení:</p>
<ul>
<li>0 - žádné provázání
<li>1 - Plné provázání (každá plocha s každou jinou)
<li>2 - Y k UV (jas k barevnosti)
<li>3 - UV k Y (barevnost k jasu)
</ul>
<p>výchozí -&nbsp;&nbsp;2  (int)</p>
</ul>


<p><var>denoise</var>:</p>
<ul>
<p>Ovládá zda mapa roztøepení je zbavována šumu nebo ne.  True zapíná odšumìní, false ho vypíná.</p>
<p>výchozí -&nbsp;&nbsp;false  (bool)</p>
</ul>


<p><var>AP</var>:</p>
<ul>
<p>Prahová hodnota ochrany pøed artefakty.  Pokud je AP nastaveno na hodnotu vìtší nebo rovnu 0, tak pøed
pøedáním snímku s odstranìným prokládáním TDeint pøeskenuje všechny pøipojené (weaved) pixely, aby poznal jestli nìjaký vytváøí hodnotu
vìtší než AP.  Všechny pixely, které budou takové pak budou interpolovány.  Použijte tuto pomoc pro ochranu pøed velmi zøetelnými
artefakty souvisejícími s pohybovou adaptavitou. Doporuèuje se velká hodnota AP (25+, neboli èím vìtší tím více odstraní artefaktù,
které lze vidìt pøi plné rychlosti pøehrávání), a menší hodnoty nièí
výhody pohybové adaptivity ve statických oblastech bohatých na detaily.  AP metrika je stejná jako u <var>cthresh</var>
metriky... takže rozsah je 0-255. Pøi nule bude detekováno vše kromì úplnì rovných oblastí jako
roztøepení. Pøi 255 nebude detekováno nic. Použití AP zpomalí zpracování. Natavte AP hodnotu menší
než 0 vìtší než 254 pro vypnutí.</p>
<p>výchozí -&nbsp;&nbsp;-1 (vypnuto)  (int)</p>
</ul>


<p><var>APType</var>:</p>
<ul>
<p>Když se má použít <var>AP</var> post-processing (<var>AP</var> bude nastaveno >= 0 a < 255), APType
ovládá zda by mìl být zahrnut pohyb okolních pixelù.  Jsou 3
možná nastavení:</p>
<ul>
<li>0 = Nezahrnuje okolní pohyb.  Jestli pøipojený (weaved) pixel vytváøí hodnotu, která
        pøesáhne prahovou hodnotu AP tak bude interpolován.
<li>1 = Jestli pøipojený (weaved) pixel vytváøí hodnotu, která pøesáhne prahovou hodnotu AP a nejménì polovina
        pixelù v oknì 5x5 s daným pixelem ve støedu je také detekovaná jako pohyblivá, pak takový
        pixel bude interpolován.
<li>2 = Pøesnì jako 1, kromì toho, že místo 1/2 pixelù musí být detekována jako pohyblivá 1/3 pixelù v okolním oknì 5x5.
</ul>
<p>Režimy 1 a 2 poskytují zpùsob pro podchycení více artefaktù (nižší hodnoty AP) bez úplného
obìtování statických oblastí.</p>
<p>výchozí -&nbsp;&nbsp;1  (int)</p>
</ul>


<p><var>edeint</var>:</p>
<ul>
<p>Umožòuje zadat externí klip ze kterého budou brány interpolované pixely místo
toho aby TDeint použil své interpolaèní metody.  Pokud je klip zadán, pak
TDeint zpracuje všechno jako obvykle kromì toho, že místo svého výpoètu interpolovaných pixelù
vezme potøebné pixely z odpovídající prostorových (spatial) pozic ve stejném snímku
klipu edeint.  Pro vypnutí použití klipu edeint jednoduše nezadávejte hodnotu pro edeint.</p>
<p>výchozí -&nbsp;&nbsp;NULL (PClip)</p>
</ul>


<p><var>emask</var>:</p>
<ul>
<p>Umožòuje zadat externí klip ze kterého bude brána maska pohybu místo
vnitøní masky vestavìné v TDeint.  Použití této možnosti zpùsobí, že následující parametry
TDeint nebudou mít žádný vliv:  <var>mthreshL</var>, <var>mthreshC</var>, <var>mtnmode</var>, <var>denoise</var>,
<var>link</var>.  Hodnoty, které mohou být pøítomny v masce pohybu snímkù jsou definovány
následovnì:</p>
<ul>
<li>10 - Použít pixel z aktuálního snímku
<li>20 - Použít pixel z pøedchozího snímku
<li>30 - Použít pixel z následujícího snímku
<li>40 - Použít prùmìr pixelù z aktuálního a následujícího
<li>50 - Použít prùmìr pixelù z aktuálního a pøedchozího
<li>60 - Interpolace
<li>70 - Použít [1 2 1] smíchání (blend)) pixelù z pøedch/akt/násl
</ul>
<p>Pro jiné hodnoty je chování nedefinované, ale mìlo by se s nimi skonèit pracovat pøi vnitøním zporování
že byly rovny 60.</p>
<p>výchozí -&nbsp;&nbsp;NULL (PClip)</p>
</ul>


<p><var>blim</var>:</p>
<ul>
<p>Nastavuje maximální hodnotu rozdílu pro režim 2.  Pokud oba rozdíly (zdroj-pøedchozí a zdroj-následující) jsou
nad touto hodnotou tak je zdroj vrácen jaký je.  Jinak je zdroj smíchán (blended) s buï pøedchozím nebo následujícím
podle toho, který je podobnìjší zdrojovému.  Tato hodnota je v rozsahu 0.0 až 100.0 , na základì rozdílu jasového kanálu.
Použijte debug=true aby jste vidìli generované hodnoty rozdílu a limitní hodnotu.  Ladící (debug)
výstup bude vypadat následovnì:</p>
<pre>[5776] TDeint:  frame 0:  d1 = 0  d2 = 0  lim = 1513728</pre>
<p>d1 je rozdíl zdroj-pøedchozí a d2 je rozdíl zdroj-následující.  lim je maximální hodnota
pøevedené z desetinné (float) hodnoty do dlouhého celého èísla bez oznaèení.  Nastavte blim na zápornou hodnotu
pro vypnutí kontroly (zdroj bude vždy smíchán (blended) s buï pøedchozím nebo následujícím).</p>
<p>výchozí -&nbsp;&nbsp;-2.0  (float)</p>
</ul>


<p><var>metric</var>:</p>
<ul>
<p>Nastavuje, jaká prostorová (spatial) metrika roztøepení se použije pro detekci roztøepených pixelù.  Možnosti:</p>
<ul>
<p>Pøedpokládejme 5 sousedních pixelù (a,b,c,d,e) umístìných svisle.</p>
<ul><p>
a<br>
b<br>
c<br>
d<br>
e<br>
</p></ul>
<pre>
0:  d1 = c - b;
    d2 = c - d;
    jestli ((d1 > cthresh && d2 > cthresh) || (d1 < -cthresh && d2 < -cthresh))
    {
       jestli (abs(a+4*c+e-3*(b+d)) > cthresh*6) je roztøepený;
    }

1:  val = (b - c) * (d - c);
    jestli (val > cthresh*cthresh) je roztøepený;
</pre>
</ul>
<p>Metrika 0 je ta, kterou tdeint vždy používal døíve do v1.0 RC7.  Metrika 1 je metrikou roztøepení
použitou ve funkcích Donalda Grafta FieldDeinterlace()/IsCombed() v pluginu decomb.dll.</p>
<p>výchozí -&nbsp;&nbsp;0  (int)</p>
</ul>


<p><var>expand</var>:</p>
<ul>
<p>Nastavuje poèet pixelù pro expanzi masky roztøepení horizontálnì na každé stranì roztøepených pixelù.
V podstatì pokud je expanze vìtší než 0 tak TDeint  považuje všechny pixely uvnitø horizontální vzálenosti 'expand'
detekovaného roztøepeného pixelu také za roztøepené.</p>
<p>výchozí -&nbsp;&nbsp;0  (int)</p>
</ul>


<p><var>slow</var>:</p>
<ul>
<p>Nastavuje, která funkce srovnávání polí bude použita.  Tyto funkce srovnávají odpovídající funkce
v tfm.  Možné hodnoty:</p>
<ul>
<li>0 - normální  (mìla by být ménì pøesná)
<li>1 - pomalejší
<li>2 - nejpomalejší (mìla by být nejpøesnìjší)
</ul>
<p>výchozí -  1&nbsp;&nbsp;(int)</p>
</ul>


<p><var>emtn</var>:</p>
<ul>
<p>Zadává externí klip, který TDeint použije pro detekci pohybu místo té, která bìží na
vstupním klipu. Vstupní klip je stále používán pro odstranìní prokládání.  Klip <var>emtn</var> je jednoduše použit pro
poèítané zmìny pixelù mezi snímky.</p>
<p>výchozí -  NULL&nbsp;&nbsp;(PClip)</p>
</ul>


<p><var>tshints</var>:</p>
<ul>
<p>Zapíná vysílání údajù (hints) pro použití v TSwitch().  Pokud je  TSwitch používáno po TDeint tak nastavte toto na
true.  Jinak nastavte false.</p>
<p>výchozí -  false&nbsp;&nbsp;(bool)</p>
</ul>


<p><var>opt</var>:</p>
<ul>
<p>Ovládá, které cpu optimalizace jsou použity.  Možná nastavení:</p>
<ul>
<li>0 - použít c rutiny
<li>1 - použít mmx rutiny
<li>2 - použít isse rutiny
<li>3 - použít sse2 rutiny
<li>4 - autodetekovat
</ul>
<p>výchozí -&nbsp;&nbsp;4  (int)</p>
</ul>


<hr size=2 width="100%" align=center>



<h2>TSwitch</h2>

<p>TSwitch je schopen èíst údaje (hints) z TDeint které ukazují, ve kterých snímcích bylo odstranìno prokládání nebo ne.  Na základì
tìchto hints pak TSwitch doruèí snímky z jednoho ze dvou klipù (<var>c1</var> nebo <var>c2</var>).  Pokud ve vstupním snímku nebylo odstranìno
prokládání, tak je vrácen odpovídající snímek z klipu <var>c1</var> .  Pokud ve vstupním snímku bylo odstranìno
prokládání, tak je vrácen odpovídající snímek z klipu <var>c2</var> .</p>
<p>Pro použití TSwitch, musíte nastavit <var>tshints</var>=true v TDeint a umístit TSwitch hned za TDeint ve
vašem Avisynth skriptu.</p>
<p>Dùvody proè ve snímcích nemuselo být odstranìno prokládání pomocí TDeint jsou pøepsání (nadøazení), hints, full=false, nebo
tryweave=true.</p>

<h3>Syntaxe</h3>
<p><code>TSwitch</code> (clip, clip <var>&quot;c1&quot;</var>, clip <var>&quot;c2&quot;</var>,
bool <var>&quot;debug&quot;</var>)</p>

<h3>PARAMETRY</h3>

<p><var>c1</var>:</p>
<ul>
<p>Nastavuje klip pro navrácení snímkù, když ve vstupním snímku nebylo odstraòováno prokládání.</p>
<p>výchozí -  NULL&nbsp;&nbsp;(PClip)</p>
</ul>

<p><var>c2</var>:</p>
<ul>
<p>Nastavuje klip pro navrácení snímkù, když ve vstupním snímku bylo odstraòováno prokládání.</p>
<p>výchozí -  NULL&nbsp;&nbsp;(PClip)</p>
</ul>

<p><var>debug</var>:</p>
<ul>
<p>Zapíná ladící výstup, který u každého snímku øekne jestli bylo ve vstupním snímku odstraòováno prokládání nebo ne, a
z kterého z klipù (<var>c1</var> nebo <var>c2</var>) je brán výstupní snímek.  Ladící informace
je vysílána pomocí OutputDebugString().  Pro zobrazení výstupu mùžete použít
<a href="http://www.sysinternals.com/Utilities/DebugView.html">DebugView</a> ze Sysinternals.</p>
<p>výchozí -&nbsp;&nbsp;false  (bool)</p>
</ul>

<hr size=2 width="100%" align=center>



<h2>Pøíklady skriptù</h2>

<p><b>Odstraòování prokládání se stejnou frekvencí snímkù:</b></p>
<ul><pre>mpeg2source()
tdeint()</pre></ul>

<p><b>Bobbing:</b></p>
<ul><pre>mpeg2source()
tdeint(mode=1)</pre></ul>

<p><b>Odstraòování prokládání pomocí EEDI2 pro interpolaci:</b></p>
<ul><pre>mpeg2source()
interp = separatefields().selecteven().eedi2()
tdeint(edeint=interp)</pre></ul>

<p><b>Bobbing s EEDI2 pro interpolaci:</b></p>
<ul><pre>mpeg2source()
interp = separatefields().eedi2(field=-2)
tdeint(mode=1,edeint=interp)</pre></ul>

<p><b>Smartbobb se srovnáním polí (Odstraòování prokládání se stejnou frekvencí snímkù smícháním snímkù zpracovaných metodou bob):</b></p>
<ul><pre>mpeg2source()
tdeint(mode=2)</pre></ul>

<p><b>Smartbobb se srovnáním polí s EEDI2 pro interpolaci:</b></p>
<ul><pre>mpeg2source()
interp = separatefields().eedi2(field=-2)
tdeint(mode=2,edeint=interp)</pre></ul>

<p><b>Použití TSwitch pro zostøení jen snímkù, ve kterých se odstraòuje prokládání:</b></p>
<ul><pre>mpeg2source()
tdeint(tshints=true)
tswitch(c1=last,c2=last.sharpen())</pre></ul>


<hr size=2 width="100%" align=center>


<h2>Seznam zmìn</h2>

<p>   01/21/2006  v1.1<br>
      + added TSwitch() filter<br>
      + added new blend deinterlacing mode (type = 5)<br>
      + expanded ovr line input buffers<br>
      + added new map outputs (map=3/4) which output both a map and deinterlaced frame<br>
      + map output works correctly with ap post-processing<br>
      + map output works correctly with hints/ovr/full/tryweave<br>
      + support passing through of dgdecode hints and tivtc's new hints<br>
      + added ability to run motion detection on a separate clip (emtn parameter)<br>
      - motion map now checks top/bottom lines<br>

<p>   10/16/2006  v1.0 Final<br>
      + added blend deinterlacing option (type = 4)<br>
      - changed denoise default to false<br>
      - pixels detected as moving, but with absolute difference < 4 to both vertical neighbors are
          no longer automatically weaved (should fix problems with slow fades)</p>

<p>   10/04/2006  v1.0 RC8<br>
      + added expand parameter<br>
      + added slow parameter and slow=1/2 matching modes from tfm<br>
      - fixed a typo causing mode 2 to crash with yuy2 input</p>

<p>   04/10/2006  v1.0 RC7<br>
      + optimized combed frame detection functions (now matches tivtc)<br>
      + added second spatial combing metric and "metric" parameter (same as tfm and is/showcombeditvtc)<br>
      + optimized denoise routines<br>
      + improved the field comparison routine (now equal to slow=0 in tfm)<br>
      + mode 2 uses the field comparison routine instead of full frame subtract for determining the best
           matching frame (more accurate)<br>
      - directly assign frames from emask clip (no need to copy)<br>
      - changed blim default to -2.0 (disabled)<br>
      - call setcachehints for emask/edeint clips when used</p>

<p>   03/22/2006  v1.0 RC6<br>
       + optimized motion map and field comparison routines<br>
       + added opt parameter<br>
       - fixed missing cache in mode 2</p>

<p>   03/21/2006  v1.0 RC5<br>
       - fixed mode 2 mmx/isse subtract frames functions (contained paddq sse2 instruction)</p>

<p>   03/19/2006  v1.0 RC4<br>
       + output MIC values in debug info when tryweave=true or full=false<br>
       + added value 70 to emask input<br>
       + added mmx versions of isse/sse2 compare/blend routines for mode=2<br>
       - refactored/rewrote a lot of the code to clean up and simply things, no changes that effect output...
            should give a slight speed up</p>

<p>   03/18/2006  v1.0 RC3<br>
       + Added mode 2 and blim parameter</p>

<p>   12/18/2005  v1.0 RC2<br>
       + Added emask parameter<br>
       - Fixed edeint not working correctly with mode=1<br>
       - Changed field=-1 operation when hints=false</p>

<p>   12/03/2005  v1.0 RC1<br>
       + Added edeint parameter</p>

<p>   08/14/2005  v1.0 beta 4<br>
       - SetCacheHints call to diameter instead of radius<br>
       - Fixed type=1 YUY2 interpolation routine giving messed up chroma output (bug was introduced in v1.0 beta 3)</p>

<p>   05/14/2005  v1.0 beta 3<br>
       + Added APType parameter, adds 2 new AP post-processing modes that take surrounding motion into account<br>
       + Small changes (hopefully improvements) to type 3 (ELA-2) interpolation</p>

<p>   04/26/2005  v1.0 beta 2<br>
       + Added modes -2 and -1... will upsize vertically by a factor of 2 using ELA or ELA2<br>
       + Call SetCacheHints in filter constructor<br>
       + Some small optimizations, should give a very small speed up</p>

<p>   04/23/2005  v1.0 beta 1<br>
       + Added AP threshold and post-processing<br>
       + Added blockx and blocky for variable window size during combed frame detection<br>
       - Changed default MI value to 64 (default window size is now 16x16 = 256 pixels)<br>
       - changed default cthresh value to 6<br>
       - Small change to denoising routine</p>

<p>   04/20/2005  v0.9.7.2<br>
       - Fixed not correctly using the field information from tfm's hints when acting as a post-processor for it.
            Also fixed not correctly altering the match info of tfm's hints when acting as a post-processor for it
            (PP=1 in tfm).<br>
       + Improvements to type 3 interpolation, renamed to modified ELA-2</p>

<p>   03/10/2005  v0.9.7.1<br>
       + Fixed not correctly reading hints from newer versions of tivtc and if colorimetry hints
            were present from dgdecode.</p>

<p>   01/20/2005  v0.9.7<br>
       + Added link and denoise parameters, link defaults to 2 and denoise to true<br>
       + Added ELA interpolation (tomsmocomp version) as type = 3<br>
       + Hints option can now read hints from tfm as well as telecide<br>
       + map = 2 now sets the chroma pixels that are to be interpolated to 255 and not just the luma<br>
       - Changed default type value to 2 (kernel interpolation)<br>
       - Changed default tryWeave value to false</p>

<p>   10/03/2004  v0.9.6<br>
       + Added full parameter, allows for ivtc post-processing.  full defaults to true.<br>
       + Added cthresh, chroma, and MI parameters... these are used when full=false<br>
       + Added tryWeave option, allows TDeint to adaptively switch between per-field
            and per-pixel motion adaptation.  tryWeave defaults to true.<br>
       + Improved field differencing<br>
       + changed mtnmode default to 1</p>

<p>   09/26/2004  v0.9.5<br>
       + Sped up mtnmodes 2 and 3, was doing it the hard way and not the easy way...</p>

<p>   09/25/2004  v0.9.4<br>
       + Added auto hints detection<br>
       + Added mtnmodes 2 and 3<br>
       + Added ability to deinterlace from the original stream when using hints via clip2 parameter<br>
       - Fixed field differencing using the wrong fields doh!</p>

<p>   09/18/2004  v0.9.3<br>
       + Added order = -1 option, will detect parity from avisynth<br>
       + Added hints option for reading telecide hints for interlaced/progressive<br>
       + 5 field motion check now includes checks over 4 field distances<br>
       - Fixed a bug in YUY2 type = 1 deinterlacing method</p>

<p>   09/14/2004  v0.9.2<br>
       + Added kernel interpolation and sharp parameter<br>
       + Added 5 field motion check and mtnmode parameter<br>
       + Changed default motion thresholds to 6</p>

<p>   09/12/2004  v0.9.1<br>
       - Fixed some really stupid bugs, one motion check was incorrect for the first and last
            frame of a clip, and mode = 1 would only work for the first half of the video</p>

<p>   09/12/2004  v0.9<br>
       - Initial Release</p>

<p><kbd>Èeský pøeklad: 21.3.2009</kbd>
</p>
</body>
</html>
