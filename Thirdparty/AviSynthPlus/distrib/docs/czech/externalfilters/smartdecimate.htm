<html>
<head>
<title>SmartDecimate</title>
<link rel="stylesheet" type="text/css" href="../../avisynth.css">
<!--
Automatically generated, don't change:
$Id: smartdecimate.htm,v 1.1 2010/02/27 14:50:14 wilbertd Exp $
-->
</head>
<body>
<h1>SmartDecimate</h1>
<h2>Pøehled</h2>
<b>autor:</b> SmartDecimate by Kevin Atkinson<br>
<b>verze:</b>     v0.23 (C plugin, naèítá se pomocí LoadCPlugin)<br>
<b>dowload:</b> <a href="http://kevin.atkinson.dhs.org/tel/">http://kevin.atkinson.dhs.org/tel/</a>,
<a href="http://www.avisynth.org/warpenterprises/">http://www.avisynth.org/warpenterprises/</a>
<br><b>kategorie:</b>   Odstraòování prokládání &amp; pulldown
<br><b>poadavky:</b> YV12 &amp;&nbsp; YUY2 Barevné prostøedí
<hr>
<p>
Smart Decimate odstraòuje telecine kombinováním telecine polí a
decimováním ve stejném èase, co se liší od tradièního
pøístupu uspoøádávání telecine snímkù a teprve poté následujícího odstraòování duplikátù.
Poslední verze Smart Decimate mùete najít na <a
href="http://kevin.atkinson.dhs.org/tel/"
>http://kevin.atkinson.dhs.org/tel/</a>.

<h2>Obsah</h3>
</h2>
<ul>
<li><a href="#usage">Základní pouití</a>
<li><a href="#guide">Prùvodce pouitím</a>
<li><a href="#ref">Popis filtru</a>
<li><a href="#works">Pochopení jak SmartDecimate pracuje</a>
<li><a href="#t_max">Vyladìní T_Max</a>
<li><a href="#deinterlace">Pouití Post Deinterlacer</a>
<li><a href="#motion">Zacházení s nechtìnım pohybem</a>
<li><a href="#decomb">Smart Decimate proti Decomb</a>
<li><a href="#other">Jiné vìci pro vyzkoušení Smart Decimate</a>
<li><a href="#caveats">Upozornìní</a>
<li><a href="#compile">Kompilování</a>
<li><a href="#final">Slovo na závìr</a>
<li><a href="#chage">Seznam zmìn</a>
</ul>

<a name="usage"><h2>Základní pouití</h2></a>

<pre>LoadPlugin(&quot;...\avisynth_c.dll&quot;)
LoadCPlugin(&quot;...\SmartDecimate.dll&quot;)
AssumeTFF() # nebo AssumeBFF()
SmartDecimate()</pre>

Všimnìte si, e druhı plugin je LoadCPlugin a ne LoadPlugin. (Za Load je
umístìno písmeno C)
<p>
<b>JE VELMI DÙLEITÉ, ABY BYLO POØADÍ POLÍ SPRÁVNÉ.</b>

<a name="guide"><h2>Prùvodce pouitím</h2></a>

V tomto prùvodci budu pøedpokládat, e váš materiál je 3:2 pulldown s
monım zamíchanım videem. Nicménì, SmartDecimate mùe zpracovat jakıkoli
pevnı decimaèní pomìr.
<p>
Pro pouití tohoto filtru, musíte nejdøíve urèit správné poøadí polí.
Pokud je poøadí polí nesprávné, mùj filtr nebude správnì pracovat.
Urèení poøadí polí:
<pre>AviSource(...)
AssumeTFF()
Bob()</pre>
Nyní si prohlédnìte video a hledejte zpìtnı pohyb. Pokud ádnı nevidíte,
tak by jste mìli pouít "assumetff()". Pokud nìjakı vidíte, zkuste:
<pre>AviSource(...)
AssumeBFF()
Bob()</pre>
A ještì jednou hledejte zpìtnı pohyb. Pokud tentokrát ádnı nevidíte,
tak by jste mìli pouít "assumebff()".
<p>
Teï nastal èas nastavit mùj filtr:
<pre>LoadPlugin(&quot;...\avisynth_c.dll&quot;)
LoadCPlugin(&quot;...\smartdecimate.dll&quot;) # všimnìte si C v loadCplugin
AviSource(...)
AssumeTFF() # nebo AssumeBFF() jak je urèeno vıše
SmartDecimate()</pre>
Pokud se vám vısledek líbí, tak je to vše co je potøeba. Pokud ne
ètete dále.
<p>
Pokud je váš materiál animovanı s hodnì opakovanımi snímky, tak by jste mìli zkusit:
<pre>SmartDecimate(tel=0.60)</pre>
To by se mìlo vyhnout jakémukoli bobbingu ve dlouhıch sekvencích bez pohybu.
<p>
Hodnota "tel" øídí jak agresivní je filtr pøi uspoøádání polí.
Vıchozí hodnotou je 0.50.
<p>
Pokud máte smíchané video s velkım mnostvím skuteèného videa, tak by jste
mohli chtít sníit "tel" a na 0.25. To riskuje bobbing
nìkterıch progresivních snímkù, ale nemìlo by spojovat (weave) skuteèné video snímky, co
mùe odstranit artefakty roztøepení.
<p>
Pokud máte video, které je èisté 3:2 pulldown s velmi malım podílem opravdovıch video
snímkù, pak by jste mohli zkusit zvìtšit "tel" a na 0.75. To zpùsobí,
e SmartDecimate bude opravdu agresivní, pøi uspoøádání progresivních
polí. Nicménì, asi pøestane odstraòovat váné
artefakty roztøepení za ním, pokud je nìjaké èisté video ve vašem klipu.
<p>
Pokud máte hodnì zašumìlé video, pak by jste mohli potøebovat zvıšit
parametr noise jako zde:
<pre>SmartDecimate(noise=0.80)</pre>
Vıchozí hodnota je 0.50. Nechte ho na vıchozí pokud váš klip není hodnì zašumìlı.
Vyšší hodnoty noise za sebou èasto zanechávají více artefaktù roztøepení pro èisté
video snímky.
<p>
Pokud máte opravdu èistı klip a všimli jste si nìkterıch artefaktù roztøepení
v èistıch video snímcích, pak by jste mohli chtít sníit parametr noise.
Ale buïte opatrní; pokud je pøíliš nízko, SmartDecimate nebude schopen
uspoøádat progresivní pole a bude je tedy bobovat (duplikovat).
<p>
Nakonec, pokud máte hybridní video (mix 3:2 pulldown a skuteèného
videa), mìli by jste zváit nahrazení dumb (hloupı) bob nìèím jako
DgBob nebo SmoothDeinterlace.  Aby jste to udìlali, pouijte monost "bob".
Napøíklad:
<pre>SmartDecimate(bob=DgBob(...))</pre>
To vıraznì zlepší kvalitu èistıch video snímkù. Všimnìte si,
e bob zdroj ovlivní jen jak jsou bobbované snímky rendrovány. Není
to pouito pro porovnání polí. Ani to není vyuito jinou èástí
SmartDecimate.

<a name="ref"><h2>Popis filtru</h2></a>

Filtr bude pracovat buï s YUY2 nebo YV12 vstupem.
<p>
Pouití je:
<p><code>SmartDecimate</code> (<var>[numr, denm], monosti</var>)</p>

Jmenovatel a èitatel udávají decimaèní pomìr pro
video <b>po</b> jeho rozdìlení na pole.
Vıchozí je 24 a 60 pro <var>numr</var> respektive <var>denm</var>.

<p>
Následující monosti mohou bıt pouity pro vyladìní <code>SmartDecimate</code>:

<p>
<var>bob<br>
</var>alternativní zdroj snímkù s odstranìnım prokládáním metodou bob. Vıchozí je &quot;<a href="../corefilters/bob.htm">Bob</a>()&quot;
co je v AviSynthu vestavìnı dumb (hloupı) bob filtr. Pro lepší vısledky
  pouijte smart (chytrı) bob jako <a href="dgbob.htm"> DgBob</a> nebo SmoothDeinterlace. Bobbovanı zdroj
  je pouit kdykoli SmartDecimate urèí, e pole není èástí
  progresivního snímku.
<p>
<var>weave<br>
</var>alternativní zdroj sloenıch (weaved) snímkù. Vıchozí je &quot;<a href="../corefilters/doubleweave.htm">DoubleWeave</a>()&quot;.
<p>
<var>tel<br>
</var>èíslo mezi 0 a 1, které ovládá jak agresivní je filtr
  pøi uspoøádání polí. 0.50 (vıchozí) pracuje dobøe s vìtšinou
  klipù. Èím vyšší hodnota tím více se riskuje zanechání
  artefaktù roztøepení ve skuteènì prokládaném materiálu. Èím niší hodnota, tím víc
  se riskuje bobbing (nebo v extrémním pøípadì pøeskoèení nebo
  duplikování) Telecine snímkù.
  <br>
  <br>
  V souèasnosti <var>tel
</var> pøepíná rùzné vnitøní monosti podle toho co je nastaveno.
  V souèasnosti jsou pøepínání mezi: 0.45, 0.55, 0.65
  a 0.72.
<p>
<var>noise<br>
</var>Parametr šumu.  Vıchozí hodnota, 0.50, by mìla pracovat ve vìtšinì
    pøípadù.
<p><var>t_max<br>
</var>Alternativní metoda nastavení faktoru noise.  Aby jste ho mohli pouít,
  musíte pochopit jak mùj filtr pracuje.</p>
<p><var>cpu<br>
</var>Vynutí CPU na urèitı typ.  Normálnì je to autodetekováno.
  Aby jste se podívali jestli je to detekováno správnì zapnìte logování.  Prní øádek
  vıstupu zobrazí typ CPU.  Aktuální platné hodnoty
  jsou: 0 - Generic, 2 - Integer SSE, 3 - SSE, 4 - SSE2.</p>
<p><var>unaligned<br>
</var>Umoní èíst nezarovnaná data. Normálnì <code>SmartDecimate</code> mùe ignorovat nìkolik
  pixelù na zaèátku nebo na konci kadého øádku, take ète jen ty pìknì zarovnané.
  Nastavení této hodnoty na true tomu zabrání.</p>
<p>
Následující monosti mohou bıt pouity pro ovládání tištìní uiteènıch informací:
<p>
<var>log_level<br>
</var>Vımluvnost tištìnıch informací. Vıchozí je 2.
<p>
<var>log_file<br>
</var>Pokud je nastaven, celı vıstup bude pøipojen k zadanému jménu souboru.
<p>
<var>console<br>
</var>Pøi nastavení na true, vyskoèí okno konsole window a celı vıstup bude
  posílán do ní.
<p>
<var>debug_print<br>
</var>Pokud je nastaven, tak celı vıstup bude vytištìn pøes systémovou vızvu OutputDebugString.
  Tento vıstup mùete zobrazit pomocí utility jako DebugView.
<p>
Vıznam vytištìnıch informací je následující:
<ul>
  <li>"Reseting to NUM" znamená, e vnitøní promìnné jsou resetovány a
jakékoliv šablony jsou také resetovány.  To nastane, kdy je kadé video
pøipojeno nelineárním zpùsobem.</li>
  <li>"FRAME 3 = [3, 4]"
ukazuje jak je snímek èíslo 3 (napøíklad)
rendrován.  3 zde ukazuje primární zdrojové pole, které je
vybráno.  Pokud má bıt snímek rendrován sloením (weaving) dvou polí dohromady,
èísla v [] ukazují která pole zdroje jsou vybrána.  Pokud má bıt ve snímku
odstranìno prokládání metodou bob pak místo [] bude "BOB".</li>
  <li>"Diff NUM: WHAT DIFF"
ukazuje rozdíl mezi poli zdroje
NUM a NUM+1.  WHAT je klasifikace rozdílu
0 co znamená stejné, 1 podobné, a 2 rùzné.  DIFF je numerickı
rozdíl.</li>
</ul>

<p>
Následující monosti mohou bıt pouity pro vyladìní vnitøních parametrù. Aby
jste pochopili co dìlají, musíte se podívat na zdrojovı kód.
Mohou bıt zmìny mezi vydáními.
<ul>
  <li>max_last_set - kladné celé èíslo
  <li>t1_def, t2_def, t1_max, t2_max - desetinné mezi 0.0 a 1.0
  <li>floor - desetinné mezi 0.0 a 1.0
  <li>floor_adj = desetinné vìtší ne 0.0
  <li>sml_peak, lrg_peak - desetinné vìtší ne 1.0
  <li>sml_tail_diff, lrg_tail_diff - desetinné vìtší ne 0.0
</ul>

<a name="works"><h2>Pochopení jak SmartDecimate pracuje</h2></a>

Tato diskuze pøedpokládá, e ètenáø zná prokládané
video, a zná vıznam takovıch termínù jako snímek, pole, horní pole,
spodní pole, BFF, TFF, telecide, telecine, 3:2 pulldown, atd..
<p>
Jiné telecide filtry obecnì odstraòují telecine ve dvou krocích
zpracování. Nejprve jsou telecine pole uspoøádány, ale frekvence snímkù
není zmìnìna, pak jsou duplikované snímky odstranìny. SmartDecimate takto
nepracuje. SmartDecimate namísto toho, kombinuje telecine pole a
decimuje frekvenci snímkù v jednom okamiku.
<p>
První vìc, kterou SmartDecimate dìlá je, e pouije "SeparateFields()",
kterı rozdìlí video na samostatná pole, co také zdvojuje
frekvenci snímkù. Tedy pole èíslo 9 je ve skuteènosti spodní pole
snímku 4 (pøedpokládám, e video je TFF) pøed jeho rozdìlením na
pole. Pro jednoduchost se budu odkazovat vdy na pole ze zdrojového
videa tímto zpùsobem.
<p>
SmartDecimate pak vybírá pole v pravidelné šablonì a snaí se
vyhnout vybírání duplikovanıch polí. Pøesnìji, a je N
èíslem umístìní snímku a R bude pomìr, kterı pro 3:2 pulldown
bude 24/60 = 2/5, pak SmartDecimate volí mezi polem
floor(N/R) a floor(N/R) + 1. Napøíklad, pro èíslo umístìní snímku
5, pouití typického 3:2 pulldown, SmartDecimate volí mezi
poli 12 a 13. Kterı zvolí je docela komplikované a
nìco co sem u nedostanu.
<p>
Poté kdy je zdrojové pole vybráno, musí rozhodnout jak ho rendrovat
SmartDecimate volí mezi: 1) jeho uspøádáním s pøedchozím
polem, 2) jeho uspøádáním s následujícím polem, nebo 3) jeho bob deinterlace.
Kterı zvolí, je zaloeno na tom jak podobné je pole k
pøedchozímu nebo následujícímu. Pokud je pole stejné jako pøedchozí nebo
následující pole, uspoøádá ho s tímto polem sloením tìchto
dvou polí dohromady. Pokud nemùe najít pole pro uspoøádání, provede odstranìní prokládání
metodou bob v aktuálním poli. SmartDecimate ve skuteènosti nedìlá koneèné
rendrování. Místo toho pouívá jinı AviSynth filtr, kterı to udìlá.
V pøípadì skládání (weaving) pouije DoubleWeave(), a v
pøípadì bobbingu pouije Bob() nebo smart (chytrı) bob filtr pokud
je nìjakı k dispozici a zadanı.

<a name="t_max"><h2>Vyladìní T_Max</h2></a>

Aby odkryl, která pole se liší jedno od druhého a
která jsou stejná, SmartDecimate hledá špièky v øetìzci rozdílù.
To je dáno tøemi hodnotami reprezentujícími rozdíl mezi
ètyømi po sobì jdoucími poli A B C D, pokud BC (t.j. rozdíl mezi B
a C) &gt; AB a BC &gt; CD a AB a CD mají podobné hodnoty, pak
pole A a B by mohly bıt stejné, pole B a C by mohly
bıt rozdílné, a pole C a D by mohly bıt stejné.
<p>
Nicménì, tato metoda není dokonalá a mùe obèas klasifikovat vysoce
pohyblivé scény, kdy podobné hodnoty rozdílù mezi snímky (to je
AB a CD jsou podobné), e by mohli bıt stejné. Take pro øízení tohoto,
SmartDecimate jednoduše pøedpokládá, e všechna pole s rozdílem vìtším ne
pevná prahová hodnota nemohou bıt stejná. Naneštìstí neexistuje
optimální hodnota pro tuto prahovou hodnotu, take je nastavena na rozumnou hodnotu,
která by mìla pracovat dobøe ve vìtšinì klipù, které nejsou extrémnì zašumìlé.
Nicménì, tato hodnota obecnì nechá nìkterá rozdílná pole
nedotèená, co povede k artefaktùm roztøepení. Aby jste se tomu vyhnuli, mìla by
bıt prahová hodnota "t_max" nastavena co moná nejníe.
<p>
Pro objevení nejlepší hodnoty "t_max" je pro konkrétní klip
budete potøebovat znát jaké jsou rozdíly mezi snímky.
Nejsnadnìjší zpùsob jak to udìlat je nastavit monost "log_file" (s log
level nastavenou na 2 nebo vyšší) a spustit SmartDecimate na znaèné èásti vašeho
klipu.  Jakmile je to udìláno, mìli by jste v log souboru vidìt nìco podobného
tomuto:
<pre>...
Diff 827: 0 6.11586e-008
FRAME 331 = [828,827]
Diff 828: 2 8.21554e-005
Diff 829: 0 3.69098e-008
Diff 830: 0 3.27322e-008
FRAME 332 = [830,831]
Diff 831: 2 0.000124936
Diff 832: 0 6.48069e-008
FRAME 333 = [832,833]
Diff 833: 2 0.000102379
Diff 834: 0 3.54472e-008
...</pre>
Øádky, které vás zajímají jsou ty které zaèínají "Diff
...".  První èíslo za Diff je zdrojové èíslo pole.
Druhé èíslo je klasifikace rozdílu s 0
znamenající shodnost, 1 podobnost, a 2 rozdílnost.  Koneèné èíslo je
skuteènı rozdíl.  To co vás v nìm zajímá je rozdíl
snímkù klasifikovanıch jako shodné.  Chcete nastavit t_max mírnì
nad maximální hodnotu všech rozdílù klasifikovanıch jako stejné.
Pro tento klip by 7.0e-8 mìla bıt dobrou hodnotou.  Ale protoe jsem se podíval jen na
malou èást klipu mùe bıt potøeba vyšší protoe rozdíly
se mohou hodnì lišit.  Nejlepší je podívat se na hodnotu pro
nìkolik rùznıch oblastí klipu, aby jste dostali bezpeènou hodnotu.  Pøedpokládejme, e
7.0e-8 je dobrá hodnota a mohu ji pouít následovnì:
<pre>SmartDecimate(t_max=0.000000070)</pre>
Napsal jsem 0.000000070 místo 7.0e-8 protoe AviSynth jak se zdá nepodporuje
vìdeckı zápis. Aby jste si byli jisti, e jste pøevedli èíslo
správnì, nastavte log level na 3 nebo vyšší a hledejte øádek
jako:
<pre>t1_max = 7.00000e-008  t2_max = 2.10000e-007  max_last_set = 13</pre>
Hodnota, která vás zajímá je t1_max co je 7e-8.  Proto jsem
pøevedl èíslo správnì.  Další hodnoty jsou pro jiné
vnitøní prahové hodnoty.
<p>
Jakmile si myslíte, e jste nalezli dobrou hodnotu pro t_max, znovu projeïte váš klip
pøes SmartDecimate s log level nastavenou na 3 nebo vyšší, aby jste se pøesvìdèili,
e jste ji nenastavili pøíliš nízko. Pokud ji nastavíte pøíliš nízko velkı
poèet snímkù bude bobbován a vy uvidíte zprávy jako je tato:
<pre>2001: T1 Maxed Out at 2.00000e-008</pre>
Tyto zprávy jsou normálnì pro skuteèné video èásti vašeho klipu, ale
nemìli by se ukázat v telecine èástech vašeho klipu. Pokud je vidíte,
tak to znamená, e t_max je pøíliš malı a má bıt zvìtšen. Pøesná
hodnota mùe bıt objevena prohlédnutím rozdílù okolních
snímkù. Napøíklad:
<pre>...
Diff 1999: 2 3.08506e-008
Diff 2000: 1 4.03734e-008
Diff 2001: 2 8.89810e-006
Diff 2002: 1 2.93221e-008
...</pre>
ukazuje, e t_max by mìl bıt alespoò 4.04e-8, ale 4.5e-8 by byla
bezpeènìjší hodnota.
<p>
Nakonec si prosím všimnìte, e jak "t_max" tak "noise" ovládají stejnı
vnitøní parametr, kterım je "t1_max".  Dìlají to jen jinım zpùsobem.
"t_max" ho nastavuje pøímo, zatímco "noise" ho nastavuje nepøímo, podle
exponenciální formule.  Ve SmartDecimate 0.21 tato formule je:
<pre>t1_max = exp(17.65*noise - 20.71)</pre>
Ale pøesné parametry se mohou v rùznıch vydáních mìnit.  Myšlenka je taková, e
hodnota šumu 0.50 (vıchozí) by mìla pracovat dobøe s vìtšinu
klipù, zatímco 0.80 mùe bıt pouito pro opravdu zašumìlé klipy, atd.

<a name="deinterlace"><h2>Pouití Post Deinterlacer</h2></a>

Ideálnì by pole rendrována filtrem SmartDecimate nemìla potøebovat
odstranit prokládání, pokud jsou parametry správnì vyladìny. Reálnì mùe bıt
post deinterlacer uiteènı. Nicménì protoe SmartDecimate pracuje
spíše na úrovni polí ne na úrovni snímkù, jsou vìci, kterıch by jste si
mìli bıt vìdomi.
<p>
Vìtšina deinterlacerù (odstraòovaèù prokládání) pøi práci vdy volí horní pole (nebo snad
spodní) jako dominantní pole a vıbìrovì hází informaci
do druhého pole a pak je interpoluje nebo smíchává (blending). Pro normální
30 fps (nebo 25 fps pal) je to správnì. Nicménì pro
vıstup ze SmartDecimate to není správné, protoe dominantní
pole není vdy stejné. To závisí na tom které pole
SmartDecimate pùvodnì vybíral ze zdrojového videa, a mùe to bıt buï
horní nebo spodní pole. Proto tradi¨èní deinterlacer mùe
vzít nesprávné pole. Nemusí to bıt dokonce ani pozorovatelné, ale mìli
by jste si toho bıt vìdomi.
<p>
Autoøi filtrù pro odstraòování prokládání mohou opravit tento problém za cenu
dohlíení na paritu snímku. SmartDecimate vdy zahlásí
paritu pùvodního vybraného pole jako paritu finálního
rendrovaného snímku. Pokud je parity true, pak by mìlo bıt vybráno
horní pole. Pokud je to false, bude vybráno spodní pole.  Také bude ochotnı
pøedávat údaje hints do deinterlaceru pro indikaci která pole jsou bobbována
pokud mi nìkdo øekne jak.

<a name="motion"><h2>Zacházení s nechtìnım pohybem</h2></a>

Pouitím monosti <var>weave</var> mùete pouít rùzné klipy pro vstup
a vıstup. To je uiteèné pro práci s titulky nebo jinım pohybem,
kterı nechcete uvaovat pøi uspoøádávání snímkù. Napøíklad
mùete zkusit oøíznout titulky.
<pre>b = Bob()
w = DoubleWeave()
CropBottom(64)
SmartDecimate(bob = b, weave = w)</pre>
Pak nebude vıstupní video oøíznuté, ale posledních 64 øádkù nebude vidìt
filtr SmartDecimate. Pokud pouijte tuto metodu, pak bob
zdroj musí bıt také zadán. Pokud nezadáte bob zdroj, tak
se pokusí pouít vstupní klip pro "Bob()". Ale vıslednı klip
nebude mít stejné rozmìry jako sloenı (weave) zdroj.

<a name="decomb"><h2>Smart Decimate proti Decomb</h2></a>

Pøed <a href="http://neuron2.net/decomb/decombnew.html"><cite>Decomb 5</cite></a>
od Donalda Grafta (aka Neuron2), mìli tradièní telecine filtry (které pracují
nejdøíve uspoøádáním telecine polí a pak decimací - odstraòování
duplikovánıch snímkù) tendenci duplikovat snímky. S Decomb 5
Donald jak se zdá tento problém vyøešil. Pøesto má pøístup filtru
SmartDecimate nìkolik vıhod pøed pøístupem
Decomb a naopak. Tedy ani jeden pøístup není jasnì lepší.
Kterı filtr pouijete, závisí na zdrojovém materiálu
a cílové frekvenci snímkù.
<p>
<h3>Èistı 3:2 pulldown materiál</h3>

Jak Smart Decimate tak Decomb budou pracovat vıbornì.  Decomb mùe stále
zanechat nìjaké duplikované snímky u vysoce nepravidelného 3:2 pulldown
materiálu.  Smart Decimate na druhou stranu, podle povahy své práce,
to obecnì nedìlá, ale mùe se ukonèit bobbing nìkterıch snímkù, u kterıch
by nemìl.  V mıch neformálních testech je Smart Decimate mírnì rychlejší
ne Decomb, kdy je vypnut postprocesing v Decomb.  S post
processingem je Smart Decimate o hodnì rychlejší.
<p>
<h3>Hybrid 3:2 pulldown a prokládané video</h3>

Pokud si z nìjakıch dùvodù pøejete nechat video na 30fps, tak pouijte
Decomb.  Smart Decimate by byl schopen uspoøádat telecine snímky, pøi
pøevodu z 60 -&gt; 30fps , ale bude také duplikovat snímky. Decomb
má speciální reim pro práci s tímto pomocí rozmazání snímkù dohromady, co mùe vést
ke hladšímu pohybu.
<p>
Pokud je vaše cílová frekvence 24fps, pak je volba zaloena na
osobní chuti, protoe jak Smart Decimate tak Decomb zpracují tuto situaci
zcela odlišnì, a s velmi rozdílnımi vısledky.
<p>
Smart Decimate zpracuje video vybíráním snímkù z bobbovaného
zdroje (dvojnásobná frekvence snímkù) v 3:2 šablonì. To je, jde od
60 -&gt; 24fps.  To vede ke slušnì hladkému pohybu bez nutnosti
rozmazávání snímkù dohromady. Nicménì, video je stále
mírnì trhavé. Podle mıch zkušeností je mírné trhání obecnì
nepozorovatelné, kromì pøípadu kdy probíhá text. Napøíklad, pøi
decimaci probíhajících titulkù v této podobì jsou vısledky
hrozné. Protoe jsou pouity bobbované snímky, budete mít také nìkteré
artefakty bobbingu.  Vısledky nebudou moc dobré kromì pøípadu, kdy pouijete
smart bob.
<p>
Decomb, na druhou stranu zkusí decimovat skuteèné video tak, e jde od
zdroje s odstranìnım prokládáním s 30 fps k 24 fps. Dìlá to jedním ze
dvou zpùsobù. První vìc, kterou mùe udìlat je prosté vypuštìní jednoho z kadıch 5
snímkù. Tento pøístup povede k extrémnì trhavım vısledkùm. Druhá vìc, kterou
mùe udìlat je smíchat snímky dohromady. Tento pøístup
povede k hladšímu videu ne u pøístupu Smart Decimate, ale ne bez
neádoucích artefaktù. Pohybové oblasti obrazu budou obecnì
rozmazané. U velkého pohybu se mohou objevit duplikované obrázky,
které mohou ztìovat oku sledování pohybu. Rozmazání
snímkù dohromady také negativnì ovlivní kompresi protoe dìlá
sledování pohybu obtínìjší.
<p>
<h3>Hybrid s progresivním 30 fps</h3>

Pokud vaše video obsahuje pøimìøené mnoství skuteèného 30 fps progresivního materiálu,
pak pochodíte lépe s Decomb. Z povahy toho jak mùj filtr
pracuje, vypustí jeden snímek z kadıch 5 pøi pøevodu na
24 fps.
<p>
Decomb na druhou stranu vidí prokládané video a progresivní 30 fps
jako stejnou vìc a bude tak  schopen rozmazat snímky dohromady pro hladší
pohyb.  Pokud je váš klip hlavnì video/30 fps progresivní s nìjakım
3:2 pulldown, Decomb mùe také udret 30 fps a smíchat
pulldown materiál pro lepší vısledky.
<p>
<h3>Zvláštní šablony Telecine</h3>

Pokud vaše šablona telecine není 3:2 pulldown (nebo jednoduše 25 fps
progresivní v pøípadì pal) a chcete se pokusit obnovit to na
jeho pùvodní frekvenci snímkù, mìli by jste zkusit jak Smart Decimate tak
Decomb a podívat se kterı pracuje lépe.  Nemám v této oblasti ádné
zkušenosti, take opravdu nevím.
<p>
<a name="other"><h2>Jiné vìci pro vyzkoušení Smart Decimate</h2></a>
<p>
Zde jsou nìkteré další vìci, které by jste mohli vyzkoušet se Smart Decimate,
pokud je nemùete zvládnout s pouitím tradièních telecine filtrù Decomb.

<h3>Lepší Bob pro Telecine materiál</h3>

Pokud váš materiál obsahuje nìjakı telecine materiál a vy chcete odstranit prokládání
metodou bob a získat 60 fps, pak by jste mìli zkusit:
<pre>SmartDecimate(1,1, tel=0.25, bob=DgBob(...))</pre>
co povede k lepším vısledkùm ne pouití DgBob (nebo vìtšina jinıch
smart bob filtrù) samotnı, protoe telecine snímky jsou duplikovány spíše
ne aby v nich bylo provedeno odstranìní prokládání metodou bob. To by mohlo udìlat velkı rozdíl
u animovanıch filmù.
<p>
<h3>Práce s Telecine s rozmazanımi snímky</h3>

Pokud pracujete s mnoha rozmazanımi snímky, zde je nìco na
vyzkoušení. Pouijte SmartDecimate(1,1) a pak zkuste vybrat
nerozmazané snímky jen vıbìrem snímkù, které jsou duplikované alespoò jednou.
Mohli by jste bıt schopni udìlat pozdìjší krok s Decimate()
z balíku Decomb, nebo <a href="http://neuron2.net/multidecimate/multidecimate.html">MultiDecimate</a>.
Nemám ponìtí jak dobøe to bude pracovat, protoe jsem to nikdy nezkoušel, ale
pøesto bych si to myslel v pøípadì, e by to nìkoho zajímalo.

<a name="caveats"><h2>Upozornìní</h2></a>

Kdy jsou pouity optimalizace MMX/SSE , SmartDecimate mùe ignorovat do 6 (14
pro SSE2) pixelù na zaèátku nebo na konci kadého øádku, protoe ètení v pamìti
jsou zarovnaná.   Pokud vás to obtìuje, nastavte "unaligned" na true,
co donutí SmartDecimate pouít neoptimalizovanı kód pøi
ètení dat snímkù.
<p>
SmartDecimate upozorní na jakékoli ignorované pixely pokud je logging level
nastavena na level 0 nebo vyšší.

<a name="compile"><h2>Kompilování</h2></a>

Pro kompilování SmartDecimate budete potøebovat nainstalovat Gcc a Nasm, a
moná GNU Make. Já jsem pouil <a href="http://www.mingw.org/">MinGW</a>
(2.0.0-3) s MSYS 1.09, Gcc 3.3.1, a <a
href="http://nasm.sourceforge.net/">Nasm</a> 0.98.37. Kromì Nasm,
lze všechny poadované utility najít na <a
href="http://www.mingw.org/download.shtml">MinGW Download
page</a>. Jiné konfigurace by mìli pracovat, ale mùete potøebovat editovat
Makefile. Jakmile jsou všechny potøebné nástroje nainstalovány a na cestì,
jednoduše napište:
<pre>make</pre>
z MSYS shell a to je vše co by mìlo bıt vyadováno.

<a name="final"> <h2>Slovo na závìr</h2></a>

Zpìtná vazba je velmi vítána.  Posílejte ji prosím na kevin.tel at
atkinson.dhs.org.

<a name="chage"><h2>Seznam zmìn</h2></a>

<p><b>0.23 (Sep 16, 2003)</b></p>
<ul>
<li>Bug Fixed.
<li>Slightly improved the field matching algorithm.
</ul>

<p><b>0.22 (Sep 12, 2003)</b></p>
<ul>
<li>Bug fixes.
<li>Fixed typos in documentation thanks to Tom Daniel.
</ul>

<p><b>0.21 (Sep 7, 2003)</b></p>
<ul>
<li>Greatly expanded the documentation to give users a better idea of
how SmartDecimate works and how to use it to its maxium potential.
<li>The CPU type is now auto detected.  SSE2 support is also provided.
<li>Bug fixes, especially when working with unaligned data.
<li>No longer ignores the last couple of rows (in some cases as many
as 11) of each frame
<li>Now use DoubleWeave() for rendering weaved frames
rather than doing it itself.
<li>When stepping through the video, one may now step backwards up to
60 frames or so without causing the pattern to be reset.
<li>Other minor changes.
</ul>

<p><b>0.20 (Aug 29, 2003)</b></p>
<ul>
<li>Expanded documentation with a short guide to using SmartDecimate.
<li>Uses an improved field matching algorithm.
<li>Bug fix in the non-optimized version when dealing with yv12 input.
</ul>

<p><b>0.12  (Aug 22, 2003)</b></p>
<ul>
<li>Can now control the output that went to the console on previous
versions.
<li>Can now modify some of the internal paramaters.
<li>An SSE optimized version is now provided.
</ul>

<p><b>0.11 (Aug 18, 2003)</b></p>
<ul>
<li>Greatly improved the classification algorithm
</ul>

<p><b>0.10 (Aug 16, 2003)</b></p>
<ul>
<li>Initial Release
</ul>

<p><kbd>$English Date: 2004/08/17 20:31:19 $</kbd></p>
<p><kbd>Èeskı pøeklad:12.5.2009</kbd></p>
</body>
</html>
