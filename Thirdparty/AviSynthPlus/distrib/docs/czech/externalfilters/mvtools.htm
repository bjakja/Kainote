<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="cz"><head>

<title>MVTools</title>
<link rel="stylesheet" type="text/css" href="../../avisynth.css">
<!--
Automatically generated, don't change:
$Id: mvtools.htm,v 1.1 2010/02/27 14:50:14 wilbertd Exp $
-->
</head>
<body>
<h1>MVTools</h1>
<h2>Pøehled</h2>
<b>autor:</b> Manao, Fizick(Aleksandr Balachnin), Tsp, TSchniede
<br><b>verze:</b> 1.11.4.5
<br><b>stáhnout:</b> <a href="http://avisynth.org.ru/">http://avisynth.org.ru/</a>,
<a href="http://www.avisynth.org/warpenterprises/">http://www.avisynth.org/warpenterprises/</a> <br>
<b>kategorie:</b>  Rùzné pluginy<br>
<b>poadavky:</b> YV12 nebo YUY2 Barevné prostøedí<br>
<b>licence:</b> GPL
<hr>
<h2>Obsah
</h2>
<ul>
  <li><a href="#mvtools">
I) O pluginu MVTools</a>
  </li>
  <li><a href="#functions">II) Popisy funkcí</a></li>
  <li><a href="#examples">III) Pøíklady</a></li>
  <li><a href="#disclaimer">IV) Odmítnutí záruk (nepøeskakujte tuto èást, ale nenutím vás
to nauèit se)</a></li>
  <li><a href="#revisions">V) Revize</a></li>
</ul>
<h2><a name="MVTools"></a>I) O pluginu MVTools
</h2>
<p>MVTools - plugin pro AviSynth 2.5 je kolekce funkcí
pro odhadnutí a kompenzaci pohybu objektù ve video klipech.
Kompenzace pohybu mùe bıt pouita pro silné èasové (temporal) odšumìní, pokroèilé pøevody snímkovıch frekvencí,
restauraci obrazu a další úlohy.
</p>
<p>Plugin obsahuje server-funkci odhadu pohybu MVAnalyse pro nalezení vektorù pohybu a
 nìkolik klient-funkcí kompenzace pohybu (MVCompensate, MVMask a další)
které pouívají tyto vektory.
</p>
<p>Plugin pouívá metodu srovnávání blokù pro odhad pohybu (podobné metody jsou pouity v MPEG2, MPEG4, atd).
Ve fázi analızy plugin rozdìluje snímky na malé bloky a snaí se najít pro kadı blok v aktuálním snímku
nejpodobnìjší (odpovídající) blok v druhém snímku (pøedchozím nebo následujícím).
Relativní posunutí tìchto blokù je vektor pohybu.
Hlavním mìøítkem podobnosti blokù je souèet absolutních rozdílù (SAD)
všech pixelù tìchto dvou porovnávanıch blokù.
SAD je hodnota, která øíká, jak dobrı byl odhad pohybu.
<p>Vıstupem MVAnalyse (server) je speciální klip s informacemi o vektorech pohybu v nìjakém formátu.
</p>
<p>Ve fázi kompenzace klient-funkce pluginu ètou vektory pohybu
a pouijí je k vyjmutí blokù a zformování snímku s kompenzovanım pohybem
(nebo realizuje nìjakou jinou plnou nebo èásteènou kompenzaci pohybu nebo funkci interpolace).
Kadı objekt (blok) v tomto (plnì) kompenzovaném snímku je umístìn na stejnou pozici v jaké je v aktuálním snímku.
Tedy, mùeme (napøíklad) pouít silné èasové odšumìní dokonce pro docela rychle se pohybující objekty
bez vytváøení nepøíjemnıch artefaktù a duchù
(rysy objektu a hrany jsou shodné pokud je kompenzace perfektní).
Plugin mùe vytvoøit kompenzované sousední snímky pro kadı aktuální snímek,
a odstranit v nich šum vnitøní funkcí (MVDenoise).
Nebo mùete pouít kompenzované a pùvodní snímky k vytvoøení prolínaného (interleaved) klipu,
odstranit v nich šum jakımkoliv externím èasovım (temporal) filtrem,
a vybrat centrální vyèištìné pùvodní snímky pro vıstup (viz pøíklady).
</p>
<p>Odhad pohybu a jeho kompenzace nejsou samozøejmì ideální a dokonale pøesné.
V nìkterıch komplikovanıch pøípadech (video se stmíváním - fading, ultra-rychlého pohybu, nebo periodickıch struktur)
mùe bıt odhad pohybu zcela chybnı, a kompenzovanı (obzvláštì interpolovanı) snímek mùe bıt kostkatı a (nebo) ošklivı.
Tìké potíe jsou také kvùli vzájemnému zastínìní jednoho objektu druhım nebo obrácenì odkrıvání.
Sloité Avisynth skripty s øadou funkcí pro kompenzaci pohybu mohou spotøebovat velkı objem pamìti
a vısledkem je velmi pomalé zpracování.
Nejedná se o jednoduchı, ale o docela pokroèilı plugin. Pouívejte ho jen ve vhodnıch pøípadech a snate se vyladit jeho parametry.
Existuje mnoho diskuzí o pouití kompenzace pohybu na doom9 Avisynth fóru.
Pøedevším se podívejte na starší vlákno <a href="http://forum.doom9.org/showthread.php?s=&amp;threadid=76041">MVTools</a>,
vlákno <a href="http://forum.doom9.org/showthread.php?t=102071">true motion</a>,
nové vlákno <a href="http://forum.doom9.org/showthread.php?t=84770">MVTools</a> a nìkterá další.
Snate se èíst pøíspìvky jako doplnìk této dokumentace a ádejte zde o pomoc.
Pokud se skuteènì zajímáte o témata odhadu a kompenzace pohybu,
mùete snadno najít øadu vìdeckıch publikací (pouijte WWW vyhedávání).
</p>
<p>Poznámky: Plugin je stále ve vıvoji. Aktuální verze má nìkterá omezení.
Podporováno je jen progresivní YV12, YUY2 video.
Pouijte pøevod barevného formátu a zkuste pouít (smart) bob-deinterlace pro prokládané video
(mùe také pracovat rozdìlení na pole SeparateFields s nebo bez SelectEven/SelectOdd).
Nìkteré komplikované skripty (MVBOB, MCBOB) pouívají MVTools pro
<a href="http://forum.doom9.org/showthread.php?t=84725">odstranìní prokládání s kompenzací pohybu.</a>
 </p>
 <p>Alternativnì mùete zkusit pouít <a href="http://forum.doom9.org/showthread.php?t=101859">plugin Motion</a> od mg262.
</p>
<h2><a name="functions"></a>II) Popisy funkcí
</h2>

<h3>Bìné parametry</h3>

<p>Filtry, které pouívají vektory pohybu mají bìné parametry.
Ty jsou prahovımi hodnotami detekce zmìny scény,
a mají znaky mmx / isse. Také pouívají jeden nebo více
vektorovıch streamù, které jsou vytváøeny funkcí <code>MVAnalyse</code>.
</p>
<p><var>int thSCD1</var> : prahová hodnota, která rozhoduje, zda se blok zmìnil
mezi pøedchozím snímkem a aktuálním. Kdy se blok zmìnil, znamená to,
e odhad pohybu pro toto není vıznamnı. To nastává
napøíklad pøi zmìnì scény. Tedy to je jedna z prahovıch hodnot pouitıch k nastavení
mechanismu zmìny scény. Jeho zvìtšení sníí
poèet blokù detekovanıch jako zmìnìné. Mùe to bıt uiteèné pro zašumìlé nebo blikající video.
Prahová hodnota je porovnána s hodnotou SAD
(Sum of Absolute Differences - souèet absolutních rozdílù, hodnotou, která øíká jak špatnı byl odhad pohybu ).
Pro pøesnì identické bloky máme SAD=0. Ale skuteèné bloky se vdy liší kvùli sloitému pohybu objektù
(pøiblíení, rotaci, deformaci), diskrétnosti vzorkování pixelù, a šumu.
Pøedpokládejme, e máme dva porovnané bloky 8x8 s kadım pixelem lišícím se o 5.
V tomto pøípadì bude SAD 8x8x5 = 320 (blok nebude detekován jako zmìnìnı pro thSCD1=400).
Pokud pouijete bloky 4x4, SAD bude 320/4.
Pokud pouijete bloky 16x16, SAD bude 320*4.
Ve skuteènosti se tento parametr násobí vnitønì v MVTools,
a vy musíte vdy pouít hodnotu redukovanou na velikost bloku 8x8.
Vıchozí je 400 (od v.1.4.1).
</p>
<p><var>int thSCD2</var> : prahová hodnota, která nastavuje kolik blokù ve snímku se musí zmìnit
aby se rozhodlo, e se jedná o zmìnu scény. Je to v rozsahu 0 a 255, 0
znamená 0 %, 255 znamená 100 %. vıchozí je 130 ( co znamená 51 % ).
</p>
<p><var>bool isse</var> : znak, kterı umoòuje vypnout ISSE a MMX optimalizace pokud se nastaví na false (pro odladìní).
Vıchozí je true. Pokud váš procesor nepodporuje ISSE MMX optimalizace, bude to kadopádnì
vypnuto ( a vy nebudete schopni je aktivovat )</p>

<h3>MVAnalyse</h3>

<p><code>MVAnalyse</code> (<var>clip, int "blksize", int "blksizeV", int "pel", int "level", int "search",
int "searchparam", int "pelsearch", bool "isb", int "lambda", bool "chroma", int "delta",
bool "truemotion", int "lsad", int "pnew", int "plevel", bool "global", int "pzero", int "overlap", int "overlapV",
string "outfile", int "sharp", int "rfilter", clip "pelclip", int "dct", int "divide", bool "mc", int "idx", int "sadx264"</var>)
</p>
<p>Odhaduje pohyb metodou srovnávání blokù
a vytváøí speciální vıstupní klip s daty vektorù pohybu (pouívané dalšími funkcemi).<br>
Jsou implementovány nìkteré hierarchické víceúrovòové metody vyhledávání (od hrubého mìøítka obrazu k nejjemnìjšímu).
Funkce pouívají nulovı vektor a vektory sousedních blokù jako prediktory (pøedpovìdi) pro aktuální blok.
Nejdøíve je odhadnuta odchylka (SAD) pro prediktory,
pak se zkušební vektor (kandidát) zmìnìní o nìjakou hodnotu v nìkterém smìru,  odhaduje se SAD, atd.
Pøijatı novı vektor je vektor s minimální hodnotou SAD (s nìjakou penalizací na soudrnost pohybu).
</p>
<p><var>blksize</var> : Velikot bloku (horizontální). Je buï 4, 8 nebo 16 ( vıchozí je 8 ).
Vìtší bloky jsou ménì citlivé na šum, jsou rychlejší, ale také ménì pøesné.</p>
<p><var>blksizeV</var> : vertikální velikost bloku. Vıchozí je rovna horizontální velikosti.
Doplòkové monosti: 4 pro blksize=8 a 8 nebo 2 pro blksize=16.</p>
<p><var>pel</var> : je pøesnost odhadu pohybu.  Hodnota mùe bıt jen 1, 2 nebo 4. 1 znamená
pøesnost na pixel. 2 znamená pøesnost na pùl pixelu, 4 znamená pøesnost na ètvrtinu pixelu,
tvoøenou prostorovou (spatial) interpolací (pøesnìjší ale pomalejší a ne vdy lepší kvùli velkému kroku násobení mezi úrovnìmi).
Vıchozí je 2 od v1.4.10.</p>
<p><var>level</var> : je poèet Nepouitıch hrubıch úrovní v hierarchické
analıze provádìné pøi vyhledávání vektorù pohybu. Obvykle èím niší, tím lepší (lze nalézt vektory s jakoukoliv délkou).
Promìnná je zachována pro studijní (testovací) úèely.
Nìkdy je <var>level</var> uiteènı pro vylouèení velkıch (livıch) vektorù (poèítaèové grafiky, atd).
Vıchozí : 0 (jsou pouity všechny úrovnì).</p>
<p><var>search, searchparam, pelsearch</var> : <var>search</var> urèuje typ vyhledávání v kadé úrovni, a
<var>searchparam</var> je pøídavnı parametr (krok, rádius) pro toto vyhledávání,
a <var>pelsearch</var> je parametr na nejjemnìjší (pel) úrovni:</p>
<ul>
	<li><var>search </var>= 0 : 'jednoprùchodové vyhledávání'. <var>searchparam</var> je krok mezi
  kadımi zkoušenımi vektory ( pokud <var>searchparam</var> je vìtší ne 1, krok se bude progresivnì upøesòovat
  - postupnì zmenšovat ).</li>
	<li><var>search </var>= 1 : 'N-prùchodové'. N je nastaveno parametrem <var>searchparam</var>. Je to
  nejznámìjší algoritmus vyhledávání vektorù pohybu.</li>
  <li><var>search </var>= 2 : Logaritmické vyhledávání, také nazıvané Diamantové vyhledávání.
  <var>searchparam</var> je úvodní krok vyhledávání, a také se postupnì zmenšuje.
  Je to vıchozí typ vyhledávání ( s vıchozími hodnotami <var>searchparam</var> = 2 a <var>pelsearch</var> = <var>pel</var> )</li>
  <li><var>search </var>= 3 : Vyèerpávající vyhledávání, <var>searchparam</var> je rádius (ètvercová strana je 2*radius+1). Je
  pomalı, ale dává nejlepší vısledky podle hodnot SAD.</li>
</ul>
<p><var>isb</var> : umoní volit mezi dopøednım vyhledáváním (pohyb z
pøedchozího snímku do aktuálního) pro <var>isb</var>=false a zpìtnım vyhledáváním (pohyb z následujícího
snímku do aktuálního) pro <var>isb</var>=true (isb znamená "IS Backward",
je to implementováno a nazváno pøesnì tak jak je zde popsáno, neptejte se na to :-). Vıchozí je <var>isb</var>=false.</p>
<p><var>chroma</var> : nastavení na true umoní zahrnout také barevnost pøi
odhadu pohybu (false - pouze jas). Vıchozí je true.
</p><p><var>delta</var> : nastavuje interval snímkù mezi referenèním snímkem a aktuálním
snímkem. Vıchozí je 1, co znamená, e vektory pohybu jsou vyhledávány mezi aktuálním snímkem
a pøedchozím ( nebo dalším ) snímkem. Nastavení na 2 vám umoní vyhledávat vektory pohybu mezi snímkem n a n-2
nebo n+2 ( v závislosti na nastavení <var>isb</var> ).</p>

<p> Existuje nìkolik pokroèilıch parametrù, které nastavují souvislost vektorù pohybu pro odhad takzvaného skuteèného pohybu (true motion).
Nìkteré porovnané bloky z jiného snímku mohou bıt nejpodobnìjší vzorovım blokùm aktuálního snímku podle kriteria intenzity (SAD),
ale neodpovídají skuteènému pohybu objektu.
Napøíklad, mohou pøíslušet jinému podobnému objektu v jiném rohu snímku nebo nìjaké periodické struktuøe.
Parametry "True motion" se snaí udret pohybová pole více soudrná, namísto nìkterıch náhodnıch distribucí vektorù.
Je to obzvláš dùleité pro jednotlivé kompenzace pohybu a interpolace.
Nìkteré parametry jsou experimentální a mohou bıt odstranìny (nahrazeny) v pøíštích verzích po vyzkoušení. Oznamujte prosím své závìry.
</p>
<p><var>truemotion</var> je pøednastavení hodnot tìchto parametrù.
Umoòuje snadno pøepnout vıchozí hodnoty všech "true motion" parametrù najednou.
Nastavte <var>true</var> pro vyhledávání skuteèného pohybu - true motion (vyšší soudrnost vektorù),
Nastavte <var>false</var> pro vyhledávání vektorù pohybu s nejlepší SAD.
Vıchozí je true od v1.4.10.
V kadém pøípadì mùete nastavit kadı parametr samostatnì.</p>
<p><var>lambda</var> : nastavuje soudrnost polí vektorù. Èím vyšší,
tím soudrnìjší. Nicménì, pokud je pøíliš vysokı, mohou bıt nìkteré nejlepší vektory pohybu
opomenuty. Velmi se doporuèují hodnoty kolem 400 - 2000 (pro velikost bloku 8).
Vnitønì je to koeficient pro penalizaci (úpravu) SAD od kvadratického rozdílu vektoru od prediktoru (sousedù),
násobenım 256. <br>
Vıchozí je 0 pro <var>truemotion</var>=false a 1000*blksize*blksizeV/64 pro <var>truemotion</var>=true.
</p>
<p><var>lsad</var>: SAD limit pro pouití <var>lambda</var> . Lokální <var>lambda</var> je sníeno (plynule od v1.10.2)
pokud hodnota SAD vektoru prediktoru (zhotovená ze sousedních blokù) je vìtší ne tento limit.
Brání to pouití špatnıch prediktorù, ale sniuje soudrnost pohybu.
Pro skuteènı pohyb (true motion) jsou doporuèeny hodnoty nad 1000 (pro velikost bloku=8).<br>
Vıchozí je 400*blksize*blksizeV/64 pro <var>truemotion</var>=false a 1200*blksize*blksizeV/64 pro <var>truemotion</var>=true.
</p>
<p><var>pnew</var>: relativní penalizace (násobena 256) k odchylce (SAD) nového kandidujícího vektoru.
Novı kandidující vektor musí bıt lepší, aby byl pøijat jako novı vektor jen, kdy jeho
SAD s penalizací (SAD + SAD*pnew/256) jen niší ne odchylka prediktoru (staré SAD).
To brání nahrazení docela dobrıch prediktorù novımi vektory s o trochu lepším SAD
ale jinou délkou a smìrem.<br>
Vıchozí je 0 pro <var>truemotion</var>=false a 50 pro <var>truemotion</var>=true.
</p>
<p><var>plevel</var>:  reim násobení penalizaèního koeficientu <var>lambda</var> úrovnì.
Hodnota=0 - bez násobení, 1 - lineární, 2 - kvadratická závislost na velikosti hierarchické úrovnì.
Všimnìte si, e délka vektoru je menší na niší úrovni.<br>
Vıchozí je 0 pro <var>truemotion</var>=false a 1 pro <var>truemotion</var>=true
</p>
<p><var>global</var>:  odhaduje globální pohyb (v kadé úrovni) a pouívá ho jako doplòkovı prediktor.
Je odhadován pouze (panoramatickı) posun kamery (ne pøibliování ani rotace).
Pouijte false pro vypnutí, pouijte true pro zapnutí.
Vıchozí je false pro <var>truemotion</var>=false a true pro <var>truemotion</var>=true.
</p>
<p><var>pzero</var>: relativní penalizace (násobena 256) k odchylce (SAD) pro nulovı (a globální) vektor.
Brání nahrazení docela dobrıch prediktorù nulovımi vektory s o trochu lepší SAD
(<var>lambda</var> se pro nulové a globální vektory nepouívá). Vıchozí je roven <var>pnew</var> od v1.11.
</p>
<p><var>overlap</var>:  hodnota pøekrytí blokù (horizontální). Musí bıt sudá a menší ne velikost bloku
(do blksize/2 pro MVCompensate).
Krok mezi bloky pro odhad pohybu je roven (blksize-overlap).
N blokù pokrıvá velikost ((blksize-overlap)*N + overlap)  na snímku.
Zkuste pouít hodnotu pøekrytí od blksize/4 do blksize/2.
Èím vìtší pøekrytí, tím vìtší poèet blokù, a tím menší rychlost zpracování.
Vıchozí hodnota je 0. <br>
Funkce s podporou pøekrytí jsou: MVFlow, MVFlowInter, MVFlowFps (ne
MVFlowFps2), MVShow, MVMask, MVCompensate, MVDeGrain1, MVDeGrain2,
MVDeGrain3.
</p><p><var>overlapv</var>:  vertikální hodnota pøekrytí blokù. Vıchozí je rovna horizontální.
Musí bıt sudá pro YV12 a menší ne velikost bloku.
</p><p><var>outfile</var>:  Jméno souboru pro zápis dat vektorù pohybu.
Tato data mohou bıt pouita nìkterım externím programem
nebo mohou bıt dalšími verzemi MVTools pro kódování druhého prùchodu, atd. <br>
Vytváøenı binární soubor má hlavièku (struktura MVAnalysisData, viz MVInterface.h ve zdrojovém kódu),
a sekvenci dat:<br>
èíslo snímku, data vektoru (Vx, Vy, SAD) kadého bloku,
pøíští platné èíslo snímku, data vektoru tohoto snímku, atd.<br>
Vıchozí - Prázdnı øetìzec, nezapisuje soubor.</p>
<p><var>sharp</var>:  metoda interpolace subpixelu pro <var>pel</var>=2,4. <br>
Pouijte 0 pro mìkkou interpolaci (bilineární), 1 pro bikubickou interpolaci (4 tap Catmull-Rom),
 2 pro ostrou interpolaci Wiener (6 tap, podobná Lanczos).<br>
Vıchozí je 2.
</p>
<p><var>rfilter</var>:  metoda sníení hierarchickıch úrovní.
Pouijte 0 pro jednoduchı souèet 4 pixelù (prùmìrování, jako BilinearResize, stará metoda),
pouijte 1 pro filtr 1/4, 1/2, 1/4 (jako ReduceBy2) pro hladší odhad pohybu.<br>
Vıchozí je 1 (od v1.11.0.2).
</p>
<p><var>pelclip</var>: nadvzorkovanı zdrojovı klip pro pouití namísto vnitøní subpixelové interpolace (pro pel&gt;1).<br>
Pixely v øádcích a sloupcích dìlitelné pel (0,2,4,... pro pel=2) musí bıt pùvodní zdrojové pixely,
ostatní pixely musí bıt interpolovány.<br>
Pøíklad pro pel=2: <code>LanczosResize(width*2,height*2,src_left=0.25, src_top=0.25)</code>.
(Nedávná poznámka: je to správné pro jas, ale ne pøesnì to odpovídá pozicím pixelù barevnosti vnitøní interpolace v MVTools.
Pøesto vektory a kompenzace pohybu jsou pro obvyklé klipy docela podobné,
stejná barevnost by byla s src_left=0.5 pro YUY2 a dodateènì src_top=0.5 pro YV12).<br>
Další uiteènı pøíklad je EEDI2 hranovì-namíøenı resampler.<br>
Pro správné vısledky musíte pouít (stejnı) <var>pelclip</var> pro celı øtezec funkcí MVTools
které pouívají stejnı zdrojovı klip (a idx). <br>
Vıchozí není definována.
</p>
<p><var>dct</var>: pouití blokù DCT (frekvenèní spektrum) pro vıpoèet rozdílu blokù (SAD).
Zvláštì mùe zlepšit odhad vektoru pohybu pøi blikání a stmívání jasu.<br>
0 - obvyklé prostorové (spatial) bloky, nepouívat DCT;<br>
1 - pouít bloky DCT místo prostorovıch dat (pomalé pro velikost bloku 8x8 a velmi pomalé pro jiné velikosti);<br>
2 - smíchaná prostorová a DCT data; váha závisí na støedním rozdílu jasu;<br>
3 - adaptivní pøepínání po blocích z prostorového na ekvivalentní-váenı smíšenı reim (experimentální, o nìco rychlejší).<br>
4 - adaptivní pøepínání po blocích z prostorového na smíšenı reim s vìtší váhou DCT (experimentální, o nìco rychlejší).<br>
pøidané reimy ve v1.9.5.3:  (vyadují sadx264 0-7, pouívají nejrychlejší SATD funkce, pouze jas!) <br>
5 - SATD místo SAD pro jas<br>
6 - stejné jako 2 jen pouívají SATD<br>
7 - stejné jako 3 jen pouívají SATD<br>
8 - stejné jako 4 jen pouívají SATD<br>
9 - podobné jako 2, pouívají SATD a váené rozsahy od SAD jen k ekvivalentním SAD &amp; SATD<br>
10 - podobné jako 3/4,pouívají SATD váha je na SAD, jen na velké zmìny jasu<br>
Vıchozí = 0.
</p>
<p><var>divide</var>: post-processing vektorù pohybu rozdìlením kadého bloku na 4 podbloky.<br>
0 - nedìlit;<br>
1 - rozdìlit bloky a pøipsat originální vektor všem 4 podblokùm;<br>
2 - rozdìlit bloky a pøipsat støední (se 2 sousedními) vektory podblokùm;<br>
Vıchozí je = 0. Hodnoty velikosti bloku pøekrytí musí bıt zvoleny, aby byly pøijatelné po vnitøním dìlení.
</p>
<p><var>mc</var>: dodateènì zachovat pohybovì kompenzované snímky ve vektorovém klipu (pouije se v MVDenoise).
Vıchozí je false (neuchovává se pro šetøení pamìti) od v1.11.4.
</p>
<p><var>idx</var>: index klipu. Umoòuje vnitøní znovupouití (sdílení)
víceúrovòovıch dat vypoètenıch pro snímky klipu
nìkolika instancemi filtru (nebo jinımi funkcemi)
pro rychlejší zpracování a sníení vyuití pamìti.
Je obzvláš uiteènı pro pel=2 k zabránìní provádìní vıpoètù interpolace podruhé,
pøi provádìní dopøedného &amp; zpìtného vyhledávání ve stejném klipu.
Pokud pouíváte idx, mìli by jste vdy pouít kladné hodnoty,
a mìli by jste pouít jen stejnou hodnotu filtrù
které pracují ve stejném klipu (jinak by analıza nepracovala správnì).
Ve vıchozím stavu je kadé instanci filtru dáno jedineèné záporné èíslo
(které vytvoøí svá vlastní víceúrovòová data).</p>
<p><var>sadx264</var>: vyuívá SAD funkcí z kodeku x264 pokud jsou dostupné pro velikost bloku<br>
0 - Autodetekovat CPU a vybrat nejlepší funkce<br>
1 - pouít MMX 16x16, 16x8, 8x8, 8x4, 4x4 (8x16, 4x8 pouito jen na barevnost - chroma)<br>
2 - pouít MMX 16x16, 16x8, 8x8, 8x4 (8x16, pouito jen na barevnost - chroma) zarovnáno na 32 bajtové bloky<br>
3 - pouít MMX 16x16, 16x8, 8x8, 8x4 (8x16, pouito jen na barevnost - chroma) zarovnáno na 64 bajtové bloky, nejlepší pro Pentium M<br>
4 - pouít SSE2 16x16, 16x8 (ádné zvláštní zarovnání)<br>
5 - pouít SSE2 16x16, 16x8, zarovnáno na 64 bajtové bloky (dobrá volba pro Core)<br>
6 - pouít SSE3 16x16, 16x8 (zdá se, e rychleji pracuje jen na Pentium 4E &amp; Core1)<br>
7 - pouít SSSES3 16x16, 16x8, zarovnáno na 64 bajtové bloky (dobrá volba pro Core2)<br>
Reimy 8-12 jsou urèeny jen pro ladìní a testování - pouijte místo nich dct &gt;4.<br>
Pouití sadx264 &gt; 7 znamená: pouít vybranı místo SAD pro jakoukoliv jasové/barevnostní (luma/chroma) SAD kde je to moné!<br>
pro SAD / SATD mix a pouze luma pouijte dct<br>
8 - pouít SSD mmx, pracuje podobnì jako 1<br>
9 - pouít SATD mmx, pracuje podobnì jako 1<br>
10 - pouít SATD SSE2, pracuje podobnì jako 2<br>
11 - pouít SATD SSSE3, pracuje podobnì jako 2<br>
12 - pouít SATD SSSE3 s PHADD na 8xY, pracuje podobnì jako 2<br>
Vıchozí je 0, pouijte -1 nebo &gt;=13 pro pouití starého algoritmy v1.9.4 SAD a úplnou deaktivaci x264 SAD funkcí.<br>
</p>

<p>Zkuste pouít funkci <code>MVShow</code> pro kontrolu odhadnutıch polí pohybu a vyladìní parametrù.</p>
<p>Poznámka: MVAnalyse (pokud Pel=2) detekuje znak videa zaloeného na polích (po SeparateFields) a automaticky
dìlá opravu vektorù pohybu v souladu s vertikálním posunem polí s rùznou paritou.
Zkuste pouít AssumeFrameBased pokud to nepotøebujete.</p>

<h3>MVCompensate</h3>

<p><code>MVCompensate</code> (<var>clip, clip "vectors", bool "scbehavior", int "mode", int "thSAD",
bool "fields", clip "pelclip", int "idx"</var>)
<p>Provádí plnou kompenzaci pohybu ve snímku. To znamená, e bloky ukázané
pomocí vektorù pohybu v referenèním snímku budou posunuty podle vektorù k dosaení jejich umístìní
v aktuálním snímku.</p>
<p><var>scbehavior</var> ( vıchozí je true ), rozhoduje, kterı snímek bude zachován
pøi zmìnì scény. Je-li true, snímek je ponechán nezmìnìnı. Jinak je do aktuálního snímku
zkopírován referenèní snímek.</p>
<p><var>mode</var> mùe bıt buï 0 nebo 1 (vıchozí). Mode=0 døíve znamenal pouití kompenzace
provádìné pøi vyhledávání vektorù. Nyní je to provádìno v reimu mode=1.
Mode=1 znamená, e pøepoèítává kompenzaci z dat vektorù ( protoe mùete
chtít pouít vektory na jinı klip ne ten ve kterém vyhledáváte ). Starı reim mode=2 je nyní vypnutı.</p>
<p><var>thSAD</var> je prahová hodnota SAD pro bezpeènou (dummy) kompenzaci. Pokud je blok SAD nad thSAD,
pak je blok špatnı, a my pouijeme zdrojovı blok místo kompenzovaného bloku. Vıchozí je 10000 (prakticky vypnuto).
</p>
<p><var>fields</var>: je-li nastaven na true a <var>pel=2</var>, pak pøidáváme vhodná vertikální posunutí
 (po pùlpixelu) polí pro video zaloené na polích.
 Zkuste to pouít pro odstranìní prokládání (ne pro odšumìní).<br>
Vıchozí je false.
</p>
<p><var>pelclip</var>: nadvzorkovanı zdrojovı klip pro pouití místo interní subpixelové interpolace (stejné v MVAnalyse).<br>
Vıchozí není definováno.
</p>
<p><var>idx</var> pracuje stejnım zpùsobem jako <var>idx</var> v MVAnalyse.
</p>
<p>Zpracování pøekrytıch blokù je implementováno jako okenní sumarizace blokù
(jako FFT3DFilter, hodnota pøekrytí do blksize/2) pro sníení blocking artefaktù (kostkatìní).
</p>

<h3>MVDenoise</h3>

<p><code>MVDenoise</code> (<var>clip, clip mvs [,...], bool "Y", bool "U", bool "V", int "thT", int "thSAD", int "thMV"</var>)
</p>
<p>Provádí èasové (temporal) odšumìní s kompenzací pohybu z nìkolika klipù vektorù mvs. Referenèní snímky
jsou pohybovì kompenzovány a pak slouèeny s aktuálním snímkem.</p>
<p>První prahová hodnota, <var>thT</var>, rozhoduje zda pixel, kterı pøichází z
pøedchozího nebo následujícího snímku má bıt zahrnut do procesu vıpoètu. Pokud se tento pixel
liší více ne <var>thT</var> od pixelu v aktuálním snímku, není pouit.</p>
<p>Druhá <var>thSAD</var>, rozhoduje zda blok má bıt zmìnìn nebo
ne ( stejnı princip jako <var> thSCD1</var> ). Jestlie se blok zmìnil, pixely nejsou slouèeny s pixely
z pøedchozího nebo následujícího snímku.</p>
<p><var>thMV</var> je délka vektoru, nad kterou není blok pouit pro
odšumìní.</p>
<p>Nakonec, <var>Y</var>, <var>U</var> a <var>V</var> øíkají na kterıch plochách by se mìlo odšumovat.</p>
<p>Vıchozí : <var>Y</var>, <var>U</var> a <var>V</var> jsou true, <var>thT</var> = 10, <var>thSAD</var> = 200 a <var>thMV</var>=30.</p>
<p>Funkce je zastaralá. Zpracování pøekrytıch blokù je
implementováno jako jednoduché sekvenèní pokrytí bloky zleva doprava,
shora dolù.
Funkce pouívá data kompenzace pohybu uloené v klipech vektorù. </p>

<h3>MVMask</h3>

<p><code>MVMask</code> (<var>clip, clip "vectors", float "ml", float "gamma",
int "kind", int "Ysc"</var>)
</p>
<p>Vytváøí klip masek z dat vektorù pohybu.
Maska je definována daty blokù, ale je interpolovaná, aby zapadla na celou velikost snímku.
Maska je vytvoøena jak na jasové (luma) tak na barevnostních (chroma) plochách. Hodnoty masky mohou bıt od 0 (min) do 255 (max).</p>
<p><var>kind</var> parametr definuje druh masky.
</p><p>Reim <var>kind=0</var> vytváøí masku pohybu z délek vektorù pohybu. Vytváøí lepší
masku ne <a href="masktools.htm#motionmask"> MotionMask</a> ( <a href="masktools.htm">
MaskTools</a> ) protoe vektory pohybu jsou mnohem víc vìrohodné ne
algoritmus MotionMask. Hodnota masky 0 znamená nikde ádnı pohyb ( délka
vektorù pohybu je nulová ). Èím vìtší délka vektoru, tím vìtší hodnota masky (nasycené do 255),
mìøítko je definováno pomocí <var>ml</var>.</p>
</p><p><var>kind=1</var> umoní vytvoøit masku hodnot SAD (souèet absolutních rozdílù) místo
délek vektorù. Mùe to bıt uiteèné k nalezení problémovıch oblastí se špatnım odhadem pohybu.
(Je pouit vnitøní faktor blocksize*blocksize/4 pro normalizaci mìøítka <var>ml</var>.)
<p><var>kind=2</var> umoòuje vytvoøit okluzní masku (špatné bloky v dùsledku roztrení, napìtí).
V souèasnosti se pouívá nìjakı normalizovanı souèet kladnıch rozdílù pohybu blokù. Mùe to bıt násobeno pomocí mìøítka <var>ml</var>.</p>
<p><var>kind=3</var> umoòuje vytvoøit masku horizontální komponenty vektoru pohybu v jednotkách pel plus 128.
Násobené koeficienty se nepouívají.</p>
<p><var>kind=4</var> umoòuje vytvoøit masku vertikální komponenty vektoru pohybu v jednotkách pel plus 128.
Násobené koeficienty se nepouívají.</p>
<p><var>kind=5</var> - barevná mapa pohybu jako x,y komponent vektorù pohybu zobrazenıch v U, V barevnıch plochách
(v jednotkách pel plus 128, násobené koeficienty se nepouívají).</p>
<p><var>ml</var> definuje mìøítko masky pohybu.
Kdy délka vektoru (nebo hodnota jiného typu) je vyšší nebo rovna <var>ml</var>, bude vıstupní
hodnota nasycena do 255. Menší hodnoty vedou k menším vıstupùm.
</p><p><var>gamma</var> je pouito pro definování ukazatele závislosti vıstupu na vstupu.
<var>gamma</var> = 1.0 znamená lineární závislost, zatímco <var>gamma</var> = 2.0 dává
kvadratickou závislost.</p>
<p>A nakonec, <var>Ysc</var> je hodnota vzatá maskou pøi zmìnì scény</p>
<p>Vıchozí jsou: <var>kind</var> = 0,  <var>ml</var> = 100, <var>gamma</var> = 1.0, a
<var>Ysc</var> = 0.</p>

<h3>MVSCDetection</h3>

<p><code>MVSCDetection</code> (<var>clip, clip "vectors", int "Ysc"</var>)
</p>
<p>Vytváøí masku detekce scény z dat vektorù pohybu.
Maska je vytvoøena jak na jasové (luma) tak i na barevnostních (chroma) plochách. Vıstup beze zmìny scény je 0.</p>
<p><var>Ysc</var> je hodnota braná maskou pøi zmìnì scény, vıchozí je 255.</p>

<h3>MVShow</h3>

<p><code>MVShow</code> (<var>clip, clip "vectors", int "scale", int
"sil", int "tol", bool "showsad"</var>)
</p>
<p>Zobrazuje vektory pohybu.
</p>
<p><var>scale</var> umoòuje zvìtšit vektory
pohybu, napøíklad za úèelem zvıšení pøesnosti ( kdy je
<var>pel</var> &gt; 1 a <var>scale</var> = 1, neuvidíte
odchylky menší ne jeden pixel ).
</p>
<p><var>sil</var> umoní vidìt rùzné úrovnì analızy ( kdy se pøi vyhledávání
vektorù pohybu provádí hierarchická analıza, a mùe to bıt zajímavé pro pozorování
co se dìje ve vyšších úrovních ).
</p>
<p><var>tol</var> je prahová hodnota tolerance. Pokud deformace vyvolaná
vektorem pohybu vìtším ne <var>tol</var>, vektor není zobrazen.
</p>
<p>Nakonec, <var>showsad</var> umoní zobrazit støední SAD po kompenzaci
obrazu.
</p>
<p>Vıchozí jsou : <var>scale</var> = 1, <var>sil</var> = 0, <var>tol</var> =
20000 a <var>showsad</var> = false ( co zobrazí všechny vektory ).</p>

<h3>MVChangeCompensate</h3>
<p><code>MVChangeCompensate</code> (<var>clip vectors, clip</var>)</p>
<p>Umoní mìnit kompenzaci uloenou do mvs streamu (streamu vektorù pohybu).</p>

<h3>MVIncrease</h3>
<p><code>MVIncrease</code> (<var>clip, clip "vectors", int "horizontal", int "vertical", int "idx"</var>)</p>
<p>Umoòuje pouít vektory vypoèítané pro zmenšenou verzi klipu aby byly pouity pro
provedení kompenzace v klipu s pùvodní velikostí.</p>
<p><var>horizontal</var> je horizontální pomìr mezi šíøkou klipu
a šíøkou zmenšeného klipu.</p>
<p><var>vertical</var> je vertikální pomìr mezi vıškou klipu
a vıškou zmenšeného klipu.</p>
<p><var>idx</var> pracuje stejnì jako v <code>MVAnalyse</code></p>

<h3>MVDepan</h3>

<p><code>MVDepan</code> (<var>clip, clip "vectors", bool "zoom", bool "rot", float
"pixaspect", float "error", bool "info", string "log", float "wrong", float "zerow", int "range"</var>)
</p>
<p>Dostává vektory pohybu, odhaduje globální pohyb a vkládá data do
vıstupního snímku ve zvláštním formátu pro plugin <code>DePan</code> (od Fizick).</p>
<p>Globální pohyb uvnitø snímku (panoramování, zoom, rotace) je odhadnut iterativní
procedurou, za pouití pouze dobrıch blokù.
</p>
<p>Odmítnuté bloky: 1) poblí okrajù snímkù; 2) s velkım SAD (podle parametru <var>thSCD1</var>
); 3) s pohybem lišícím se od sousedù nebo globálu.</p>
<p>Parametry <i>zoom</i> a <i>rot</i> pøepínají odhad zoom (pøiblíení, vzdálení)) a rotaci, <var>
pixaspect </var> je protaení pixelu (1.094 pro standardní PAL, 0.911 pro
standardní NTSC), <var>error </var>je maximální støední odchylka pohybu.</p>
<p>Vyhodnocenı globální pohyb ve snímku se pøepne na nulu pro velké chyby pohybu nebo
pøi zmìnì scény (podle parametrù <var>thSCD1, thSCD2</var> ).
</p>
<p>parametr <var>info</var> umoòuje zapsat informace o globálním pohybu pro ladìní.
</p>
<p>parametr <var>log</var> umoòuje nastavit jméno log souboru ve formátu DeShaker, Depan.</p>
<p>parametr <var>wrong</var> definuje limit pro vypnutí blokù velmi odlišnıch od sousedních.
</p>
<p>parametr <var>zerow</var> definuje váhu nulovıch vektorù pohybu (pro sníení jejich vlivu).
</p>
<p><var>range</var> - poèet pøedchozích (a také následujících) snímkù (polí) v blízkosti ádaného snímku pro odhad jejich pohybu.
</p>
<p>Vıchozí jsou : <var>zoom</var> = true, <var>rot</var> = true, <var>pixaspect</var> = 1.0,
<var>error</var> = 15.0, <var>info</var> = false, <var>wrong</var>=10, <var>zerow</var>=0.05, <var>range</var>=0.</p>
<p>Pro odhad globálního pohybu prokládaného zdroje musíte rozdìlit pole
(jak pro MVAnalyse tak pro MVDepan).</p>

<h3>MVFlow</h3>

<p><code>MVFlow</code> (<var>clip, clip "vectors", float "time", int "mode", bool "fields", clip "pelclip", int "idx"</var>)
</p>
<p>Provádí kompenzaci pohybu ve snímku ne po blocích (jako MVCompensation), ale po pixelech.
Vektor pohybu pro kadı pixel je vypoèítán bilineární interpolací vektorù pohybu
aktuálních a sousedních blokù (v souladu s pozicí pixelu).
To znamená, e pixely ukázané vektorem v referenèním snímku
budou posunuty (flow - proudí) podle vektorù pro dosaení jejich umístìní v aktuálním snímku.
Tato flow motion (proudící) kompenzaèní metoda neprodukuje ádné blokové artefakty, a je dobrá pro odšumìní,
ale obèas mùe vytváøet velmi zvláštnì deformované obrazy :).
Pro tuto funkci se dùraznì doporuèuje skuteènı odhad pohybu (true motion).
Kompenzace pohybu mùe bıt úplná nebo èásteèná (v mezièase).<br>
Omezení: vektory s komponentami nad 127 budou resetovány na nulovou délku.
</p>
<p><var>time</var>:  procento kompenzace pohybu (vıchozí=100.0, úplná kompenzace),
definuje èasovı moment mezi referenèním a aktuálním snímkem.</p>
<p><var>mode</var> mùe bıt buï 0 ( vıchozí ), nebo 1. <br>
mode=0 - pøinést pixely na kadé místo cílového snímku. Je to hlavní produkèní reim.<br>
mode=1 - posunout pixely z kadého místa zdroje (reference).
Je to ladící (uèební) reim s nìjakımi prázdnımi místy (s nulovou intensitou).
Mùe bıt pouit pro vytvoøení masky okluzí.
</p>
<p><var>fields</var>: je-li nastaven na true a <var>pel=2</var>, pak pøidáváme vhodná vertikální posunutí
 (po pùlpixelu) polí pro video zaloené na polích.
 Zkuste ho pouít pro odstranìní prokládání (ne pro odšumìní).<br>
Vıchozí je false.
</p>
<p><var>pelclip</var>: nadvzorkovanı zdrojovı klip pro pouití místo interní subpixelové interpolace (stejné v MVAnalyse).<br>
Vıchozí není definováno.
</p>
<p><var>idx</var> (moná) pracuje stejnım zpùsobem jako <var>idx</var> v MVAnalyse.</p>

<h3>MVFlowInter</h3>

<p><code>MVFlowInter</code> (<var>clip, clip "mvbw", clip "mvfw", float "time", float "mL", clip "pelclip", int "idx"</var>)
</p><p>Funkce interpolace pohybu. Není stejná (ale podobná) jako funkce MVInterpolate strších verzí MVTools.
Pouívá zpìtnıch "mvbw" a dopøednıch "mvfw" vektorù pohybu
pro vytvoøení obrazu v nìjakém mezièase mezi aktuálním a následujícím (podle delta) snímkem.
Pouívá pixelovou (podle metody MVFlow) kompenzaci pohybu z obou snímkù.
Vnitøní zpìtné a dopøedné masky okluze (metoda MVMask <var>kind=2</var>)
a èasovì váené souèinitele jsou pouity pro vytvoøení vıstupního obrazu s minimálními artefakty.
Pro tuto funkci se dùraznì doporuèuje skuteènı odhad pohybu (true motion).</p>
<p><var>time</var>:  pozice interpolaèního èasu mezi snímky (v procentech, vıchozí=50.0, polovièní zpùsob)</p>
<p><var>mL</var>: násobící parametr masky. Niší hodnoty odpovídají silnìjším maskám okluzí
(jako ve funkci MVMask, pouijte ho pro vyladìní a odstranìní chyb). Vıchozí=100.
</p><p><var>pelclip</var>: nadvzorkovanı zdrojovı klip pro pouití místo interní subpixelové interpolace (stejné v MVAnalyse).<br>
Vıchozí není definováno.
</p>
<p><var>idx</var> (moná) pracuje stejnım zpùsobem jako <var>idx</var> v MVAnalyse pro zvıšení rychlosti.</p>

<h3>MVFlowFps</h3>

<p><code>MVFlowFps</code> (<var>clip, clip "mvbw", clip "mvfw", int "num", int "den", int "mask", float "ml", clip "pelclip", int "idx"</var>)
</p><p>Zmìní frekvenci snímkù (fps) klipu (a poèet snímkù).
Funkce mùe bıt pouita pro pøevod frekvence snímkù, efekt pomalého pohybu, atd.
Pouívá zpìtnıch "mvbw" a dopøednıch "mvfw" vektorù pohybu
pro vytvoøení obrazu v nìjakém mezièase mezi snímky.
Pouívá pixelovou kompenzaci pohybu (jako MVFlow, MVFlowInter).
Vnitøní zpìtné a dopøedné masky okluze (metoda MVMask <var>kind=2</var>)
a èasovì váené souèinitele jsou pouity pro vytvoøení vıstupního obrazu s minimálními artefakty.
Pro tuto funkci se dùraznì doporuèuje skuteènı odhad pohybu (true motion).</p>
<p><var>num</var>:  èitatel fps vıstupního klipu. Vıchozí=25.</p>
<p><var>den</var>:  jmenovatel fps (vıchozí=1). Vısledná fps = num/den.
Pøedevším pro dvojnásobnou NTSC fps=2*29.97 pouijte <var>num</var>=60000 a <var>den</var>=1001,
a pro dvojnásobnou NTSC FILM fps=2*23.976 pouijte <var>num</var>=48000 a <var>den</var>=1001.
Kdy <var>num</var> nebo <var>den</var> je rovno 0, pak je pro vıstup brána dvojnásobná fps vstupního klipu (od v1.8.1).</p>
<p><var>mask</var>: reim masky zpracování:<br>
mask=0 jsou jednoduché zpìtné a dopøedné masky okluze (pouité ve verzích do 1.4.x, nejrychlejší);<br>
mask=1 je podobná maska s dodateènım pøepínáním na statické nulové vektory v okluzních oblastech (podobné do v1.5.x);<br>
mask=2 je pro pouití zvláštních vektorù ze sousedních snímkù pro sníení
halo efektu u objektù v okluzních oblastech (v1.8, nejpomalejší). Vıchozí=2.</p>
<p><var>ml</var>: parametr mìøítka masky. Vìtší hodnoty odpovídají slabší masce okluze
(jako ve funkci MVMask, pouijte ho pro vyladìní a odstranìní chyb). Vıchozí=100.
</p><p><var>pelclip</var>: nadvzorkovanı zdrojovı klip pro pouití místo interní subpixelové interpolace (stejné v MVAnalyse).<br>
Vıchozí není definováno.
</p>
<p><var>idx</var> (moná) pracuje stejnım zpùsobem jako <var>idx</var> v MVAnalyse pro zvıšení rychlosti.</p>

<h3>MVFlowFps2</h3>

<p><code>MVFlowFps2</code> (<var>clip, clip "mvbw", clip "mvfw", clip
"mvbw2", clip "mvfw2", int "num", int "den", int "mask", float "ml",
clip "pelclip", int "idx", int "idx2"</var>)
</p><p>Zmìní frekvenci snímkù (fps) klipu (a poèet snímkù) jako MVFlowFps,
ale s trochu lepší kvalitou (a pomalejším zpracováním) s vnìjším pøekrıváním
blokù. <br>
(Poznámky: MVFlowFps má nyní efektivnìjší vnitøní pøekrıvání blokù,
a MVFlowFps2 je zastaralı. MVFlowFps2 nepracuje správnì s pøekrıváním v MVAnalyse).<br>
Navíc ke zpìtnımi "mvbw" a dopøednımi "mvfw" vektory pohybu pùvodního zdrojového klipu,
funkce MVFlowFps2 pouívá zpìtné "mvbw2" a dopøedné "mvfw2" vektory pohybu druhého (upraveného) zdrojového klipu.
Druhı klip musí bıt vytvoøen z pùvodního zdrojového klipu oøíznutím (t.j. diagonálním posunem) o pùl velikosti bloku.
Musí to bıt provedeno pøíkazem <code>Crop(a,a,-b,-b)</code>,
kde a=b=4 musí bıt pouito pro blksize=8, a=b=8 pro blksize=16, a a=2, b=6 pro blksize=4 (viz pøíklad).
Okraje blokù budou v rùznıch èástech objektù.
MVFlowFps2 obrací posun vnitønì a prùmìruje vektory pohybu z tìchto dvou zdrojù
pro sníení chyb odhadu pohybu.
Funkce pouívá pixelovou kompenzaci pohybu (jako MVFlow, MVFlowInter).
Vnitøní zpìtné a dopøedné masky okluze (metoda MVMask <var>kind=2</var>)
a èasovì váené souèinitele jsou pouity pro vytvoøení vıstupního obrazu s minimálními artefakty.
Pro tuto funkci se dùraznì doporuèuje skuteènı odhad pohybu (true motion).</p>
<p><var>num</var>:  èitatel fps vıstupního klipu. Vıchozí=25.</p>
<p><var>den</var>:  jmenovatel fps (vıchozí=1). Vısledná fps = num/den.
Pøedevším pro dvojnásobnou NTSC fps=2*29.97 pouijte <var>num</var>=60000 a <var>den</var>=1001,
a pro dvojnásobnou NTSC FILM fps=2*23.976 pouijte <var>num</var>=48000 a <var>den</var>=1001.
Kdy <var>num</var> nebo <var>den</var> je rovno 0, pak je pro vıstup brána dvojnásobná fps vstupního klipu (od v1.8).</p>
<p><var>mask</var>: reim masky zpracování:<br>
mask=0 jsou jednoduché zpìtné a dopøedné masky okluze (pouité ve verzích do 1.4.x, nejrychlejší);<br>
mask=1 je podobná maska s dodateènım pøepínáním na statické nulové vektory v okluzních oblastech (podobné do v1.5.x);<br>
mask=2 je pro pouití zvláštních vektorù ze sousedních snímkù pro sníení
halo efektu u objektù v okluzních oblastech (v1.8, nejpomalejší). Vıchozí=2.</p>
<p><var>ml</var>: parametr mìøítka masky. Vìtší hodnoty odpovídají slabší masce okluze
(jako ve funkci MVMask, pouijte ho pro vyladìní a odstranìní chyb). Vıchozí=100.
</p><p><var>pelclip</var>: nadvzorkovanı zdrojovı klip pro pouití místo interní subpixelové interpolace (stejné v MVAnalyse).<br>
Vıchozí není definováno.
</p>
<p><var>idx</var> (moná) pracuje stejnım zpùsobem jako <var>idx</var> v MVAnalyse pro zvıšení rychlosti.</p>
<p><var>idx2</var> je index MVAnalyse druhého (posunutého) klipu (nesmí se shodovat s prvním idx).</p>

<h3>MVBlockFps</h3>

<p><code>MVBlockFps</code> (<var>clip, clip "mvbw", clip "mvfw", int "num", int "den", int "mode", float "thres", int "idx"</var>)
</p><p>Funkce pouívá èásteènou kompenzaci pohybu zaloenou na blocích
ke zmìnì frekvence snímkù (fps) klipu (a poètu snímkù).
Pouívá zpìtné "mvbw" a dopøedné "mvfw" vektory pohybu
pro vytvoøení interpolovanıch obrazù v nìjakém mezièase mezi snímky.
Pro vytvoøení vıstupního obrazu se pouívají nìkteré vnitøní zpìtné a dopøedné masky
a èasovì váené souèinitele.
(Algoritmus je zaloen na funkci MVInter starıch MVTools v1.9.12.)
Je to rychlejší ne MVFlowFps , ale mùe vytváøet kostkatìní a jiné artefakty.
Pro tuto funkci se dùraznì doporuèuje skuteènı odhad pohybu (true motion).</p>
<p><var>num</var>:  èitatel fps vıstupního klipu. Vıchozí=25.</p>
<p><var>den</var>:  jmenovatel fps (vıchozí=1). Vısledná fps = num/den.
Pøedevším pro dvojnásobnou NTSC fps=2*29.97 pouijte <var>num</var>=60000 a <var>den</var>=1001,
a pro dvojnásobnou NTSC FILM fps=2*23.976 pouijte <var>num</var>=48000 a <var>den</var>=1001.
Kdy <var>num</var> nebo <var>den</var> je rovno 0, pak je pro vıstup brána dvojnásobná fps vstupního klipu.</p>
<p><var>mode</var>: reim zpracování:<br>
0 - prùmìr dopøedné a zpìtné èásteèné kompenzace pohybu (nejrychlejší, vıchozí).<br>
1 - statickı støed.<br>
2 - dynamickı støed.<br>
3 - èasovì váená kombinace pøenesenıch dopøednıch blokù maskovanıch posunutımi zpìtnımi
a pøenesenıch zpìtnıch maskovanıch posunutımi dopøednımi.<br>
4 - reim 3 smíchanı s jednoduchım statickım èasovım prùmìrem podle masky okluze posunutıch blokù.<br>
5 - maska okluze (pro ladìní).
</p><p><var>thres</var>: prahová hodnota mnoství okluzí na blok pro binarizaci masky.
Vıchozí=0, co je vnitønì = blksize*blksizeV/4.
</p>
<p><var>idx</var> (moná) pracuje stejnım zpùsobem jako <var>idx</var> v MVAnalyse pro zvıšení rychlosti.</p>

<h3>MVFlowBlur</h3>

<p><code>MVFlowBlur</code> (<var>clip, clip "mvbw", clip "mvfw", float "blur", int "prec", clip "pelclip", int "idx"</var>)
</p><p>Experimentální jednoduchá funkce rozmazání pohybu. Mùe bıt pouita pro FILM-efekt (simulaci konce otevøení závìrky kamery).
Pouívá zpìtné "mvbw" a dopøedné "mvfw" vektory pohybu
pro vytvoøení a pøekrytí mnoha kopií èásteènì kompenzovanıch pixelù
v mezièase v nìjakém intervalu rozmazání (blurring) kolem aktuálního snímku.
Pouívá pixelovou kompenzaci pohybu (jako MVFlow).
Pro tuto funkci se dùraznì doporuèuje skuteènı odhad pohybu (true motion).</p>
<p><var>blur</var>: èasovı interval rozmazání (blur) mezi snímky, èas otevøení závìrky (v procentech, vıchozí=50.0)</p>
<p><var>prec</var>: pøesnost rozmazání v jednotkách pixelù. Maximální krok mezi kompenzovanımi rozmazanımi pixely. Vıchozí =1 (nejpøesnìjší).
</p><p><var>pelclip</var>: nadvzorkovanı zdrojovı klip pro pouití místo interní subpixelové interpolace (stejné v MVAnalyse).<br>
Vıchozí není definováno.
</p>
<p><var>idx</var> (moná) pracuje stejnım zpùsobem jako <var>idx</var> v MVAnalyse pro zvıšení rychlosti.</p>

<h3>MVDeGrain1, MVDeGrain2 a MVDegrain3</h3>

<p><code>MVDeGrain1</code> (<var>clip, clip "mvbw", clip "mvfw", int "thSAD", int "thSADC", int "plane", int "limit", clip "pelclip", int "idx"</var>)</p>
<p><code>MVDeGrain2</code> (<var>clip, clip "mvbw", clip "mvfw", clip
"mvbw2", clip "mvfw2", int "thSAD", int "thSADC", int "plane", int
"limit", clip "pelclip", int "idx"</var>)</p>
<p><code>MVDeGrain3</code> (<var>clip, clip "mvbw", clip "mvfw", clip "mvbw2", clip "mvfw2",
   clip "mvbw3", clip "mvfw3",int "thSAD", int "thSADC", int "plane", int "limit", clip "pelclip", int "idx"</var>)</p>
<p>Provádí èasové (temporal) odšumìní s kompenzací pohybu.
Bloky pøedchozích a následujících snímkù jsou pohybovì kompenzovány a pak zprùmìrovány s aktuálním snímkem
s váenımi souèinitely závislımi na rozdílech blokù od aktuálního (SAD). Funkce podporují reim pøekrıvání blokù.
</p><p>Zpracování pøekrıvajících se blokù je implementována jako okenní sumarizace blokù
(jako FFT3DFilter, hodnoty pøekrytí do blksize/2) pro sníení artefaktù kostkatìní.
</p>
<p>MVDeGrain1 má èasovı (temporal) rádius 1 (pouívá vektory pøedchozího <var>mvfw</var> a následujícího <var>mvbw</var> snímku).</p>
MVDeGrain2 má èasovı (temporal) rádius 2 (pouívá vektory dvou pøedchozích <var>mvfw2, mvfw</var> a dvou následujících <var>mvbw,mvbw2</var> snímkù).
MVDeGrain3 má èasovı (temporal) rádius 3 (pouívá vektory tøí pøedchozích <var>mvfw3, mvfw2, mvfw</var> a tøí následujících <var>mvbw, mvbw2, mvbw3</var> snímkù).
Je to pomalejší, ale produkuje trochu lepší vısledky (silnìjší odšumìní).</p>
<p>parametr <var>"thSAD"</var> definuje mìkkou prahovou hodnotu souètu absolutních rozdílù bloku.
Blok se SAD nad prahovou hodnotou <var>thSAD</var> má nulovou váhu pøi prùmìrování (odšumìní).
Blok s nízkou hodnotou SAD má nejvìtší váhu.
Musíte zadat hodnotu <var>thSAD</var> redukovanou na velikost bloku 8x8.
Nízké hodnoty mohou vést k šachovnicovému odšumìní, velké hodnoty mohou vést k duchùm a artefaktùm.
<br>
Vıchozí <var>thSAD</var>=400.</p>
<p><var>"thSADC"</var> je prahová hodnota pro plochy barevnosti (chroma).<br>
Vıchozí (není-li zadána) : <var>thSADC</var>=thSAD.
Pokud je zadána pak <var>thSADC</var>je pouito pro barevnost a <var>thSAD</var> je pouito pro jas (luma).</p>
<p>parametr <var>plane</var> nastavuje zpracovanou barevnou plochu:<br>
0 - jas, 1 - barevnost U, 2 - barevnost V, 3 - obì barevné roviny, 4 - vše. Vıchozí je 4.
</p>
<p><var>limit</var>: maximální zmìna pixelu (jako plugin DeGrainMedian pro zabránìní nìkterım artefaktùm).
Vıchozí je 255 (bez omezení).
</p>
<p><var>pelclip</var>: nadvzorkovanı zdrojovı klip pro pouití místo interní subpixelové interpolace (stejné v MVAnalyse).<br>
Vıchozí není definováno.
</p>
<p><var>idx</var> (moná) pracuje stejnım zpùsobem jako <var>idx</var> v MVAnalyse pro zvıšení rychlosti.</p>

<h3>MVRecalculate</h3>

<p><code>MVRecalculate</code> (<var>clip, clip vectors, int "thSAD", int "blksize", int "blksizeV",
int "search", int "searchparam", int "lambda", bool "chroma",
bool "truemotion", int "pnew", int "overlap", int "overlapV",
string "outfile", int "sharp", clip "pelclip", int "dct", int "divide", bool "mc", int "idx", int "sadx264"</var>)
</p>
<p>Upøesòuje a pøepoèítává døíve odhadnutá (z MVAnalyse) data vektorù pohybu  <var>vectors</var>
pro jinı klip <var>clip</var> nebo nastavení novıch parametrù (napø. menší velikost bloku), po dìlení, atd.
Tato dvou fázová metoda mùe bıt také uiteèná pro stabilnìjší (robustnìjší) odhad pohybu.
Upøesnìní se provádí jen na nejjemnìjší hierarchické úrovni.
Interpolované vektory starıch blokù jsou pouity jako prediktory pro nové vektory, s pøepoètem SAD.
Jen nové vektory špatné kvality se SAD vyšší ne prahová hodnota <var>thSAD</var> budou znovu odhadnuty vyhledáváním.
Zadávejte hodnotu <var>thSAD</var> redukovanou (násobenou) na velikost bloku 8x8. Vıchozí <var>thSAD</var>=200.
Dobré vektory jsou nezmìnìny, ale jejich SAD bude aktualizováno (pøepoèítáno).
</p>
Další parametry mají stejnı vıznam jako v MVAnalyse (ale mùete pouít jiné hodnoty).
Pouijte jiné hodnoty idx pokud se klip nebo bloky liší.
<p></p>


<h2><a name="examples"></a>III) Pøíklady
</h2>
<p> Ve všech pøíkladech pøedpokládáme, e u je ve skriptu definovanı nìjakı zdrojovı klip <var>source</var>:</p>
<pre>source = AVISource("c:\test.avi") # nebo MPEG2Source, DirectShowSource, nìjakı pøedchozí filtr, atd.
</pre>
<p>Zobrazení vektorù pohybu ( dopøednıch ) :
</p>
<pre>vectors = source.MVAnalyse(isb = false)
source.MVShow(vectors)</pre>

<p>Zobrazení zpìtnıch vektorù :
</p>
<pre>vectors = source.MVAnalyse(isb = true)
source.MVShow(vectors)</pre>

<p>Pouití MVMask :
</p>
<pre>vectors = source.MVAnalyse(isb = false)
source.MVMask(vectors)</pre>

<p>Odšumnìní :</p>
<pre>backward_vec2 = source.MVAnalyse(isb = true, lambda = 1000, delta = 2)
backward_vec1 = source.MVAnalyse(isb = true, lambda = 1000, delta = 1)
forward_vec1 = source.MVAnalyse(isb = false, lambda = 1000, delta = 1)
forward_vec2 = source.MVAnalyse(isb = false, lambda = 1000, delta = 2)
source.MVDenoise(backward_vec2,backward_vec1,forward_vec1,forward_vec2,tht=10,thSAD=300)</pre>

<p>Deblokování kompenzace uloené v mvs streamu (streamu vektorù pohybu)</p>
<pre>vectors = source.MVAnalyse(isb = false, lambda = 1000)
compensation = source.MVCompensate(vectors, mode = 0)
compensation = compensation.Deblock() # pouití funkce DeBlock
vectors = vectors.MVChangeCompensate(compensation)</pre>

<p>Odšumìní s pel = 2, efektivní :</p>
<pre>backward_vec2 = source.MVAnalyse(isb = true, lambda = 1000, delta = 2, pel = 2, idx = 1)
backward_vec1 = source.MVAnalyse(isb = true, lambda = 1000, delta = 1, pel = 2, idx = 1)
forward_vec1 = source.MVAnalyse(isb = false, lambda = 1000, delta = 1, pel = 2, idx = 1)
forward_vec2 = source.MVAnalyse(isb = false, lambda = 1000, delta = 2, pel = 2, idx = 1)
source.MVDenoise(backward_vec2,backward_vec1,forward_vec1,forward_vec2,tht=10,thSAD=300)</pre>

<p>Pouití MVIncrease : </p>
<pre>vectors = source.reduceby2().mvanalyse(isb = true)
return source.MVIncrease(vectors, horizontal = 2, vertical = 2)</pre>

<p>Pouití MVDepan s pluginem <a href="depan.htm">Depan</a> pro prokládanı zdroj
 (pøíklad funkce DepanStabilize):</p>
<pre>source = source.AssumeTFF().SeparateFields() # nastavení správného poøadí polí
vectors = source.MVAnalyse(isb = false)
globalmotion = source.MVDepan(vectors, pixaspect=1.094, thSCD1=400)
DepanStabilize(source, data=globalmotion, cutoff=2.0, mirror=15, pixaspect=1.094)
Weave()
</pre>

<p>Rozmazání problémovıch (kostkatıch) oblastí kompenzovanıch snímkù s maskou okluze:</p>
<pre>vectors = source.MVAnalyse(isb = false, lambda = 1000)
compensation = source.MVCompensate(vectors) # nebo zde pouijte funkci MVFlow
# pøipravíme rozmazanı snímek s nìjakou silnou funkcí rozmazání nebo deblokování:
blurred = compensation.DeBlock(quant=51) # pouijeme zde funkci DeBlock
badmask = source.MVMask(vectors, kind = 2, ml=50)
overlay(compensation,blurred,mask=badmask) # nebo pouijeme rychlejší funkci MaskedMerge z MaskTools
</pre>

<p>Nové vytvoøení špatnıch snímkù interpolací pomocí MVFlowInter:</p>
<pre>backward_vectors = source.MVAnalyse(isb = true, truemotion=true, pel=2, delta=2, idx=1)
forward_vectors = source.MVAnalyse(isb = false, truemotion=true, pel=2, delta=2, idx=1)
inter = source.MVFlowInter(backward_vectors, forward_vectors, time=50, ml=70, idx=1)
# Pøedpokládejme, e špatné snímky jsou 50 a 60
source.trim(0,49) ++ inter.trim(49,-1) \
 ++ source.trim(51,59) ++ inter.trim(59,-1) ++ source.trim(61,0)
</pre>

<p>Zmìna fps pomocí MVFlowFps:</p>
<pre># Pøedpokládáme progresivní zdroj PAL 25 fps
backward_vec = source.MVAnalyse(isb = true, truemotion=true, pel=2, idx=1)
# pouijeme explicitní idx pro rychlejší zpracování
forward_vec = source.MVAnalyse(isb = false, truemotion=true, pel=2, idx=1)
source.MVFlowFps(backward_vec, forward_vec, num=50, den=1, ml=100, idx=1) # získáme 50 fps
</pre>

<p>Zdvojnásobení fps pomocí MVFlowFps pro nejrychlejší (témìø) k pøehrávání v reálném èase:</p>
<pre># Pøedpokládáme progresivní zdroj PAL 25 fps nebo NTSC Film 23.976
backward_vec = source.MVAnalyse(blksize=16, isb = true, chroma=false, pel=1, searchparam=1, idx=1)
# pouijeme explicitní idx pro rychlejší zpracování
forward_vec = source.MVAnalyse(blksize=16, isb = false, chroma=false, pel=1, searchparam=1, idx=1)
source.MVFlowFps(backward_vec, forward_vec, num=2*FramerateNumerator(source), \
   den=FramerateDenominator(source), mask=0, idx=1)
</pre>

<p>Zdvojnásobení fps pomocí MVFlowFps pro 'nejlepší' vısledky (ale pomalejší zpracování):</p>
<pre># Pøedpokládáme progresivní zdroj PAL 25 fps nebo NTSC Film 23.976
backward_vec = source.MVAnalyse(overlap=4, isb = true, pel=2, search=3, idx=1)
# pouijeme pøekrıvání blokù, pøesnost na pùl pixelu a Vyèerpávající vyhledávání
forward_vec = source.MVAnalyse(overlap=4, isb = false, pel=2, search=3, idx=1)
source.MVFlowFps(backward_vec, forward_vec, num=2*FramerateNumerator(source), \
   den=FramerateDenominator(source), idx=1)
</pre>

<p>Zmìna fps pomocí MVFlowFps2:</p>
<pre># Pøedpokládáme progresivní zdroj PAL 25 fps. Zkusme ho pøevést na 50.
backward_vec = source.MVAnalyse(isb = true, truemotion=true, pel=2, idx=1, search=3)
# pouijeme explicitní idx pro rychlejší zpracování a pouijeme úplné vyhledávání
forward_vec = source.MVAnalyse(isb = false, truemotion=true, pel=2, idx=1, search=3)
cropped = source.crop(4,4,-4,-4) # o polovinu velikosti bloku 8
backward_vec2 = cropped.MVAnalyse(isb = true, truemotion=true, pel=2, idx=2, search=3)
forward_vec2 = cropped.MVAnalyse(isb = false, truemotion=true, pel=2, idx=2, search=3)
source.MVFlowFps2(backward_vec,forward_vec,backward_vec2,forward_vec2,num=50,idx=1,idx2=2)
</pre>

<p>Generování pìkného rozmazání pohybu pomocí MVFlowBlur:</p>
<pre>backward_vectors = source.MVAnalyse(isb = true, truemotion=true)
forward_vectors = source.MVAnalyse(isb = false, truemotion=true)
source.MVFlowBlur(backward_vectors, forward_vectors, blur=15)
</pre>

<p>Odšumìní pomocí nìjakého externího filtru pro odstranìní šumu (kterı pouívá 3 snímky: pøedchozí, aktuální, následující):</p>
<pre>backward_vectors = source.MVAnalyse(isb = true, truemotion=true, delta = 1, idx = 1)
# pouijeme explicitní idx pro rychlejší zpracování
forward_vectors = source.MVAnalyse(isb = false, truemotion=true, delta = 1, idx = 1)
forward_compensation = source.MVFlow(forward_vectors, idx=1, thSCD1=500) # nebo pouijte MVCompensate
backward_compensation = source.MVFlow(backward_vectors, idx=1, thSCD1=500) # nebo pouijte MVCompensate
# vytvoøíme postupné 3-snímkové sekvence
interleave(forward_compensation, source, backward_compensation)

DeGrainMedian() # umístìte sem váš oblíbenı èasovı nebo èasovì-prostorovı (temporal nebo spatial-temporal) odšumovaè

selectevery(3,1) # vrací jen filtrované centrální (nekompenzované) snímky
</pre>

<p>Pouití pøedfiltrovaného klipu pro spolehlivìjší odhad pohybu,
ale kompenzaci pohybu nepøedfiltrovaného klipu (pøíklad odšumìní)</p>

<pre># Pouijte nìkterı odšumovaè (rozmazávaè) nebo odstraòovaè blikání (deflicker) pro pøedfiltrování
prefiltered = source.DeGrainMedian()
backward_vectors = prefiltered.MVAnalyse(isb = true, truemotion=true, delta = 1, idx = 1)
# pouijeme explicitní idx pro rychlejší zpracování
forward_vectors = prefiltered.MVAnalyse(isb = false, truemotion=true, delta = 1, idx = 1)
# pouijeme nepøedfiltrovanı klip pro kompenzaci pohybu (s jinım idx)
forward_compensation = source.MVFlow(forward_vectors, idx=2) # nebo pouijte MVCompensate(mode=1)
backward_compensation = source.MVFlow(backward_vectors, idx=2) # nebo pouijte MVCompensate(mode=1)
# vytvoøíme postupné 3-snímkové sekvence
interleave(forward_compensation, source, backward_compensation)

DeGrainMedian() # umístìte sem váš oblíbenı èasovı nebo èasovì-prostorovı (temporal nebo spatial-temporal) odšumovaè

selectevery(3,1) # vrací jen filtrované centrální (nekompenzované) snímky
</pre>

<p>Odšumìní pomocí MVDegrain2 s pøekrytımi bloky (blksize=8) a subpixelovou pøesností:</p>
<pre>backward_vec2 = source.MVAnalyse(isb = true, delta = 2, pel = 2, overlap=4, sharp=1, idx = 1)
backward_vec1 = source.MVAnalyse(isb = true, delta = 1, pel = 2, overlap=4, sharp=1, idx = 1)
forward_vec1 = source.MVAnalyse(isb = false, delta = 1, pel = 2, overlap=4, sharp=1, idx = 1)
forward_vec2 = source.MVAnalyse(isb = false, delta = 2, pel = 2, overlap=4, sharp=1, idx = 1)
source.MVDegrain2(backward_vec1,forward_vec1,backward_vec2,forward_vec2,thSAD=400,idx=1)</pre>

<p>Odšumìní prokládaného zdroje pomocí MVDegrain1 s pøekrıvajícími se bloky (blksize=8) a subpixelovou pøesností:</p>
<pre>fields=source.AssumeTFF().SeparateFields() # nebo AssumeBFF
backward_vec2 = fields.MVAnalyse(isb = true, delta = 2, pel = 2, overlap=4, sharp=2, idx = 1)
forward_vec2 = fields.MVAnalyse(isb = false, delta = 2, pel = 2, overlap=4, sharp=2, idx = 1)
fields.MVDegrain1(backward_vec2,forward_vec2,thSAD=400,idx=1)
Weave()</pre>

<p>Odšumìní prokládaného zdroje pomocí funkce MVDegrain2i:</p>
<pre>function MVDegrain2i(clip "source", int "overlap", int "dct", int "idx")
{
overlap=default(overlap,0) # hodnota pøekrytí (0 a 4 pro blksize=8)
dct=default(dct,0) # pouijte dct=1 pro klip se slabım blikáním
idx=default(idx,1) # pouijte rùzné idx pro rozdílné zdroje ve stejném skriptu
fields=source.SeparateFields() # rozdìlíme pole
backward_vec2 = fields.MVAnalyse(isb = true, delta = 2, pel = 2, overlap=overlap, idx = idx,dct=dct)
forward_vec2 = fields.MVAnalyse(isb = false, delta = 2, pel = 2, overlap=overlap, idx = idx,dct=dct)
backward_vec4 = fields.MVAnalyse(isb = true, delta = 4, pel = 2, overlap=overlap, idx = idx,dct=dct)
forward_vec4 = fields.MVAnalyse(isb = false, delta = 4, pel = 2, overlap=overlap, idx = idx,dct=dct)
fields.MVDegrain2(backward_vec2,forward_vec2,backward_vec4,forward_vec4,thSAD=400,idx=idx)
Weave()
}

source=AVISource("video.avi")
mvdegrain2i(source,4,0,1)
</pre>

<p>Jak pouít externí klip subpixelové interpolace:</p>
<pre># Naètìte plugin Eedi2 (<a href="http://bengal.missouri.edu/%7Ekes25c/">od tritical</a>) s funkcí interpolace se zohlednìním smìrù obrysù
LoadPlugin("Eedi2.dll")
# vytvoøíme ze zdroje nadvzorkovanı klip
ups = source.EEDI2(field=1).LanczosResize(2*width(source), 2*height(source), src_left=0.25)
bv = source.MVAnalyse(isb = true, pel = 2, overlap=4, pelclip=ups, idx = 1)
source.MVCompensate(bv, pelclip=ups, idx=1)
</pre>

<p>Jak pouít s MT filtrem a speciální <a href="http://forum.doom9.org/showthread.php?t=94996">vícevláknovou verzí AviSynthu</a>:</p>
<pre># Naètìte MT plugin od TSP
LoadPlugin("MT.dll")
avisource("some.avi")
global idx1 = 10  # globální údaje od IanB
MT("""
idx1 = idx1 + 1
# rùzná vlákna pro horní a spodní polovinu snímku musí mít rùzné idx (trik od Foxishadis)
backward_vec2 = MVAnalyse(isb = true, delta = 2, pel = 2, overlap=4, sharp=1, idx = idx1)
backward_vec1 = MVAnalyse(isb = true, delta = 1, pel = 2, overlap=4, sharp=1, idx = idx1)
forward_vec1 = MVAnalyse(isb = false, delta = 1, pel = 2, overlap=4, sharp=1, idx = idx1)
forward_vec2 = MVAnalyse(isb = false, delta = 2, pel = 2, overlap=4, sharp=1, idx = idx1)
last.MVDegrain2(backward_vec1,forward_vec1,backward_vec2,forward_vec2,thSAD=400,idx=idx1)
""",2) # dvì vlákna

# Poznámka: Reim SetMTMode(2) vícevláknového AviSynthu je podporován od MVTools v.1.8.4.1 (beta testing)
</pre>
<p>Stejnı pøíklad se SetMTMode:</p>
<pre>SetMTMode(5)
FFmpegSource("some.avi") # avisource nepracuje se SetMTMode na mém stroji - TSchniede

SetMTMode(2)
idx = 1
backward_vec2 = MVAnalyse(isb = true, delta = 2, pel = 2, overlap=4, sharp=1, idx = idx)
backward_vec1 = MVAnalyse(isb = true, delta = 1, pel = 2, overlap=4, sharp=1, idx = idx)
forward_vec1 = MVAnalyse(isb = false, delta = 1, pel = 2, overlap=4, sharp=1, idx = idx)
forward_vec2 = MVAnalyse(isb = false, delta = 2, pel = 2, overlap=4, sharp=1, idx = idx)
last.MVDegrain2(backward_vec1,forward_vec1,backward_vec2,forward_vec2,thSAD=400,idx=idx)
</pre>

<p>Jak pouít pøedfiltrovanı klip a pøepoèítat data pohybu pùvodního zdroje (MVFlowFPS pøíklad)</p>
<pre>prefiltered = source.DeGrainMedian() # trocha vyhlazení
backward = prefiltered.MVAnalyse(isb = true, idx = 1, blksize=16)
forward = prefiltered.MVAnalyse(isb = false, idx = 1, blksize=16)
# pøepoèítání pùvodního zdrojového klipu s jinou velikostí bloku
forward_re = MVRecalculate(source, forward, idx=2, blksize=8, thSAD=100)
backward_re = MVRecalculate(source, backward, idx=2, blksize=8, thSAD=100)
source.MVFlowFps(backward_re, forward_re, num=50, den=1, idx=2)</pre>

<h2><a name="disclaimer"></a>IV) Odmítnutí záruk
</h2>
<p>Tento plugin je šíøen za podmínek GNU GPL licence, bez jakıchkoli záruk. Viz. 'gpl.txt'.<br>
Dokumentace je šíøena pod <a href="http://creativecommons.org/licenses/by-sa/3.0/">CreativeCommons BY-SA 3.0 license.</a><br>
</p><p>Zvate prosím provedení nìjaké <a href="http://avisynth.org.ru/donate.html">dotace</a> pro podporu.</p>
<p>MVTools pouívají èásti kódu z následujících projektù:<br>
Resizer (SimpleResize.cpp) je z Avisynth pluginu SimpleResize od Toma Barryho. http://www.trbarry.com<br>
Fast DCT (fdct_mmx.asm) je z XVID MPEG-4 VIDEO KODEKU. http://www.xvid.org<br>
DCT general transform (viz. fftwlite.h) je z FFTW knihovny (jako DLL vızva). http://www.fftw.org<br>
SATD (pixel-32.asm, pixel.asm) a alternative SADx264 (sad-a.asm,
x86inc.asm, x86inc-32.asm, cpu-32.asm) jsou z projektu x264.
http://www.videolan.org/developers/x264.html
(Loren Merritt, Laurent Aimar, Alex Izvorski et al).
</p>

<h2><a name="revisions"></a>V) Revize
</h2>
<small>
<p>1.11.4.5 (15.11.2008 by Fizick)</p>
<ul>
<li>MVBlockFps: fixed left border bug</li>
</ul>
<p>1.11.4.4 (15.10.2008 by Fizick)</p>
<ul>
<li>Restore old internal cache size growing as before v1.11.4.2 (some crashes reported).</li>
</ul>
<p>1.11.4.3 (08.10.2008 by Fizick)</p>
<ul>
<li>MVDenoise: fixed error of v.1.11.4 with luma correction.</li>
<li>MVCompensate: fix potential memory leakage (in constructor).</li>
</ul>
<p>1.11.4.2 (26.09.2008 by Fizick)</p>
<ul>
<li>MVAnalyse: cut unused compensation memory space from vector clip (mc parameter).</li>
<li>Decreased internal cache size growing.</li>
<li>All MVFlow functions: fixed old bug with pixels for pel=4.</li>
<li>MVAnalyse: added rfilter parameter (smooth method).</li>
<li>MVBlockFps: added YUY2 and pelclip support.</li>
<li>Tiny stability fixes for MT.</li>
</ul>
<p>1.11.0.1 beta (08.09.2008 by Fizick)</p>
<ul>
<li>New MVBlockFps for simple fps change (almost realtime :-).</li>
<li>MVAnalyse: more smooth method of frame hierarchical level reducing (like ReduceBy2) for smoothing at every level.</li>
<li>MVAnalyse: Added pzero parameter of zero vector cost for more coherent motion vectors (now switched ON by default, set to 0 if you need in old algo).</li>
<li>MVAnalyse: Decreased pelsearch internal clipping from pel to 1 (asked by somebody for speed).</li>
<li>MVFlowFps,MVFlowFps2, MVFlowInter: removed thSAD parameter.</li>
<li>All functions: Removed mmx parameter.</li>
</ul>
<p>1.10.2.1 (28.08.2008 by Fizick)</p>
<ul>
<li>MVDegrain1-3: fixed old rounding error resulted in some chroma tint
(some thanks to Didee for bugreport, but it could be more persevering in official MVTools forum thread :)</li>
<li>Made doc about pelclip more accurate (hopely).</li>
</ul>
<p>1.10.2.0 beta (27.08.2008 by Fizick)</p>
<ul>
<li>Debugged and renamed MVRefine back to new MVRecalculate :).</li>
<li>MVAnalyse: changed LSAD threshold from hard by soft for a little more coherent motion at bad areas.</li>
<li>MVAnalyse: fixed old bug for (rarely used) different horizontal and vertical overlap sizes.</li>
</ul>
<p>1.10.1.0 not public (22.08.2008 by Fizick)</p>
<ul>
<li>Change MVRecalculate by more general function (MVRefine) which can re-estimate vectors.</li>
</ul>
<p>1.10.0.0 not public (18.08.2008 by Fizick)</p>
<ul>
<li>Added MVRecalculate function to update SAD (as requested by Didee).</li>
<li>Fixed possible memory leaks (thanks to josey_wells for note)</li>
<li>Other changes of v1.9.6-1.9.7 branch by josey_wells are still not merged -
 too many work to analyse new code and numerous cosmetic rewriting,
 so based on v1.9.5.7</li>
</ul>
<p>1.9.6.x-1.9.7.x series branch (01.08.2008-26.08.2008 by josey_wells)</p>
<ul>
<li>Added MVAnalyseMulti, MVDegrain, MVMultiExtract functions with internal multitheading
(that does not require any special AviSynth, SetMTMode or MT) </li>
<li>Some bug fixes (memory leaks), code consolidation (rewriting) for stability and performance improvements.
Also there is a multitude of changes due to the addition of threading class,
semaphore class, critical section class, thread files for MVDegrain, MVAnalyseMulti
as well as factoring out common code for MVDegrain into a single base class moving out common code etc.
There are no changes of algorithms.
See <a href="http://forum.doom9.org/showthread.php?t=84770">messages at forum</a> since August 2008 for download, syntax and discussion.</li>
</ul>
<p>1.9.5.7 public beta (03.07.2008 by Fizick)</p>
<ul>
<li>Fixed Overlap_2xY_mmx</li>
<li>Added (incomplete?) list of used projects to doc.</li>
</ul>
<p>1.9.5.6 (02.07.2008 by TSchniede)</p>
<ul>
<li>Improved my, added Overlap_2xY_mmx, optimized CheckMV2 and LumaSAD.</li>
</ul>
<p>1.9.5.5 (28.06.2008 by TSchniede)</p>
<ul>
<li>Improved default 2xY SAD and added new faster 2xY SAD.</li>
</ul>
<p>1.9.5.4 (27.06.2008 by TSchniede)</p>
<ul>
<li>Ported CPU detection from x264.</li>
<li>Now using x264 SAD autoddetect is default</li>
<li>Merge with 1.9.5.1, re-enabled 32x16 mode (only default functions)</li>
</ul>
<p>1.9.5.3 (26.06.2008 by TSchniede)</p>
<ul>
<li>Imported SSD & SATD funtions.</li>
<li>access using sadx264 > 7 or dct > 4.</li>
</ul>
<p>1.9.5.2 (24.06.2008 by TSchniede)</p>
<ul>
<li>Buffered source block in aligned area before calculating SAD.</li>
<li>This fixes crashes if source block was unaligned due to overlaped blocks.</li>
<li>Worst case was < 1% slower, most of the time it further increases performance.</li>
</ul>
<p>1.9.5.1 public beta (21.06.2008 by Fizick)</p>
<ul>
<li>Merge v.1.9.5 changes by TSchniede.</li>
</ul>
<p>1.9.5 (21.06.2008 by TSchniede), based on v.1.9.3</p>
<ul>
<li>MVAnalyse: added sadx264 option.</li>
<li>Internal modifications - aligned memory of luma&chroma planes and modified MVTools to the interface of the SAD functions used in x264.</li>
<li>minor bugfix (deactivate DebugPrint possible)</li>
</ul>
<p>1.9.4.1 beta (12.06.2008 by Fizick, released 21.06.2008)</p>
<ul>
<li>Fixed bug for pel=4 with sharp=2 (thanks to Pustovetov for report and fix).</li>
<li>MVCompensate: added block size 16x2 (bug reported by AVIL).</li>
</ul>
<p>1.9.4 not public beta (08.06.2008 by Fizick)</p>
<ul>
<li>MVAnalyse and other: added block size 32x16 (requested by MAG79).</li>
</ul>
<p>1.9.3.1 (05.06.2008 by Fizick)</p>
<ul>
<li>MVIncrease: was broken (as noted by MAG79).</li>
</ul>
<p>1.9.3 (20.04.2008 by Fizick)</p>
<ul>
<li>MVAnalyse: fixed bug for pelclip (broken since v1.8.5).</li>
<li>MVDegrain: added thSADC as chroma threshold (request by Terranigma).</li>
</ul>
<p>1.9.2 (29.01.2008, all bugs were found by josey_wells)</p>
<ul>
<li>MVDegrain3: fixed bug in code for 16x8 block; fix typo (MVDegrain2 instead of MVDegrain3).</li>
<li>MVAnalyse: fixed old bug in NStepSearch.</li>
</ul>
<p>1.9.1 beta (15.12.2007 by Fizick)</p>
<ul>
<li>MVAnalyse: Increased speed (by 20%) of global motion estimation (other algo).</li>
<li>MVAnalyse: Added assembler optimization for small blocksizes SAD (speed by 50%).</li>
<li>MVMask: Added kind=5 motion colormap as x,y components of motion vector shown in U, V color planes.</li>
</ul>
<p>1.9.0 (04.12.2007 by Fizick)</p>
<ul>
<li>Added MVDegrain3.</li>
</ul>
<p>1.8.6 (02.12.2007 by Fizick)</p>
<ul>
<li>Added components x,y motion vector mask kind=3,4 to MVMask (requested by Terka).</li>
</ul>
<p>1.8.5.1 (12.11.2007 by we:)</p>
<ul>
<li>Merge v1.8.4.3 and v1.8.5 changes, added MT example.</li>
</ul>
<p>1.8.4.3 (05.10.2007 by Tsp)</p>
<ul>
<li>Implemented internal cache buffer miss detection with buffer growing (as suggested by IanB).</li>
</ul>
<p>1.8.5 (05.11.2007 by Fizick)</p>
<ul>
<li>Added pelsearch parameter as search parameter (radius) at finest level (request by Terranigma).</li>
<li>Decreased internal buffer to decrease memory usage, with some changes in critical sections.</li>
<li>Added block size 16x2 (requested by ab_99).</li>
</ul>
<p>1.8.4.2 (25.10.2007 by Tsp)</p>
<ul>
<li>Added critical section in frame refining to fix rare bug in multi-threaded processing.</li>
</ul>
<p>1.8.4.1 (23.10.2007 by Tsp)</p>
<ul>
<li>Implemented thread-safe internal buffer access
for correct multithreaded processing with SetMTmode(2) in Avisynth MT version (for multi CPU).</li>
</ul>
<p>1.8.4 (22.08.2007 by Fizick)</p>
<ul>
<li>"divide" now works with "overlap".</li>
</ul>
<p>1.8.3 (17-20.08.2007 by Fizick)</p>
<ul>
<li>MVFlowFps: renamed "mode" parameter to "mask".</li>
<li>MVFlowFps2: added "mask" parameter.</li>
<li>MVFlowFPS, MVFlowFPS2: Restored default values num=25, den=1 (as was in version 1.7 and early)</li>
<li>MVDegrain1, MVGegrain2 - added "limit" parameter.</li>
</ul>
<p>1.8.2 beta (30.07.2007 by Fizick)</p>
<ul>
<li>MVAnalyse: corrected (increased) search radius at finest level for pel>1.</li>
<li>Added pel=4 option for quarter pixel precision.</li>
<li>Renamed clip2x parameter to pelclip.</li>
</ul>
<p>1.8.1 beta (28.06.2007 by Fizick)</p>
<ul>
<li>MVAnalyse: added postrocessing motion vectores by dividing blocks into subblocks to decrease zone of motion vectors interpolation.</li>
<li>MVFlowFps: added "mode" parameter to select processing method at occlusion areas (and speed).</li>
<li>Some internal changes (padding in MVAnalysisData, header to vector stream frames, etc).</li>
</ul>
<p>1.8.0 beta (22.06.2007 by Fizick)</p>
<ul>
<li>MVFlowInter, MVFlowFPS, MVFlowFPS2, MVMask: improved occlusion mask by extent</li>
<li>MVFlowInter, MVFlowFPS: decreased objects halo at occlusion areas by using motion vectors of adjacent frames</li>
<li>MVFlowInter, MVFlowFPS: disabled SAD mask and thSAD parameter</li>
<li>MVShow: fixed drawn positon of vectors</li>
<li>MVFlowFPS, MVFlowFPS2: Changed default output fps to double of input (default num, den = 0) </li>
<li>Added error messages on missed vector clips</li>
</ul>
<p>1.7.0 beta (05.06.2007 by Fizick)</p>
<ul>
<li>MVAnalyse: added blksizeV and overlapV parameters for non-square blocks 8x4 and 16x8.</li>
</ul>
<p>1.6.4 (30.05.2007 by Fizick)</p>
<ul>
<li>MVAnalyse: modified vectors order for Enhausted search (expanding squares).</li>
<li>MVAnalyse: fixed bug with dct=3.</li>
<li>MVFlowFps, MVFlowFPS2, MVFlowInter: now blend frames with bad motion estimaton (at scenechanges, flashes).</li>
<li>MVFlowFps, MVFlowFPS2: fixed bug with thSAD parameter (and correspondent mask).</li>
</ul>
<p>1.6.3 (06.05.2007 by Fizick)</p>
<ul>
<li>MVDepan: more compatible with DepanEstimate (range parameter, etc).</li>
</ul>
<p>1.6.2 (11.11.2006 by Fizick)</p>
<ul>
<li>MVAnalyse: changed DCT=2 mode to global luma dependent.</li>
</ul>
<p>1.6.1 beta (25.10.2006 by Fizick)</p>
<ul>
<li>MVAnalyse: added experimental DCT mode to improve motion estimation at luma flicker and fades (fast for blksize=8 only).</li>
</ul>
<p>1.5.8 beta (14.10.2006 by Fizick)</p>
<ul>
<li>Many functions: added <var>clip2x</var> parameter to use 2X upsampled clip instead of internal subpixel interpolation for pel=2</li>
<li>MVFlowFps, MVFlowFps2: added <var>thSAD</var> parameter; use local blending of neighbour frames pixels
 in regions with bad motion vectors</li>
<li>MVFlowFps, MVFlowFps2: may use motion vectors for any frames <var>delta</var></li>
<li>MVFlowFps, MVFlowFps2: fixed a bug for video with big nominators and denominators (thanks to Trixter for report)</li>
<li>MVCompensate: added experimental <var>fields</var> parameter
 to compensate fields shift of fieldbased video for pel=2</li>
<li>MVAnalyse: changed pnew parameter to relative of SAD</li>
</ul>
<p>1.5.3 beta (01.10.2006 by Fizick)</p>
<ul>
<li>MVAnalyse: improved zero motion estimation for fieldbased video for pel=2</li>
<li>Merged v1.4.12-1.4.13 changes</li>
<li>Temporary restored MVIncrease, MVChangeCompensation, MVDenoise (with compensation stored in vector clip)</li>
</ul>
<p>1.5.1 beta (05.09.2006 by Fizick)</p>
<ul>
<li>Merged v1.4.11 changes</li>
</ul>
<p>1.5.0 beta (23.08.2006 by Fizick)</p>
<ul>
<li>Corrected vector predictors interpolation (from coarse to fine scale) for overlap>0.</li>
<li>MVFlowInter: added thSAD parameter.</li>
<li>MVFlowInter: local blending of neighbour frames pixels
 in regions with bad motion vectors.</li>
<li>Removed compensation storage in vector clip</li>
<li>Removed functions MVIncrease, MVChangeCompensation, MVDenoise
(it used compensation in vector clip, and did not support overlapping).</li>
<li>Removed  mode=2 loop option of MVCompensation, mode=0 is processed as mode=1 now.</li>
<li>Added thSAD parameter to MVCompensation for safe (dummy) compensation as requested by Didee</li>
</ul>
<p>1.4.13 (28.09.2006 by Fizick)</p>
<ul>
<li>Fixed bug with possible wrong frames pointers in core (MVClip.Update),
hided by caching (thanks to IanB for advice)</li>
</ul>
<p>1.4.12 (25.09.2006 by Fizick)</p>
<ul>
<li>Seems fixed bug with frames caching in MVDenoise (and possible in MVDegrain) (thanks to il9ad for report)</li>
</ul>
<p>1.4.11 (06.09.2006 by Fizick)</p>
<ul>
<li>Corrected vector predictors interpolation (from coarse to fine scale) for overlap>0.</li>
<li>Fixed bug with pitch for overlap=0, YV12 in MVDegrain1 (thanks to Boulder for report)</li>
</ul>
<p>1.4.10 (18.08.2006 by Fizick)</p>
<ul>
<li>Corrected right and bottom borders processing in MVCompensate for arbitrary frame sizes.</li>
<li>Changed defaults in MVAnalyse: pel=2, truemotion=true, sharp=2.</li>
</ul>
<p>1.4.9 (14.08.2006 by Fizick)</p>
<ul>
<li>Fixes a bug in MMX optimization of overlap mode in MVDeGrain, MVCompensate for YUY2 with blksize=8
 (thanks to TSchniede for report).</li>
</ul>
<p>1.4.8 (31.07.2006 by Fizick)</p>
<ul>
<li>Added some MMX optimization of overlap mode in MVDeGrain, MVCompensate.</li>
<li>Fixed a bug with last (not processed) rows in MVDeGrain.</li>
</ul>
<p>1.4.7 (25.07.2006 by Fizick)</p>
<ul>
<li>Decreased overlap gridness in MVDeGrain1, MVDeGrain2, MVCompensate.</li>
<li>Added example with MVDeGrain1 for interlaced.</li>
</ul>
<p>1.4.6 (24.07.2006 by Fizick)</p>
<ul>
<li>Decreased denoising in MVDeGrain1, MVDeGrain2.</li>
<li>Plane parameter in MVDeGrain1, MVDeGrain2 now works :)</li>
</ul>
<p>1.4.5 (22.07.2006 by Fizick)</p>
<ul>
<li>Added plane parameter to MVDeGrain1, MVDeGrain2.</li>
</ul>
<p>1.4.4 (19.07.2006 by Fizick)</p>
<ul>
<li>Corrected default thSAD=400 in MVDeGrain1, MVDeGrain2.</li>
<li>Fixed a bug with V color plane in MVChangeCompensate.</li>
</ul>
<p>1.4.3 (17.07.2006 by Fizick)</p>
<ul>
<li>Decrease overlap gridness in MVDeGrain1, MVDeGrain2.</li>
</ul>
<p>1.4.2 (16.07.2006 by Fizick)</p>
<ul>
<li>Fixed a memory access bug in MVDeGrain1, MVDeGrain2. Thanks to krieger2005 for report.</li>
</ul>
<p>1.4.1 (23.06.2006 by Fizick)</p>
<ul>
<li>Changed MVDeGrain1, MVDeGrain2 mode to SAD weigthing.</li>
<li>Chanded thSCD1 default from 300 to 400.</li>
</ul>
<p>1.4.0 (19.06.2006 by Fizick)</p>
<ul>
<li>Added MVDeGrain1, MVDeGrain2 limited averaging denoisers.</li>
<li>Corrected thSAD scale in MVDenoise.</li>
<li>Corrected documentation about SAD.</li>
</ul>
<p>1.3.1 (11.06.2006 by Fizick)</p>
<ul>
<li>Added bicubic subpixel interpolation method for pel=2 (with iSSE optinization for sharp=1,2).</li>
<li>Assembler iSSE speed optimization for overlapped block compensation.</li>
</ul>
<p>1.3.0 (05.06.2006 by Fizick)</p>
<ul>
<li>Implemented overlapped block motion compensation to MVCompensation(mode=1).</li>
<li>Changed default to mode=1 in MVCompensation as the most universal.</li>
<li>Added sharp subpixel interpolation method for pel=2.</li>
<li>Fixed bug for blksize=16 with YUY2.</li>
<li>(To-do list: assembler SSE speed optimization for new compensation and interpolation methods.)</li>
</ul>
<p>1.2.6 beta (21.05.2006 by Fizick)</p>
<ul>
<li>Added option to write motion vectors data to log file as requested by Endre.</li>
</ul>
<p>1.2.5 (08.05.2006 by Fizick)</p>
<ul>
<li>Decreased zero vector weight, iteration accuracy in MVDepan</li>
</ul>
<p>1.2.4 (07.04.2006 by Fizick)</p>
<ul>
<li>Fixed bug v.1.2.3 with info mode in MVDepan</li>
</ul>
<p>1.2.3 (31.03.2006 by Fizick)</p>
<ul>
<li>Implemented MVDepan for interlaced source separated by fields;</li>
<li>added optional MVDepan log file.</li>
</ul>
<p>1.2.2 beta (01.03.2006 by Fizick)</p>
<ul>
<li>Fixed frame shift bug of v1.2.1 with mmx YUY2 conversion (thanks to <b>WorBry</b> for bug report)</li>
</ul>
<p>1.2.1 beta (20.02.2006 by Fizick)</p>
<ul>
<li>Fixed bug of v1.2,</li>
<li>Speed restored,</li>
<li>mmx YUY2 conversion (from avisynth 2.6 function by sh0dan) </li>
<li>But it seems, overlap mode still does not work properly</li>
</ul>
<p>1.2 beta (17.02.2006 by Fizick)</p>
<ul>
<li>YUY2 format support (besides MVIncrease), no optimization</li>
</ul>
<p>1.1.1 (16.02.2006 by Fizick)</p>
<ul>
<li>Removed DeBlock and Corrector filters (will be separate plugins)</li>
<li>Documented old MVSCDetection function.</li>
<li>Cleaned project from unused source files.</li>
</ul>
<p>1.1 (non-public build 9.01.2006 by Fizick)</p>
<ul>
<li>Quite large revision (beta). New option for overlapped block motion estimation in MVAnalyse
for usage in MVFlow, MVFlowInter, MVFlowFps for improved motion compensation.</li>
<li>Lookup tables for motion interpolation.</li>
<li>Small correction of  displacement value in MVFlowFps2.</li>
</ul>
<p>1.0.3 (Released 30.12.2005 by Fizick)</p>
<ul>
<li>Fixed bug with displacement in MVFlowInter, MVFlowFps (introduced in v1.0.2).</li>
</ul>
<p>1.0.2 (Released 28.12.2005 by Fizick)</p>
<ul>
<li>Corrected value of displacement in MVFlow (a little).</li>
</ul>
<p>1.0.1 (Released 24.12.2005 by Fizick)</p>
<ul>
<li>Fixed memory leakage bug in MVAnalyse with global motion (thanks to <b>AI</b> for report).</li>
<li>Removed penalty for zero vector predictor in MVAnalyse (was introduced in v1.0).</li>
<li>Changed chroma=true as default in MVAnalyse.</li>
</ul>
<p>1.0 (Released 29.11.2005 by Fizick)</p>
<ul>
<li>I'm tired of long version numbers :). But the plugin is stil experimental :(.</li>
<li>Restored zero vector predictor in MVAnalyse.</li>
<li>Changed blur time scale in MVFlowBlur (100 is fully open shutter now) as <b>Mug Funky</b> requested.</li>
</ul>
<p>0.9.13.3 (Released 27.11.2005 by Fizick)</p>
<ul>
<li>Added global motion (simple method) vector predictor to MVAnalyse.</li>
<li>Vector search is skipped (for speed) if good predictor was found (with SAD &lt; pnew).</li>
<li>Parameter <var>scale</var> in MVShow works properly now.</li>
<li>Disabled some debug and profiling info output (for speed increasing).</li>
<li>Changed default <var>prec</var>=1 (was 2) in MVFlowBlur.</li>
</ul>
<p>0.9.13.2 (Released 22.11.2005 by Fizick)</p>
<ul>
<li>Fixed bug in MVFlowFps, MVFlowFps2 for non-integer fps.</li>
</ul>
<p>0.9.13.1 (Released 21.11.2005 by Fizick)</p>
<ul>
<li>Fixed bug in MVFlowFps, MVFlowFps2, MVFlowInter, MVFlowBlur (introduced in v0.9.13).</li>
<li>Removed <var>plen</var> parameter from MVAnalyse as not useful.</li>
</ul>
<p>0.9.13 (Released 20.11.2005 by Fizick)</p>
<ul>
<li>Added <var>truemotion</var> preset to MVAnalyse.</li>
<li>Added experimental MVFlowFps2.</li>
<li>Change interpolated vector rounding method in all MVFLow... functions.</li>
<li>Edited documentation a little.</li>
</ul>
<p>0.9.12.4 (Released 15.11.2005 by Fizick)</p>
<ul>
<li>Changed type of <var>ml</var> parameter in MVMask, MVFlowInter, MVFlowFps from int to float.</li>
<li>Added bound check of <var>ml, time, blur</var> parameters.</li>
<li>Small possible bug fixed (emms).</li>
<li>Partially updated documentation. But I am not sure that <b>sh0dan</b> requested <b>exactly such</b> updating :).
It is still not user guide but functions reference.</li>
</ul>
<p>0.9.12.3 (Released 14.11.2005 by Fizick)</p>
<ul>
<li>Fixed bug for chroma for width not divisible by 16 in MVMask (introduced in v0.9.11).</li>
<li>Some speed optimizing of MVFlowFps.</li>
<li>Reset size of internal frames buffer to original value 10. Try various versions.</li>
</ul>
<p>0.9.12.2 (Released 13.11.2005 by Fizick)</p>
<ul>
<li>Added experimental precise but slow MVFlowBlur function as <b>scharfis_brain</b> requested.</li>
<li>Temporary changed size of internal frames buffer to 5.</li>
</ul>
<p>0.9.12.1 (Released 12.11.2005 by Fizick)</p>
<ul>
<li>Added experimental MVFlowFps function.</li>
<li>Disabled MVInter function.</li>
<li>Temporary changed size of internal frames buffer from 10 to 3 for memory usage decreasing.
Speed must be tested for complex scripts.</li>
</ul>
<p>0.9.12 (Released 09.11.2005 by Fizick)</p>
<ul>
<li>Added MVFlowInter function. MVInter function will be removed in next release (it is worse).</li>
<li>Changed scale of <var>ml</var> parameter for kind=2 of MVMask to more optimal default.</li>
<li>Fixed small bug in Bilinear.asm (strange pixels near right border for pel=2).</li>
</ul>
<p>0.9.11.1 (Released 06.11.2005 by Fizick)</p>
<ul>
<li>Added half-pel support to MVFlow.</li>
<li>Increased max <var>quant</var> from 51 to 60 in DeBlock for very strong deblocking .</li>
<li>Corrected documentation.</li>
</ul>
<p>0.9.11 (Released 04.11.2005 by Fizick)</p>
<ul>
<li>Improved MVMask: Replaced boolean <var>showsad</var> parameter to integer <var>kind</var>,
added occlusion mask option. Changed bilinear resize code to more correct and fast SimpleResize.</li>
</ul>
<p>0.9.10.1 (Released 01.11.2005 by Fizick)</p>
<ul>
<li>Fixed bug with chroma and luma small changes in MVInter (rounding error).</li>
<li>Vector interpolation in MVFlow and mask in MVInter are correct now (due to fixing bug in SimpleResize).</li>
</ul>
<p>0.9.10 (Released 31.10.2005 by Fizick)</p>
<ul>
<li>Added some true motion (smoothed) estimation options to MVAnalyse</li>
<li>Added function MVFlow for per-pixel motion compensation</li>
<li>Added function MVInter for motion interpolation (very experimental)</li>
</ul>
<p>0.9.9.1 (Released 20.01.2005 by Manao)</p>
<ul>
<li>No need anymore of stlport_vcxxxx.dll</li>
</ul>
<p>0.9.9</p>
<ul>
<li>Filter added : Corrector</li>
<li>Filter added : MVIncrease</li>
<li>New available blocksize : 16</li>
<li>New parameter in MVAnalyse : <var>chroma</var></li>
<li>Changes in the core</li>
</ul>
<p>0.9.8.5</p>
<ul><li><code>MVCompensate</code> changed : a new parameter, idx, which works as idx in <code>MVAnalyse</code>,
and which allows speed up when compensating the same frames several times.</li>
</ul>
<p>0.9.8.4</p>
<ul><li>ME takes into account the chroma now, as requested by tsp.</li>
</ul>
<p>0.9.8.3</p>
<ul><li>Added <code>Corrector</code> function, as requested by scharfi.</li>
</ul>
<p>0.9.8.2</p>
<ul><li>New function <code>MVDepan</code> (added by Fizick) for Depan plugin.</li>
</ul>
<p>0.9.8.1</p>
<ul><li>Several bugfixes</li>
</ul>
<p>0.9.8</p>
<ul><li>Yet another little changes in the filters' syntax. The core changed a lot,
in order to gain speed were it was possible. However, by default, the speed gain won't be
visible, you'll need to configure correctly the analysis filter through its "idx"
parameter in order to gain speed ( in the mode "pel" = 2 ).</li>
<li>Bugfixes in MVDenoise, and chroma denoising in MVDenoise.</li>
<li>Now, the filters down the filter's chain tell to the analysis filter if they need
the compensation, so you don't have to worry about that at the analysis stage.</li>
</ul>
<p>0.9.7</p>
<ul><li>Yet again, a lot of rewriting. Interpolating filters are disabled ( for the moment ),
all the other filters work and should be considered as stable. Syntax has changed a lot,
and will change again before reaching 1.0 ( if it's reached one day ). Changes mainly affect
<code>MVAnalyse</code>. New filter :  <code>MVChangeCompensate</code>.
</li></ul>
<p>0.9.6.2</p>
<ul>
<li> Fixed bug in <code>MVMask</code> parameters.</li>
</ul>

<p>0.9.6.1</p>
<ul>
<li>Lot of bugfixes for the existing filters. MVMask, MVShow, MVCompensate, MVDenoise and MVSCDetection, and MVAnalyse should work .
Other may crash unexpectedly.</li>
<li>Now, for the three new filters. Two have nothing to do with motion compensation,
but I didn't want to put them in separate binaries, since they'll mainly be used with filters from this package.
The third one uses vectors, and integrates somehow the two others.</li>
<li>QDeQuant(clip c, int quant, int level) : takes a clip and quantizes it, using an approximation of the H264 DCT.
It filters the three planes ( 4x4 blocks for each of them, so the chroma isn't processed as in H264 ).
It's not exactly the H264 DCT because at q1, it's lossless, and a q51 it's not that bad, but you can raise quant over 51.
Level is the reference level of the picture.
By default it's zero, but it can be set, for example, to 128.
The picture is then treates as if pixels were ranging from -128 to 127, hence avoiding errors around 128.</li>
<li>Deblock(clip c, int quant, int aOffset, int bOffset ) : takes a clip, and deblock it using H264 deblocking,
as if the picture was made only of inter blocks. This time, quant ranges from 0 to 51 as in H264, and has the same impact.
aOffset and bOffset allow to raise / lower the quant when deciding for some internal thresholds.
They are set by default to 0. Be warned that the filter should do nothing at quant lesser 16, if aOffset and bOffset are both zero.
It's a wanted behavior ( thus it respect the partially the norm ).</li>
<li>EncDenoise(clip c, clip vectors, bool scbehavior, int quant, int aOffset, int bOffset, int thSCD1, int thSCD2) :
it merges Deblock, QDeQuant and MVCompensate, taking from them the name and behavior of their parameters.
It basically does a h264 encode as if all blocks were 8x8 inter blocks.
Reference frame is the previous frame output by the filter ( if it is the correct one, else it's the previous frame of the source ),
mvs are those given by mvanalyse on the source. The reference frame is compensated by the vectors,
then the residual difference is quantized / dequantized and added to the result of the motion compensation.
Finally, the frame is deblocked, and serves as reference for the next one.</li>
</ul>

<p>0.9.5.3</p>
<ul>
<li>Mainly a bugfixe ( several filters were affected by a silly bug , and MVCompensate now do padded motion compensation,
and compensate also the chroma ( though it rounds the vector to odd coordinates to do so )</li>
<li>A new feature, as asked by Fizick, for mvcompensate :
"scbehavior", a boolean set to true by default, will allow you to keep the previous frame over a scenechange if you set it to false.</li>
</ul>

<p>0.9.5.2</p>
<ul>
<li>MVMask has two new parameters : showsad (bool) which allows to build the mask of the SAD values instead of the mask of the vectors' length.
Ysc allows you to set the value taken by the mask on scene changes</li>
<li>MVCompensate : behavior modification on scene changes. Now, the current frame is left untouched if a scene change was detected.</li>
<li>New filter : MVSCDetection, with one parameter, Ysc, which works as previously.</li>
<li>MVInterpolate, MVConvertFPS and MVBlur are enabled, but may be buggy ( though I wasn't able to make MVConvertFPS crash )</li>
</ul>

<p>0.9.5
</p>
<ul>
  <li>Huge rewritting of the core engine. Vectors are now searched with a
   precision up to the pixel ( because no other filters can use yet more
   precise vectors, except MVShow ). The search engine is now fast ( which
   doesn't mean necessarily that the filters which use it are fast )</li>
   <li>A new parameter for MVAnalyse : lambda. See the documentation of the
   filter to see how it works</li>
   <li>MVDenoise works better.</li>
</ul>
<p>0.9.4
</p>
<ul>
  <li>Vectors can be saved to a file. In order to do so, add the parameter
filename="C:\foo.bar" to the filter MVAnalyse. If the file doesn't exist,
vectors will be saved into it. If it exists, vectors will be read from it. But,
be warned :
    <ul>
      <li>The file for a whole movie will be around 500 MB</li>
      <li>Saving / reading from a file need for the moment a linear access to
the frames, so it has to be used only when encoding the movie, not when doing
random access in it.</li>
      <li>The speed gain is not as great as one may hope, because SADs can't be
saved ( it would take too much space ) and so have to be recomputed.</li>
    </ul>
  </li>
  <li>The filter MVDenoise now works on 5 frames, and its parameters are now
"thT" and "sadT" ( have a look in the documentation to see how they work ). It
works nice ( very good for heavy denoising )</li>
  <li>The scene change detection thresholds have slightly changed. Now, a block
has changed if its SAD it over thSCD1. The default for thSCD1 is 300, and for
thSCD2 it is 130. It orks well ( better than the previous SCD engine ).<br>
  </li>
</ul>
<p>0.9.3</p>
<ul>
  <li>Last cleanings in the search of the motion vectors. It should be slightly
faster</li>
  <li>More search parameters can be set by the user, especially the search
algorithm. See the documentation</li>
  <li>Server / client implemented. You now first have to use MVAnalyse, and
then the filter you want. Look at the documentation and at the examples I'll
give alter.</li>
  <li>MVCompensate is separated from MVShow ( it's more logic that way ). For
the moment, it doesn't move the chroma ( same behavior as MVShow in the latest
releases )</li>
  <li>Some cleaning in MVBlur / MVInterpolate / MVConvertFPS, but still some
work to do. Now, MVBlur blurs around the frame, not between the frame and the
previous one.</li>
  <li>Half of the work is done for writing vectors to a file. But the resulting
file will be large ( around 500 MB - 1 GB I guess ).</li>
  <li>MVDenoise is slightly faster ( at least it should )</li>
  <li>Copies are optimized inside the filter, thanks to avisynth's copy
functions.</li>
  <li>MVShow can display the mean SAD of the compensation ( using showsad =
true )</li>
</ul>
<p>0.9.2.1</p>
<ul>
  <li>MVInterpolate makes its come back.</li>
  <li>MVConvertFPS should work on the last few frames of the clip</li>
</ul>
<p>0.9.2</p>
<ul>
  <li>MVInterpolate doesn't exist anymore.</li>
  <li>MVBlur and MVConvertFPS have been improved. They also have got new
parameters, have a look at the documentation.</li>
  <li>MVShow gets back its compensate mode ( MVShow(cm = true) )</li>
</ul>
<p>0.9.1 - 12.05.2004</p>
<ul>
  <li>First version renamed to MVTools. </li>
</ul>
<p>0.1-0.6 Released 24.01.2004 - 01.04.2004 by Manao</p>
<ul>
  <li>First public versions MotionVectors (Motion.dll). </li>
</ul>
</small>

<h2><a name="download"></a>VI) Stáhnout</h2>

<h3><a href="http://www.avisynth.org.ru/mvtools/mvtools-v1.11.4.5.zip">Stáhnout MVTools v.1.11.4.5</a></h3>

<h3>Existuje také nová vìtev <a href="http://www.avisynth.org.ru/mvtools/mvtools2.html">MVTools v2.0</a> , která je ve vıvoji.</h3>

<p>Starší MVTools v.0.9.9.1 mùete stáhnout z <a href="http://manao4.free.fr/">Manaovıch stránek</a></p>

</body></html>

<p><kbd>Èeskı pøeklad:12.3.2009</kbd>