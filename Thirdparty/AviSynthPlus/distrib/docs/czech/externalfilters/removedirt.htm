<html>
<head>
<title>RemoveDirt</title>
<link rel="stylesheet" type="text/css" href="../../avisynth.css">
<!--
Automatically generated, don't change:
$Id: removedirt.htm,v 1.1 2010/02/27 14:50:14 wilbertd Exp $
-->
</head>

<body>
<h1>RemoveDirt</h1>
<h2>Pøehled</h2>
<b>autor:</b> Rainer Wittmann (aka kassandro)
<br><b>verze:</b>   0.9<br>
<b>stáhnout:</b>  <a href="http://www.removedirt.de.tf/">http://www.removedirt.de.tf/</a><br>
<b>kategorie:</b>  Èasové vyhlazovaèe<br>
<b>poadavky:</b>
<ul>
  <li>YV12 &amp; YUY2 Barevné prostøedí</li>
  <li> šíøka a vıška klipu musí bıt dìlitelná 8</li><br>
  <li><a href="avsrecursion.htm">AvsRecursion</a></li><br>
  <li><a href="http://www.geocities.com/wilbertdijkhof/71.cab">msvcp71.dll/msvcr71.dll</A></li><br>
<b>licence:</b>  GNU General Public License<br>
</ul>
<hr>
		<H2>Úvod</H2>
		<P>Od verze 0.8 byl tento plugin úplnì pøepsán. U neobsahuje filtr
			RemoveDirt. Obsahuje u jen filtr
			RestoreMotionBlocks, kterı je jádrem AVS skriptové funkce
			RemoveDirt diskutované níe. Starı RemoveDirt trpìl dvìma problémy.
			Za prvé, rychlı pohyb velkıch objektù zpùsoboval trhání po pouití filtru RemoveDirt
			a za druhé v podstatì èasovı pøístup RemoveDirt nebyl konkurenceschopnı
			s prostorovì-èasovım pøístupem RemoveDust (AVS
			skript funkce odvozená od mého balíku <A href="removegrain.htm">RemoveGrain</A>&nbsp;)
			pokud se jedná o vıkon komprese. Pokud je má teorie o trhání pohybu po
			RemoveDirt správná, nová skriptová funkce RemoveDirt vyøeší tento problém.
			Základní myšlenkou nové skriptové funkce je pouití starého
			RemoveDirt pro statické oblasti a ostøejší verze RemoveDust pro pohybové oblasti,
			kde RemoveDirt pøedtím neprovádìl ádné èistìní. Celkovì se novı
			RemoveDirt snaí dosáhnout podobné, nebo lepší komprese ne RemoveDust s
			podstatnì více detaily v pohyblivıch oblastech, kde RemoveDust èasto nièil
			pìkné detaily.&nbsp;&nbsp;Vzhledem k masivním zmìnám bude zatím starı <A href="http://home.pages.at/kassandro/RemoveDirt/RemoveDirt.zip">
				soubor</A> a starı <A href="http://home.pages.at/kassandro/RemoveDirt/RemoveDirt-src.zip">
				zdrojovı kód</A> ještì dostupnı.&nbsp;&nbsp;Pokud máte otázky
			nebo návrhy k RemoveDirt nebo ResoterMotionBlocks,
			neváhejte a napište radìji na <A href="http://forum.doom9.org/showthread.php?s=&amp;threadid=70856">
				vlákno RemoveDirt</A>&nbsp;z fóra doom9 ne mi psát e-mail.
		</P>
		<P>RemoveDirt podporuje barevná prostøedí YV12 a planární YUY2. Take pokud ho chcete
			pouít na YUY2 klip, musíte ho pøevést z prolínaného (interleaved) YUY2 na planární
			YUY2 pøed RestoreMotionBlocks a pak zpìt na prolínané YUY2 pomocí filtrù
			Interleaved2Planar a Planar2Interleaved z mého pluginu SSETools. Dosud neexistuje oficiální verze tohoto pluginu
			a tak jsou obsaeny v balíku <A href="http://www.RemoveGrain.de.tf">
				RemoveGrain</A> . Protoe RemoveGrain upravuje podporu YUY2 také
			jen na planární formu, tento pøevod musí bıt proveden jen jednou pøed
			skriptovou  funkcí, která je sestavená z filtrù tìchto pluginù.</P>
		<H2>Instalace</H2>
		<P>Balík RemoveDirt obsahuje dvì verze pluginu.
			RemoveDirt.dll (dynamicky pøipojovanı, proto malı), RemoveDirtSSE2.dll (jen pro
			SSE2 kompatibilní procesory, dynamicky pøipojovanı)&nbsp;a RemoveDirtS.dll (staticky
			pøipojovanı, proto velkı). Zkuste nejdøív jeden ze dvou menších  dll a zkopírujte
			ho do sloky pluginù Avisynthu. Pokud nepracuje, je to pravdìpodobnì kvùli
			chybìjící knihovnì msvcr71.dll . Buï nainstalujte tuto knihovnu do
			C:\windows\system32 nebo smate RemoveDirt.dll a nahraïte ho souborem
			RemoveDirtS.dll. Vlote do sloky pluginù jen jeden dll soubor RemoveDirt.
			Pokud zaplníte sloku pluginù všemi druhy nadbyteènıch souborù dll,
			tak jen zpomalíte start jakékoli aplikace, která pouívá
			Avisynth. Nemìl by bıt ádnı konflikt s jinımi filtry.</P>
		<H2>Pouití</H2>
		<center><code>RestoreMotionBlocks</code> <var>(filtered, restore, neighbour, neighbour2, alternative,
			gmthreshold, mthreshold, pthreshold, cthreshold, noise, noisy, dist, tolerance,
			dmode, grey, show, debug)</var></center>
		<p>Prvních pìt promìnnıch jsou promìnné klipy. Všechny klipy musí bıt stejného
			typu (stejné šíøky, vıšky a barevného prostøedí). Poèet snímkù je minimální
			délka ze všech tìchto pìti klipù. První dvì promìnné jsou povinné.
			"filtered" je obvykle agresivnì filtrovanı klip, ze kterého se mají odstranit
			pohybové artefakty. Pokud RestoreMotionBlocks identifikuje blok 8x8 jako
			pohyblivı, zkopíruje tento blok z klipu "restore" do klipu
			"filtered". To je základní operace funkce RestoreMotionBlocks. Pro identifikaci
			pohyblivıch blokù pouívá RestoreMotionBlocks klip "neighbour". Vıchozí hodnotou pro
			neighbour je klip "restore" . Nicménì, ve skriptu RemoveDirt se
			"neighbour" liší od "restore". "neighbour2" je pro pouití
			RemoveDirt v kombinaci s filtry pro kompenzaci pohybu, jako MVtools (viz.
			MCRemoveDirt níe). Nakonec, pokud poèet pohyblivıch blokù pøekroèí
			procento zadané v promìnné "gmthreshold" , pak RestoreMotionBlocks
			jednoduše bere snímek z klipu "alternative". V tomto zpùsobu mohou bıt specificky
      zpracovány zmìny scén nebo globální pohyb. Klip "restore" je vıchozí hodnotou pro
			"alternative". Vıchozí hodnotou pro gmthreshold je 80, t.j. pokud
			80% blokù jsou pohyblivé bloky, pak je snímek brán z klipu
			"alternative". "mthreshold" je podobnı jako ve starém RemoveDirt. Nicménì
			protoe teï pouíváme obyèejnı SAD pro porovnání blokù, hodnoty by mìli bıt
			trochu vyšší, zvláštì kdy je nízká hodnota šumu. Vıchozí hodnotou pro
			"mthreshold" je 160. Pomocí promìnné "noise" je moné zadat úroveò šumu,
			která by mìla bıt ignorována detekcí pohybu. Vıchozí hodnotou "noise"
			je 0. Promìnná "noisy" je pouita pro zadání poètu šumovıch
			pixelù na blok 8x8 , co musí bıt pøekroèeno, aby to byl pohyblivı blok. Pokud
			noisy &gt;= 0 a noise &gt; 0, pak je hodnota "mthreshold" ignorována. Promìnné
			"pthreshold" a "cthreshold" jsou stejné jako ve starém RemoveDirt.
			Postprocessing (doplòkové zpracování) není v novém RemoveDirt zmìnìn. Vıchozí hodnata
			pro pthreshold je 10 a cthreshold ve vıchozím nastavení odvozuje hodnotu od pthreshold.
      Záporné hodnoty jsou povoleny pro pthreshold a cthreshold, ale nejsou moc
			rozumné. Promìnné "dist" a "tolerance" jsou stejné jako v
			starém pluginu RemoveDirt pokud je dmode=0, vıchozí. Vıchozí hodnotou dist
			je&nbsp;1 a vıchozí hodnotou pro tolerance je 12. Pokud grey=true (false je
			vıchozí), pak je barevnost v RestoreMotionBlocks ignorována. Logické
			promìnné "show" a "debug" jsou pouity pro ladìní (viz. kapitolu Ladìní).
		</p>
		<H2>Jak pracuje RestoreMotionBlocks</H2>
		<P>Aby promìnné vıše pracovali správnì, musí uivatel pochopit jak
			RestoreMotionBlocks pracuje. Sestává ze tøí fází. Pro první fázi je pouit jen
			klip "neighbour". Kadı snímek je rozdìlen na møíku
			o blocích s rozmìry 8x8 . Pokud je n èíslo aktuálního snímku, tak pro kadı
			blok této møíky se RestoreMotionBlocks&nbsp;dívá na jas (luma)
			tohoto bloku v sousedu (n-1) a sousedu (n+1). Všimnìte si, e nepouíváme
			snímek (n). Jsou tøi porovnávací metody (starı
			RemoveDirt má jen jednu). Pokud je noise= 0, tak je prostì vypoèteno SAD kadého bloku
			v sousedu (n-1) a sousedu (n+1). Pokud je to &gt;=
			mthreshold, blok je identifikován jako pohyblivı blok snímku n. To je nejrychlejší
			metoda a podobná metoda byla pouita ve starém RemoveDirt. Její klíèovou
			nevıhodou je, e se dá snadno zmılit šumem. Pokud je noise &gt;=0, tak
			místo SUM(|y-x|) RestoerMotionBlocks vypoèítá SUM(| |y-x|-noise |). V
			podstatì, rozdíly s absolutní hodnotou &lt;= noise jsou ignorovány. Pokud je to
			&gt;= mthreshold, tak je tento blok identifikován jako pohyblivı blok. Nazıváme to
			šumovì upravené SAD. Ze zpùsobu jak je šumovì upravené SAD vypoèítáno,
			je jasné, e "mthreshold" by mìla bıt sníena pokud je "noise"
			zvıšeno. Pokud noise &gt;= 0 a noisy &gt;= 0, pak
			RestoreMotionblocks spoèítá poèet pixelù bloku, pro kterı
			absolutní rozdíl mezi sousedem(n-1) a sousedem(n+1) je &gt;= noise.
			Pokud je toto èíslo &gt;= &nbsp;hodnotì "noisy", tak je blok
			identifikován jako pohyblivı blok. Nazıváme to NPC (= noisy pixel counting - poèítání šmovıch pixelù)
			metoda. Hodnota mthreshold je ignorována pokud je zvolena metoda NPC. Všimnìte si, e
			blok má 64 pixelù. Tedy pokud je noisy &gt; 64, tak tam nemohou bıt ádné pohyblivé
			bloky. Z mého pohledu je NPC jasnì nejlepší metoda. Má asi polovièní rychlost
			oproti SAD a asi stejnou rychlost jako NSAD.&nbsp; Noise=-1 a noisy=-1 jsou vıchozí
			hodnoty. Take SAD je vıchozí metodou pro první fázi. Provedl jsem
			vìtšinu svıch testù RemoveDirt s noise=8 nebo 10&nbsp;a noisy= 12. Jak se
			ukázalo pohyblivé bloky nalezené v první fázi se nazıvají pohyblivé bloky 1 fáze.
			Ve druhé fázi, jsou spoèítány všechny pohyblivé bloky nalezené v první fázi,
      které mají vzdálenost &lt;= dist. Pokud je vısledek &gt;= (tolerance /100) * (poèet všech blokù z první
      fáze se vzdáleností &lt;= dist), tak se tento blok nazıvá <i>motion neighbour (pohyblivı sousední)</i>
			blok. Napøíklad pokud je dist = 1 a tolerance= 12 (vıchozí hodnoty),
			tak je 9 blokù se vzdáleností &lt;= 1. Protoe 1 &lt; (12/100)*9 &lt;
			2, musí bıt aspoò 2 pohybové bloky fáze 1 mezi 9 sousedními bloky
			tak, e je blok oznaèenı jako pohyblivı sousední blok. Pokud dmode= 0,
			pak všechny pohyblivé sousední bloky se stávají fází 2 pohyblivıch blokù. Take pøi
			dmode=0 se poèet pohyblivıch blokù docela zvyšuje. Pøi dmode= 2 pak nastává
			opak: pohyblivı blok fáze 1 se stává pohyblivım blokem fáze 2 jen,
			kdy je také pohyblivım sousedním blokem. V podstatì,
			je ménì pohyblivıch blokù fáze 2 ne pohyblivıch blokù fáze 1. Napøíklad
			pokud je dist=1, tolerance= 2, dmode= 2, pak jeden pohyblivı blok fáze 1
			je zahozen, jestlie neexistují vzdálenìjší pohyblivé bloky fáze 1 se vzdáleností
			menší ne 1. Dmode=1 je právì uprostøed mezi dmode=0 a dmode= 2:
			pohyblivé sousední bloky se stávají pohybovımi bloky fáze 2. Tedy, pokud
			dmode=1, tak jsou pro detekci pohyblivıch sousedních blokù vıznamné jen pohyblivé bloky fáze 1.
			Po dokonèení této úlohy je informace o fázi 1 zahozena.
      Pokud je dist=0 nebo dmode=2, gmthreshold by mìla bıt sníena na 60 nebo dokonce 50.
			Tøetí fáze, zvaná postprocessingová fáze zaèíná
			restaurováním pohyblivıch blokù fáze 2, jejich kopírováním z klipu
			"restore" do klipu "filtered". Všechny pohyblivé bloky fáze 2 se stávají
			také pohyblivımi bloky fáze 3. Pak jsou provìøovány hranice mezi pohyblivımi
      a nepohyblivımi bloky. Za tímto úèelem je dvakrát vypoèítáno SAD dvou sousedních
      okrajovıch èárovıch segmentù (tyto èárové segmenty jsou buï horizontální nebo vertikální a jsou
			8 pixelù dlouhé). To je vypoèteno nejdøíve v klipu "restore" a pak v
			klipu "filtered". V klipu "filtered" jsou dva bloky ze dvou rùznıch zdrojù,
			jeden blok, pohyblivı blok byl obnoven z klipu
			"restore" a nepohyblivı blok je z pùvodního klipu
			"filtered". Protoe snímky klipu "restore" nejsou vùbec zmìnìny,
			oba bloky jsou ze stejného zdroje, mìli by tedy do sebe zapadnout. Pokud je
			SAD hranic v klipu "filtered" &gt; (SAD hranic v klipu restore) +
			pthreshold, pak je blok oznaèen jako novı (doplòkovı) pohyblivı blok fáze 3
			a blok je obnoven zkopírováním z "restore" do "filtered",
			protoe tyto dva bloky ve "filtered" k sobì dostateènì nezapadají
			ve srovnání se dvìma bloky v "restore". Jinımi slovy, v této fázi
			je kontrolováno zda obnovenı blok zapadá mezi zatím neobnovené bloky.
			Pokud tomu tak není, tak zatím neobnovené bloky, které dobøe nazapadají,
			jsou oznaèeny jako pohyblivé bloky fáze 3 a jsou také restaurovány. Tato
			procedura se opakuje dokud nejsou bloky, které by mohly bıt testovány.
			Pokud je hodnota promìnné grey rovna false, pak se to samé provádí pro jas i
			barevnost (chroma) (pro braevnost se pouije promìnná cthreshold místo
			pthreshold). Pokud je grey= true,  tak je proveden postprocessing jen pro jas.</P>
		<P>Nakonec, jestlie procento všech pohyblivıch blokù fáze 3 s ohledem na všechny
			bloky pøekroèí hodnotu gmthreshold, pak je snímek z "filtered" zahozen
			a nahrazen odpovídajícím snímkem v "alternative". Tímto zpùsobem
			mùeme vìnovat zvláštní zacházení ostrım zmìnám scén a scénám s
			pohybující se nebo pøibliující se kamerou.</P>
		<H2>Èernobílé klipy</H2>
		<P>Pokud je grey=true pak barevnost klipu "filtered" není dotèená funkcí
			RestoreMotionBlocks. Také postprocessing je pouit jen na jasovou komponentu. To
      je mírnì rychlejší ne grey=false. Pokud pouijete grey=false na èernobílé klipy, pak
			to nejen trvá déle, ale mùe to sníit kvalitu, protoe šum barevnosti mùe
			spustit chybnı postprocessing. Proto se velmi doporuèuje pouít "grey=true" pro
			èernobílé klipy.
		</P>
		<H2>Ladìní</H2>
		<P>Logické promìnné <i>debug</i> a <i>show</i> se pouívají pro ladní.
    Pokud je show=true, pak bloky, které jsou oznaèeny jako pohyblivé
			bloky v první fázi, jsou vybarveny èervenì, ty které jsou nalezeny ve druhé fázi jsou
			vybarveny zelenì a nakonec pohyblivé bloky oznaèené postprocessingem jsou
			vybarveny bíle. Takto se dá snadno zkontrolovat zda byly promìnné vhodnì nastaveny.
			Pøi debug=true pak RestoreMotionBlocks posílá vıstup následujícího typu do
      <A href="http://www.sysinternals.com/ntw2k/freeware/debugview.shtml" target="_blank">
				debugview</A> &nbsp;utility:</P>

				<PRE>[348] [21495] RemoveDirt: motion blocks =  942(14%), 1652(25%),  635( 9%), loops = 31
[348] [21496] RemoveDirt: motion blocks = 1745(26%), 2330(35%),   64( 0%), loops = 3
[348] [21497] RemoveDirt: motion blocks = 1480(22%), 1973(30%),   45( 0%), loops = 4
[348] [21498] RemoveDirt: motion blocks = 1081(16%), 1915(29%),   65( 1%), loops = 2
[348] [21499] RemoveDirt: motion blocks = 1403(21%), 2380(36%),  235( 3%), loops = 10
[348] [21500] RemoveDirt: motion blocks = 2618(40%), 2204(34%),   59( 0%), loops = 5
[348] [21501] RemoveDirt: motion blocks =  986(15%), 2065(31%),   75( 1%), loops = 3
[348] [21502] RemoveDirt: motion blocks = 1214(18%), 2291(35%),   78( 1%), loops = 3
[348] [21503] RemoveDirt: motion blocks = 1348(20%), 2179(33%),   57( 0%), loops = 4
[348] [21504] RemoveDirt: motion blocks =  961(14%), 1957(30%),   71( 1%), loops = 3
[348] [21505] RemoveDirt: motion blocks = 1833(28%), 2201(33%),   38( 0%), loops = 3
[348] [21506] RemoveDirt: motion blocks = 1644(25%), 2183(33%),   53( 0%), loops = 5
[348] [21507] RemoveDirt: motion blocks = 1420(21%), 2541(39%),  132( 2%), loops = 5
[348] [21508] RemoveDirt: motion blocks = 2238(34%), 2229(34%),  104( 1%), loops = 4
[348] [21509] RemoveDirt: motion blocks = 1351(20%), 2294(35%),  181( 2%), loops = 6
[348] [21510] RemoveDirt: motion blocks =  931(14%), 1800(27%),  229( 3%), loops = 5
</PRE>

		<P>První èíslo v hranatıch závorkách na levé stranì je id procesu,
			kterı spouští skript, druhé èíslo v hranatıch závorkách je èíslo snímku.
			První èíslo (s procenty v závorce) za "motion
			blocks ="&nbsp;&nbsp;je poèet pohyblivıch blokù fáze 1, druhé je
			rozdíl mezi pohyblivımi bloky fáze 2 a fáze 1 (vdy &gt;=0 pokud je dmode=0,
			vdy &lt;= 0 pokud je dmode= 2) a tøetí je rozdíl mezi pohyblivımi bloky fáze
			3 a fáze 2 (vdy &gt;= 0). Nakonec, èíslo za "loops
			=" je poèet opakování postprocessingu pouitıch pro tento snímek. Debug=true mùe bıt
			pouito pro monitorování RestoreMotionBlocks pøi enkódovacím procesu. Samozøejmì
			show=true mùe bıt pouito jen pøed enkódovacím procesem k nalezení správnıch hodnot
			pro rùzné promìnné.
		</P>
		<H2>SCSelect</H2>
		<P>SCSelect je speciální filtr, kterı rozlišuje zaèátky scén, konce scén
			a globální pohyb. Vıstup z SCClense je pouit jako
			klip "alternative" pro RestoreMotionBlocks. Tìko mùe bıt pouit pro
			jiné úèely, protoe jen vytváøí správná rozhodnutí, jestli je tam hodnì
			pohyblivıch blokù. Jen kdy je procento pohyblivıch blokù &gt; gmthreshold,
			tak RestoreMotionBlocks volí snímek z klipu zadaného promìnnou
			alternative a pak tam je vdy hodnì pohyblivıch blokù, pokud
			gmthreshold není pøíliš malı (gmthreshold &gt;= 30 by mìlo bıt dostateènì velké).
			SCSelect vysílá nesmyslné vısledky, kdy je tam jen trocha pohybovıch blokù.
			SCSelect je pouito následovnì:</P>
		<center><code>SCSelect</code> <var>(clip input, clip scene_begin, clip scene_end, clip global_motion,
			float dfactor, bool debug, bool planar)</center></var>
		<p>První ètyøí klipové promìnné jsou povinné a nemají ádná jména. Všechny ètyøi klipy
			musí mít stejné barevné prostøedí, šíøku a vıšku. První je klip,
			na kterém SCSelect zaloí své rozhodování. Obvykle by to mìl bıt stejnı klip, kterı
			byl  zadán promìnnou "neighbour" v RestoreMotionBlocks. Pokud si SCSelect
			všimne zaèátku scény, vybere její vıstupní snímek z klipu
			scene_begin. Pokud si SCSelect všimne konce scény, vybere její
			vıstupní snímek z klipu scene_end. Pokd si SCSelect všimne globálního
			pohybu, vybere jeho vıstupní snímek z klipu global_motion. Tedy
			SCSelect nevytváøí ádné nové snímky. Provádí pouze vıbìr z rùznıch zdrojù.
			Dfactor je klíèová promìnná pro citlivost na zmìnu scény.
			Èím vyšší dfactor, tím ménì snímkù bude detekováno se zaèátky a konci scén a tím více snímkù
      s globálním	pohybem. Dfactor=4.0 je vıchozí hodnota. SCSelect pracuje
			s YV12 a planárním YUY2. Pokud je pouito planární YUY2 , pak musí bıt zadáno planar=true.
			Pøi debug=true SCSelect posílá vıstup následujícího typu do
			<A href="http://www.sysinternals.com/ntw2k/freeware/debugview.shtml" target="_blank">
				debugview</A> &nbsp;utility:
		</p>
		<PRE>[3416] [67865] SCSelect: global motion
[3416] [67866] SCSelect: global motion
[3416] [67870] SCSelect: global motion
[3416] [67871] SCSelect: global motion
[3416] [67873] SCSelect: global motion
[3416] [67874] SCSelect: global motion
[3416] [67877] SCSelect: global motion
[3416] [68318] SCSelect: global motion
[3416] [68319] SCSelect: global motion
[3416] [68557] SCSelect: scene end
[3416] [68558] SCSelect: scene begin
[3416] [69481] SCSelect: scene end
[3416] [69482] SCSelect: scene begin
[3416] [70240] SCSelect: scene end
[3416] [70241] SCSelect: scene begin
[3416] [70406] SCSelect: global motion
[3416] [70407] SCSelect: global motion
[3416] [70408] SCSelect: global motion
[3416] [70409] SCSelect: global motion
[3416] [70410] SCSelect: global motion
[3416] [72032] SCSelect: global motion
[3416] [72164] SCSelect: global motion
[3416] [72165] SCSelect: global motion
</PRE>

		<P>Pro popis základní myšlenky za SCSelect øeknìme, e SAD(n)&nbsp; je rozdíl SAD
			mezi snímky input(n) a input(n+1). Nyní, pokud SAD(n) &gt;
			dfactor * SAD(n-1), tak SCSelect rozpozná konec scény a vytáhne snímek
			z klipu scene_end. Pokud je SAD(n-1) &gt; dfactor * SAD(n), tak SCSelect
			rozpozná zaèátek scény a vytáhne snímek z klipu scene_begin. Pokud jak
			SAD(n)&nbsp;&lt;= dfactor * SAD(n-1) tak i SAD(n-1) &lt;= dfactor * SAD(n), tak
			SCSelect rozpozná globální pohyb a vytáhne snímek z klipu
			global_motion. Z tohoto popisu je jasné, e dfactor musí bıt &gt; 1
			pro získání rozumnıch vısledkù. Algoritmus vıše je optimalizován tak, e
			èasto je poèítáno jen jedno SAD a ne dvì pro jeden poadovanı snímek.
			Nicménì, existují urèité nedostatky. Pokud scéna konèí s globálním pohybem,
			pak SCSelect èasto neumí detekovat konec scény. Pokud scéna zaèíná s
			globální pohybem, pak SCSelect èasto neumí detekovat zaèátek scény. Tyto dva
			efekty jsou obvykle odpovìdné za to, e jsou v SCSelect detekovány jako zaèátky a konce
      scén osamìlé snímky, jinak kadému zaèátku scény mìl pøedcházet konec scény.
      Zjemnìním algoritmu vıše bychom se mohli vyhnout samostatnım zaèátkùm scén
			a koncùm scén, ale existuje jedna situace, kde dokonce i také zjemnìní selhává.
			Jmenovitì kdy jsou konce scén s globálním pohybem a nová scéna zaèíná s
			globálním pohybem. Pak mùe bıt ostrá zmìna scény spolehlivì detekována jen s
			dobrou analızou pohybu, co by vedlo k extrémnímu zpomalení filtru.
		</P>
		<H2>RemoveDirt</H2>
		<P>RemoveDirt se nyní stal AVS skriptovou funkcí, která zahrnuje
			RestoreMotionBlocks a rùzné filtry z mého balíku <A href="http://www.RemoveGrain.de.tf">
				RemoveGrain</A> (je nutná verze 0.9 nebo vyšší). Bìhem testù
			jsem pouíval následující skript:</P>
		<PRE>function RemoveDirt(clip input, bool "_grey", int "repmode")
{
    _grey=default(_grey, false)
	repmode=default(repmode, 16)
	clmode=17
	clensed=Clense(input, grey=_grey, cache=4)
	sbegin = ForwardClense(input, grey=_grey, cache=-1)
	send = BackwardClense(input, grey=_grey, cache=-1)
	alt=Repair(SCSelect(input, sbegin, send, clensed, debug=true), input, mode=repmode, modeU = _grey ? -1 : repmode )
	restore=Repair(clensed, input, mode=repmode, modeU = _grey ? -1 : repmode)
	corrected=RestoreMotionBlocks(clensed, restore, neighbour=input, alternative=alt, gmthreshold=70, dist=1, dmode=2, debug=false, noise=10, noisy=12, grey=_grey)
	return RemoveGrain(corrected, mode=clmode, modeU = _grey ? -1 : clmode )
}	</PRE>

		<P>Proberme si tento skript podrobnìji. Nejdøíve pouijeme brutální èasovı (temporal)
			vyhlazovaè z balíku RemoveGrain pro získání klipu "clensed". Pak pouijeme
			filtry ForwardClense a BackwardClense z RemoveGrain pro vytvoøení
			klipu "alt", kterı je pak pouit jako promìnná "alternative" v následném
			RestoreMotionBlocks. Zatímco Clense provádí hodnì èistìní, urèitì vytváøí
			hodnì artefaktù v oblastech pohybu. Ve skriptové funkci RemoveDust,
			je klip "clensed" zcela opraven filtrem Repair z balíku
			RemoveGrain. V RemoveDirt je tato oprava provedena jen v oblastech pohybu.
			Statické oblasti <b>nejsou</b> opravované. Protoe klip je
			pouit jen pro obnovení pohyblivıch oblastí, mùeme pouít mnohem silnìjší reim opravy Repair
			mode&nbsp;16 (v RemoveDust jsou obvykle pouity reimy 2 nebo 5), co obnoví tenké èáry
			znièené v clense. Nakonec, protoe tam mùe zùstat nìco z
			èasového odšumìní, zvláštì, kdy je zrnìní (grain) husté, pouijeme prostorovı
			odšumovaè RemoveGrain(mode=17) pro odstranìní tìchto neèistot nebo zbytkù šumu.
		</P>
		<H2>Optimalální pouití</H2>
		<P>1. <b>Pokud je to moné, oøezávejte po RestoreMotionBlocks.</b> Moderní
			kodeky dìlí snímky stejnım zpùsobem jako RemoveDirt do møíky s bloky 8x8 pixelù
			pro vykonání rozhodující <i>diskétní kosinové transformace</i> pro takové bloky.
			Nyní, jestli je klip oøíznut po RemoveDirt, tak møíka
			RemoveDirt a kodeku se asi liší co vede  k niší kompresi.
			Existuje ale jedna vıjimka: pozdìjší oøíznutí neškodí, kdy
			všechny ètyøi strany jsou oøíznuty násobkem 8. Napøíklad,
			crop(8,64,0,-72) je ok. Na druhé stranì, by se mìlo oøezávat po
			RemoveGrain/Repair pokud je to moné, protoe tyto filtry nemohou zpracovat
			hranièní pixely. Tedy optimálním øešením je oøezávat pozdìji a to jen o
			násobky èísla 8, co bohuel není vdy moné.
		</P>
		<P>2. <b>Oøezávejte jen s "align=true"</b>. RestoreMotionBlocks silnì vyuívá
			SSE/SSE2 instrukce. Pokud oøezáváte bez "align= true" pøed
			RestoreMotionBlocks, tak data ve snímcích nemusí bıt správnì zarovnána
			a RemoveDirt bude pracovat podstatnì pomaleji. To je obzvláš
			dùleité pro SSE2 verzi. V dùsledku mùete vdy oøezávat v
			Avisynthu a ne v DVD2AVI nebo DGIndexu.</P>
		<P>3. <b>Videa zpracovaná pomocí telecine musí bıt zpracována pomocí inverzního telecine pøed RemoveDirt</b>.
			Pokud je film zpracovanı pomocí telecine, jsou nìkterá pole duplikována aby se zvıšila
			frekvence snímkù z 24fps na 30fps. Proto v takovıch duplikovanıch polích základní vlastnost
			neèistoty, popsaná vıše u neplatí a ádnı èasovı vyhlazovaè si nemùe všimnout
			neèistot v takovıch duplikovanıch polích. Na druhou stranu, po inverzním telecine je
			obvykle kadı ètvrtı snímek sloenı z polí, která pochází ze dvou
			rùznıch snímkù. Vizuálnì tyto dvì pole zapadají do sebe dobøe, ale obì jsou
			z rùzného <i>kompresního kontextu, </i> co mùe zmılit
			RemoveDirt ke špatné detekci pohybu. V extrémních pøípadech, mùe bıt jedno pole z
			I- nebo P-snímku, zatímco další je z B-snímku. Ale dokonce jsou pole
			ze snímkù stejnıch typù, rùznı kompresní kontext
			má vıznamnı efekt. Proto RemoveDirt nepracuje tak dobøe
			na videích zpracovanıch inverzním telecine, jako v nativních progresivních videích.
			Ze stejného dùvodu je také komprese videí zpracovanıch inverzním telecine horší ne
			u nativních progresivních videí. My evropané bychom mìli kadı den dìkovat bohu
			za to, e nemáme telecine materiály. Nicménì, zde v Nìmecku máme digitální TV vysílání,
			které rádi tøepí progresivní filmy (kolem 5% všech progresivních
			filmù z ARD a zvláštì ZDF je roztøepenıch). Naštìstí tito idioti nejsou schopni
			duplikovat pole, take RemoveDirt by mìl pracovat, ale v roztøepenıch filmech
			je neèistota vdy rozdìlena do dvou snímkù, které zøejmì bolí RemoveDirt. Na druhou stranu,
			pokud jsou tyto roztøepené filmy zbaveny roztøepení, tak máme problém kompresního kontextu
			pro <i>kadı </i>snímek<i> </i>a ne jen pro kadı ètvrtı snímek.
			Krokováním ve videu s vestavìnım filtrem <i>Bob</i>()<i>&nbsp;</i> lze
			rozhodnout s témìø absolutní jistotou, zda je video opravdu
			progresivní, prokládané, zpracované pomocí telecine, se smíchanımi poli nebo progresivní s posunutımi poli.
		</P>
		<P>4. <b>Vlote další filty za RemoveDirt.</b> Kromì tìch filtrù zmínìnıch døíve,
			jako crop a inverse telecine, by mìli bıt všechny ostatní filtry
			vloeny za RemoveDirt v Avisynth skriptu, protoe vìtšina filtrù má
			spíše negativní ne pozitivní dopad na detekci neèistot.</P>
<p><kbd>$English Date: 2005/05/07 $</kbd></p>
<p><kbd>Èeskı pøeklad:29.4.2009</kbd></p>
	</body>
</html>
