<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1250">

<title>MaskTools v2</title>
<link rel="stylesheet" type="text/css" href="../../avisynth.css"><!--
Automatically generated, don't change:
$Id: masktools2.htm,v 1.1 2010/02/27 14:50:14 wilbertd Exp $
--></head><body>
<h1>MaskTools v2</h1>
<h2>Pøehled</h2>
<b>Autoøi : </b>Kurosu, Manao, mg262<br>
<b>Verze : </b>2.0 alfa 36<br>
<b>Stáhnout : </b><a href="http://manao4.free.fr/">http://manao4.free.fr/</a>,
<a href="http://www.avisynth.org/warpenterprises/">http://www.avisynth.org/warpenterprises/</a><br>
<b>Kategorie : </b>Rùzné pluginy<br>
<b>Poadavky : </b>YV12 barevné prostøedí
<hr>
<h2>Obsah</h2>
<ul>
<li><a href="#masktools">Úvod</a></li>
<li><a href="#common_parameters">Bìné parametry</a></li>
<li><a href="#filters_list">Seznam filtrù</a></li>
<li><a href="#filters_description">Popis filrtù</a></li>
<li><a href="#reverse_polish_notation">Obrácenı polskı zápis (Reverse polish notation)</a></li>
<li><a href="#changelog">Seznam zmìn</a></li>
</ul>

<h2><a name="masktools"></a>I) Úvod</h2>

<p>Soubor mt_masktools.dll obsahuje sadu filtrù navrenıch pro vytvoøení masek, manipulaci a pouití masek. Masky jsou ve
zpracování videa cestou jak dát relativní vıznam kadému pixelu. Mùete napøíklad vytvoøit
masku, která vybírá jen zelené èásti videa, a pak nahradí tyto èásti
jinım videem.</p>
<p>
Aby byla co nejvìtší kontrola nad zacházením s maskami, budou filtry vyuívat fakt, e kadá
jasová (luma) a barevnostní (chroma) plocha mùe bıt bez vzájemného vztahu (uncorrelated). To znamená, e jedno video bude vdy
povaováno filtry za 3 nezávislé plochy. To platí také pro masky, co znamená
e maskovanı klip bude ve skuteènosti obsahovat 3 masky, jednu pro kadou plochu.</p>

<p>Filtry mají sadu bìnıch parametrù, které se tıkají hlavnì toho jaké zpracování dìlat na
kadé ploše. Všechny pracují jen v YV12 ( pøestoe v Avisynthu 2.6 bude k dispozici podpora
všech planárních formátù ).</p>

<h2><a name="common_parameters"></a>II) Bìné parametry</h2>

Jak bylo øeèeno døíve, všechny filtry - kromì pomocnıch (helpers) - sdílí sadu bìnıch parametrù. Tyto parametry jsou pouity
proto, aby se øeklo jaké zpracování provést na kadé ploše / kanálu, a jakou oblast videa zpracovat.

<ul>
<li><var>int "offx" (0), int "offy" (0)</var><br><br>

<var>"offx"</var> a <var>"offy"</var> jsou horní levé souøadnice obdélníku, kde by mìlo nastat skuteèné zpracování.
Cokoli mimo obdélník bude odpadem.<br>
</li>

<li><var>int "w" (-1), int "h" (-1)</var><br><br>

<var>w</var> a <var>h</var> jsou šíøkou a vıškou zpracovávaného obdélníku. -1 znamená, e obdélník se rozšíøí do
spodního pravého rohu videa. To také znamená, e vıchozí nastavení jsou zamıšlena ke zpracování
celého obrazu.<br>
</li>

<li><var>int "y" (3), int "u" (1), int "v" (1)</var><br><br>

Tyto tøi hodnoty popisují aktuální reim zpracování, kterı má bıt pouit na kadou plochu / kanál.
Zde je, jak jsou reimy kódovány :
<ul>
<li>x=-255..0 : všechny pixely plochy budou nastaveny na -x.</li>
<li>x=1 : plocha nebude zpracována. To znamená, e obsah plochy po filtru je èistı nesmysl (odpad).</li>
<li>x=2 : plocha prvního vstupního klipu bude zkopírována.</li>
<li>x=3 : plocha bude zpracována filtrem kterı je zadán.</li>
<li>x=4 (pokud je pouitelnı) : plocha druhého klipu bude zkopírována.</li>
<li>x=5 (pokud je pouitelnı) : plocha tøetího klipu bude zkopírována.</li>
</ul>
Jak vidíte, vıchozí parametry jsou voleny jen pro zpracování jasu (luma), a ne pro práci s barevností (chroma). Je to
proto, e vìtšina zpracování videa se pøi práci s 4:2:0 nedotıká barevnosti.<br>
</li>
<li><var>string "chroma" ("")</var><br><br>

Kdy je zadán, hodnota obsaená v tomto øetìzci pøepíše reimy zpracování <var>u</var> &amp; <var>v</var> . To je pìknı
doplnìk navrenı mg262, kterı dìlá filtr pøátelštìjší k uivateli. Dovolené hodnoty pro <var>chroma</var> jsou :
<ul>
<li>"process" : nastaví <var>u</var> = <var>v</var> = 3.</li>
<li>"copy" nebo "copy first" : nastaví <var>u</var> = <var>v</var> = 2.</li>
<li>"copy second" : nastaví <var>u</var> = <var>v</var> = 4.</li>
<li>"copy third" : nastaví <var>u</var> = <var>v</var> = 5.</li>
<li>"xxx", kde xxx je èíslo : nastaví <var>u</var> = <var>v</var> = -xxx.</li>
</ul>
</li>
</ul>
<h2><a name="filters_list"></a>III) Seznam filtrù</h2>
Zde je vyèerpávající seznam filtrù obsaenıch v této dll :
<ul>
<li><b>Tvorba masek : </b><ul>
<li><a href="#mt_edge">mt_edge :</a> vytváøí masky hran (obrysù).</li>
<li><a href="#mt_motion">mt_motion :</a> vytváøí masky pohybu.</li>
</ul></li>
<li><b>Operace s maskami : </b><ul>
<li><a href="#mt_invert">mt_invert :</a> invertuje (obrací) masky.</li>
<li><a href="#mt_binarize">mt_binarize :</a> transformuje mìkké masky na tvrdé masky.</li>
<li><a href="#mt_logic">mt_logic :</a> kombinuje masky pouitím logickıch operátorù.</li>
<li><a href="#mt_hysteresis">mt_hysteresis :</a> kombinuje masky  tak, e první prorùstá do druhé.</li>
</ul></li>
<li><b>Sluèování masek : </b><ul>
<li><a href="#mt_merge">mt_merge :</a> sluèuje dva klipy v souladu s maskou.</li>
</ul></li>
<li><b>Morphologickı operátor : </b><ul>
<li><a href="#mt_expand_mt_inpand">mt_expand :</a> rozšiøuje (expands) masku / video.</li>
<li><a href="#mt_expand_mt_inpand">mt_inpand :</a> smršuje (inpands) masku / video.</li>
<li><a href="#mt_inflate_mt_deflate">mt_inflate :</a> nafukuje (inflates) masku / video.</li>
<li><a href="#mt_inflate_mt_deflate">mt_deflate :</a> vyfukuje (deflates) masku / video.</li>
</ul></li>
<li><b>Lut operátor : </b><ul>
<li><a href="#mt_lut">mt_lut :</a> aplikuje vıraz na všechny pixely masky / videa.</li>
<li><a href="#mt_lutxy">mt_lutxy :</a> aplikuje vıraz na všechny pixely dvou masek / videí.</li>
<li><a href="#mt_lutxyz">mt_lutxyz :</a> aplikuje vıraz na všechny pixely tøí masek / videí.</li>
<li><a href="#mt_lutf">mt_lutf :</a> vytváøí jednolitı obraz z kolekce vıpoètu na pixelech dvou klipù.</li>
<li><a href="#mt_luts">mt_luts :</a> aplikuje vıraz zahrnutím sousedních pixelù.</li>
<li><a href="#mt_lutsx">mt_lutsx :</a> aplikuje vıraz zahrnutím sousedních pixelù jinım zpùsobem.</li>
<li><a href="#mt_lutspa">mt_lutspa :</a> poèítá hodnotu pixelu v souladu s jeho prostorovou pozicí.</li>
</ul></li>
<li><b>Operátor podpory : </b><ul>
<li><a href="#mt_makediff">mt_makediff :</a> odeèítá dva klipy.</li>
<li><a href="#mt_adddiff">mt_adddiff :</a> pøidává zpìt rozdíl dvou klipù.</li>
<li><a href="#mt_clamp">mt_clamp :</a> sevøe (oøízne) klip mezi dva jiné klipy.</li>
<li><a href="#mt_average">mt_average :</a> zprùmìruje dva klipy.</li>
</ul></li>
<li><b>Konvoluce : </b><ul>
<li><a href="#mt_convolution">mt_convolution :</a> aplikuje oddìlitelnou konvoluci na obraz.</li>
<li><a href="#mt_mappedblur">mt_mappedblur :</a> aplikuje speciální 3x3 konvoluci na obraz.</li>
</ul></li>
<li><b>Pomocníci : </b><ul>
<li><a href="#mt_square_mt_circle_mt_diamond">mt_square :</a> vytváøí øetìzec popisující ètverec.</li>
<li><a href="#mt_rectangle_mt_ellipse_mt_losange">mt_rectange :</a> vytváøí øetìzec popisující obdélník.</li>
<li><a href="#mt_freerectangle_mt_freeellipse_mt_freelosange">mt_freerectangle :</a> vytváøí øetìzec popisující obdélník.</li>
<li><a href="#mt_square_mt_circle_mt_diamond">mt_diamond :</a> vytváøí øetìzec popisující diamant.</li>
<li><a href="#mt_rectangle_mt_ellipse_mt_losange">mt_losange :</a> vytváøí øetìzec popisující kosoètverec.</li>
<li><a href="#mt_freerectangle_mt_freeellipse_mt_freelosange">mt_freelosange :</a> vytváøí øetìzec popisující kosoètverec.</li>
<li><a href="#mt_square_mt_circle_mt_diamond">mt_circle :</a> vytváøí øetìzec popisující krunici.</li>
<li><a href="#mt_rectangle_mt_ellipse_mt_losange">mt_ellipse :</a> vytváøí øetìzec popisující elipsu.</li>
<li><a href="#mt_freerectangle_mt_freeellipse_mt_freelosange">mt_freeellipse :</a> vytváøí øetìzec popisující elipsu.</li>
<li><a href="#mt_polish">mt_polish :</a> vytváøí obrácenı polskı vıraz (expresion) z infix.</li>
</ul></li>
</ul>
<h2><a name="filters_description"></a>IV) Popis filtrù</h2>
<h3><a name="mt_edge"></a>mt_edge</h3>
<p>
<code>mt_edge</code> : <var>string mode("sobel"), int thY1(10), int thY2(10), int thC1(10), int thC2(10)</var>
</p>
<p>
</p><ul>
<li><var>mode</var> volí 3x3 convoluèní jádro pouité pro vıpoèet masky. Jsou tøi pøeddefinovaná jádra,
"sobel", "roberts" a "laplace", a mùete zadat také 3x3 uivatelské jádro. "sobel" pouívá
jádro "0 -1 0 -1 0 1 0 1 0", "roberts": "0 0 0 0 2 -1 0 -1 0" a "laplace": "1 1 1 1 -8 1 1 1 1".
Normalizaèní souèinitel jádra je automaticky vypoèten a nahrazen nejbliší mocninou 2,
pro umonìní rychlejšího zpracování. Mùete zadat váš vlastní normalizaèní faktor, jeho pøidáním do seznamu
koeficientù ( napøíklad "1 1 1 1 -8 1 1 1 1 8" ).</li>
<li><var>thX1</var> je nízká prahová hodnota a <var>thX2</var> je vysoká prahová hodnota. Pod <var>thX1</var>, je pixel nastaven na nulu, nad <var>thX2</var>,
na 255, a kdy je mezi zùstane nedotèenı.</li>
<li>Pozdìji byly uvedeny tøi nová jádra : "prewitt", "cartoon" a "min/max". "prewitt" je robustnìjší
jádro, zatímco "cartoon" se chová jako "roberts", ale zahrnuje jen záporné hrany.
Nakonec, "min/max" poèítá lokální kontrast ( local max - local min ).</li>
</ul>
<p></p>
<h3><a name="mt_motion"></a>mt_motion</h3>
<p><code>mt_motion</code> : <var>int thY1(10), int thY2(10), int thC1(10), int thC2(10), int thT(10)</var></p>
<p></p><ul>
<li><var>thT</var> rozhoduje zda je snímek zmìnou scény nebo ne. Maska je prázdná, pokud
je detekována zmìna scény, jinak je maska vypoèítána.</li>
<li><var>thX1</var>, <var>thX2</var> pracují jako u mt_edge.</li>
</ul><p></p>
<h3><a name="mt_expand_mt_inpand"></a>mt_expand, mt_inpand</h3>
<p><code>mt_xxpand</code> : <var>int thY(255), int thC(255), string mode("square")</var></p>
<p></p><ul>
<li>Nahrazuje pixel lokálním maximem/minimem.</li>
<li><var>thX</var> umoòuje omezit maximální zmìnu.</li>
<li><var>mode</var> vybírá lokální okolí. Mùe brát hodnoty :<ul>
<li><b>"square"</b> : 3x3 ètvercové okolí - isse optimalizace.</li>
<li><b>"horizontal"</b> : 3x1 horizontální okolí.</li>
<li><b>"vertical"</b> : 1x3 horizontální okolí.</li>
<li><b>"both"</b> : 3-délky napøíè ( "horizontální" + "vertikální" ) okolí.</li>
<li>uivatelskı reim, kde udáváte seznam souøadnic. "0 0 -1 0 1 0" je napøíklad
ekvivalentní k "horizontal".</li>
</ul>
</li></ul><p></p>
<h3><a name="mt_inflate_mt_deflate"></a>mt_inflate, mt_deflate</h3>
<p><code>mt_xxflate</code> : <var>int thY(255), int thC(255)</var></p>
<p>
</p><ul><li>Vypoète lokální prùmìr zahrnutím jen tìch sousedù, jejich hodnota je vyšší/niší ne hodnota pixelu.</li></ul>
<p></p>
<h3><a name="mt_merge"></a>mt_merge</h3>
<p><code>mt_merge</code> : <var>clip clip1, clip clip2, clip mask, bool "luma"(false)</var></p>
<p>
</p><ul>
<li>Je to páteøí konstrukce (framework). Sluèuje klipy v souladu s maskou. Èím vìtší je hodnota masky,
tím více se bude brát druhı klip ( aktuální formule je y = ((256 - m) * x1 + m * x2 + 128) / 256 )</li>
<li><var>luma</var> je speciální reim, kde je ke zpracování všech tøí kanálù pouita jen jasová plocha masky.</li>
<li><var>u</var> a <var>v</var> jsou nastaveny na vıchozí 2 (tak vıslednı klip obsahuje barevnost klipu clip1, a vypadá správnì).</li>
</ul><p></p>
<h3><a name="mt_lut"></a>mt_lut</h3>
<p><code>mt_lut</code> : <var>string expr("x"), string yexpr("x"), string uexpr("x"), string vexpr("x")</var></p>
<p></p><ul>
<li>Aplikuje funkci definovanou parametrem expr na všechny pixely. Funkce je napsána v obráceném polském zápisu (reverse polish notation).</li>
<li>Pokud <var>yexpr</var>, <var>uexpr</var> nebo <var>vexpr</var> není definován, pouije se místo nìj <var>expr</var> .</li>
</ul><p></p>
<h3><a name="mt_lutxy"></a>mt_lutxy</h3>
<p><code>mt_lutxy</code> : <var>clip clip1, clip clip2, string expr("x"), string yexpr("x"), string uexpr("x"), string vexpr("x")</var></p>
<p></p><ul>
<li>Aplikuje dvouparametrovou funkci definovanou parametrem expr na všechny pixely. Funkce je napsána v obráceném polském zápisu.</li>
<li>Pokud <var>yexpr</var>, <var>uexpr</var> nebo <var>vexpr</var> není definován, pouije se místo nìj <var>expr</var> .</li>
</ul><p></p>
<h3><a name="mt_lutxyz"></a>mt_lutxyz</h3>
<p><code>mt_lutxyz</code> : <var>clip clip1, clip clip2, clip clip3, string expr("x"), string yexpr("x"), string uexpr("x"), string vexpr("x")</var></p>
<p><ul>
<li>Aplikuje tøíparametrovou funkci definovanou parametrem expr na všechny pixely. Funkce je napsána v obráceném polském zápisu.</li>
<li>Pokud <var>yexpr</var>, <var>uexpr</var> nebo <var>vexpr</var> není definován, pouije se místo nìj <var>expr</var> .</li>
</ul></p>
<h3><a name="mt_lutf"></a>mt_lutf</h3>
<p><code>mt_lutf</code> : <var>clip clip1, clip clip2, string mode("avg"), string expr("y"), string yexpr("y", string uexpr("y"), string vexpr("y")</var></p>
<p></p><ul>
<li>Vypoèítá hodnotu shromádìním hodnot pixelù klipu <var>clip1</var>, v souladu s <var>mode</var>. Pak pouije funkci
definovanou vırazy na všechny pixely klipu <var>clip2</var> ( které jsou mapovány do promìnné y , zatímco je x shromádìnou hodnotou ).</li>
<li><var>mode</var> mùe bıt :<ul>
<li><b>"avg"</b> nebo <b>"average"</b> : poèítá prùmìr hodnot.</li>
<li><b>"std"</b> nebo <b>"standard deviation"</b> : poèítá standardní odchylku hodnot.</li>
<li><b>"min"</b> : poèítá minimum z hodnot.</li>
<li><b>"max"</b> : poèítá maximum z hodnot.</li>
<li><b>"range"</b> : poèítá "max" - "min".</li>
<li><b>"med"</b> nebo <b>"median"</b> : poèítá støed (median) z hodnot.</li>
</ul></li>
<li>Moné pouití je pro umonìní zvıšení dynamické adaptivity : <code>mt_lutf(c, c, mode = "range", expr = "y 128 - 256 * range / 128 +")</code></li>
</ul><p></p>
<h3><a name="mt_luts"></a>mt_luts</h3>
<p><code>mt_luts</code> : <var>clip clip1, clip clip2, string
mode("avg"), string pixels(""), string expr("x"), string yexpr("x"),
string uexpr("x"), string vexpr("x")</var></p>
<p></p><ul>
<li>Poèítá operaci <var>mode</var> na vısledku funkce definované parametrem <var>expr</var>, kde x je pixel z <var>clip1</var>, a y
je pixel z okolí v klipu <var>clip2</var>, definované parametrem <var>pixels</var>.</li>
<li><var>mode</var> mùe brát stejné hodnoty jako pro <code>mt_lutf</code>.</li>
<li><var>pixels</var> je seznam souøadnic, relativních k aktuálním pixelùm. Mùe bıt vytvoøen jednou z forem pomocníkù (helpers).</li>
<li>Podívejme se na nìkterá pouití :<ul>
<li><code>mt_luts( c, c, mode = "avg", pixels = mt_square( 1 ), expr = "y" )</code> provádí konvoluci s
3x3 jádrem.</li>
<li><code>mt_luts( c, c, mode = "min", pixels = mt_square( 1 ), expr = "y" )</code> provádí smrštìní (inpand).</li>
<li><code>mt_luts( c, c, mode = "range", pixels = mt_square( 1 ), expr = "y" )</code> provádí <code>mt_edge( mode = "min/max" )</code>.</li>
<li><code>mt_luts( c, c, mode = "std", pixels = mt_square( 1 ), expr = "y" )</code> dává lokální standardní odchylku klipu.</li>
<li><code>mt_luts( c, c, mode = "max", pixels = mt_square( 1 ), expr = "x y - abs" )</code> dává
maximální rozdíl mezi okolními pixely a støedovım.</li>
<li><code>mt_luts( c, c, mode = "med", pixels = mt_square( 1 ), expr = "y" )</code> dává støed (median) pixelù
okolí.</li>
</ul></li>
</ul><p></p>
<h3><a name="mt_lutsx"></a>mt_lutsx</h3>
<p><code>mt_lutsx</code> : <var>clip clip, clip clip1, clip clip2, string mode("avg"), string mode2("none"), string pixels(""), string expr("x"), string yexpr("x"), string uexpr("x"), string vexpr("x")</var></p>
<p><ul>
<li>Poèítá <var>mode</var> na sousedních pixelech v clip1, a <var>mode2</var>  na sousedních pixelech v clip2,
pak pouije funkci definovanou parametrem <var>expr</var> s y = <var>mode</var> a z = <var>mode2</var>.</li>
<li><var>mode</var> a <var>mode2</var> mohou brát stejné hodnoty jako pro <code>mt_lutf</code>.</li>
<li><var>pixels</var> pracuje jako v <code>mt_luts</code>.</li>
<li>Podívejme se na nìjaké pøíklady :<ul>
<li><code>mt_lutsx( c, c, c, mode = "min", mode2 = "max", pixels = mt_square( 1 ), expr = "z y -" )</code> poèítá lokální max - min hodnotu.</li>
<li><code>mt_lutsx( c, c, c, mode = "min", mode2 = "max", pixels = mt_square( 1 ), expr = "x y - 256 * z y - /" )</code> mìní lokální jasnost a konstrast tak, e lokální minimum je èerné a lokální maximum je bílé.</li>
</ul></li>
</ul></p>
<h3><a name="mt_lutspa"></a>mt_lutspa</h3>
<p><code>mt_lutspa</code> : <var>clip clip, bool("relative"), string expr("x"), string yexpr("x"), string uexpr("x"), string vexpr("x")</var></p>
<p><ul>
<li>Poèítá hodnotu kadého pixelu v souladu s jeho souøadnicemi a danou lut. Promìnné x a y v lut odpovídají
pøíslušnım souøadnicím pixelu. <var>relative</var>, je vıchozí true, indikuje zda
x & y by mìly bıt absolutní (x v rozsahu 0 a šíøka klipu, y od 0 a do vıšky klipu), nebo relativní (x & y v rozsahu
od 0 do 1). Klip je pouit jako šablona (pro vıpoèet snímku, šíøky, vıšky a barevného prostøedí).</li>
<li>Podívejme se na nìjaké pøíklady :<ul>
<li><code>mt_lutspa( c, relative = true, "x y + 256 * 2 /", chroma = "128" )</code> vytváøí diagonální gradient.</li>
</ul></li>
</ul></p>
<h3><a name="mt_average"></a>mt_average</h3>
<p><code>mt_average</code> : <var>clip clip1, clip clip2</var></p>
<p></p><ul><li>Ekvivalent k <code>mt_lutxy("x y + 2 /")</code>, ale rychlejší.</li></ul><p></p>
<h3><a name="mt_makediff"></a>mt_makediff</h3>
<p><code>mt_makediff</code> : <var>clip clip1, clip clip2</var></p>
<p></p><ul><li>Ekvivalent k <code>mt_lutxy("x y - 128 +")</code>, ale rychlejší.</li></ul><p></p>
<h3><a name="mt_adddiff"></a>mt_adddiff</h3>
<p><code>mt_adddiff</code> : <var>clip clip1, clip clip2</var></p>
<p></p><ul><li>Ekvivalent k <code>mt_lutxy("x y + 128 -")</code>, ale rychlejší.</li></ul><p></p>
<h3><a name="mt_clamp"></a>mt_clamp</h3>
<p><code>mt_clamp</code> : <var>clip c, clip bright_limit, clip dark_limit, int overshoot(0), int undershoot(0)</var></p>
<p></p><ul>
<li>Vynutí, aby byla hodnota  prvního klipu mezi bright_limit + overshoot a dark_limit - undershoot.</li>
<li>Dává neádoucí vısledky pokud je bright_limit + overshoot &lt; dark_limit - undershoot.</li>
</ul><p></p>
<h3><a name="mt_invert"></a>mt_invert</h3>
<p><code>mt_invert</code> : <var>clip c</var></p>
<p></p><ul>
<li>Invertuje (obrací) hodnoty pixelù.</li>
<li>Ekvivalent k <code>mt_lut("255 x -")</code>, ale rychlejší.</li>
</ul><p></p>
<h3><a name="mt_binarize"></a>mt_binarize</h3>
<p><code>mt_binarize</code> : <var>clip c, int threshold(128), bool upper(false)</var></p>
<p></p><ul>
<li>Pokud je <var>upper</var> false, vynutí, aby všechny hodnoty, které jsou zjevnì nad <var>threshold</var> byly 0, a všechny ostatní 255.</li>
<li>Jinak vynutí,  aby všechny hodnoty, které jsou zjevnì nad <var>threshold</var> byly 255, a jinak 0.</li>
<li><var>upper</var> = true je ekvivalent pro <code>mt_lut("x threshold &gt; 0 255 ?")</code>, ale rychlejší.</li>
<li><var>upper</var> = false je ekvivalent pro <code>mt_lut("x threshold &gt; 255 0 ?")</code>, ale rychlejší.</li>
</ul><p></p>
<h3><a name="mt_logic"></a>mt_logic</h3>
<p><code>mt_logic</code> : <var>clip clip1, clip clip2, string mode("and")</var></p>
<p></p><ul>
<li>Aplikuje funkci definovanou parametrem <var>mode</var> na <var>clip1</var> a <var>clip2</var>.</li>
<li>Moné hodnoty pro <var>mode</var> jsou :<ul>
<li><b>"and"</b> : provádí binární "and" na kadém páru pixelù ( 11
&amp; 5 je poèítáno jejich pøevedním na binární èíslo, a logickım souèinem (and) všech
bitù : 11 = 1011, 5 = 101, 11 &amp; 5 = 1 ).</li>
<li><b>"or"</b> : provádí binární "or" na kadém páru pixelù ( 11 | 5 = 1011 | 101 = 1111 = 15 ).</li>
<li><b>"xor"</b> : provádí binární "xor" na kadém páru pixelù ( 11 ^ 5 = 1011 ^ 101 = 1110 = 14 ).</li>
<li><b>"andn"</b> : provádí binární "and not" na kadém páru pixelù ( 11 &amp; ~5 = 1011 &amp; ~101 = 1011 &amp; 11111010 = 1010 = 10 ).</li>
<li><b>"min"</b> : dává minimum kadého páru pixelù.</li>
<li><b>"max"</b> : dává maximum kadého páru pixelù.</li>
</ul></li>
</ul><p></p>
<h3><a name="mt_hysteresis"></a>mt_hysteresis</h3>
<p><code>mt_hysteresis</code> : <var>clip small_mask, clip big_mask</var></p>
<p></p><ul>
<li>Prorùstá malou masku do velké masky spojovacími komponentami. To umoòuje sestavovat robustnìjší masky hran (obrysù).</li>
</ul><p></p>
<h3><a name="mt_convolution"></a>mt_convolution</h3>
<p><code>mt_convolution</code> : <var>clip c, string horizontal("1 1 1"), string vertical("1 1 1"), bool saturate(true), float total(1.0f)</var></p>
<p></p><ul>
<li>Aplikuje na video konvoluci definovanou jádrem <var>horizontal</var>T x <var>vertical</var>.</li>
<li>Jak <var>horizontal</var> tak <var>vertical</var> musí mít lichou délku.</li>
<li>Vıchozí normalizaèní hodnota je suma absolutních hodnot koeficientù jádra.</li>
<li>Pokud je <var>saturate</var> true, vısledek konvoluce je oøíznut do [0..255], jinak je oøíznuta jeho absolutní hodnota do [0..255].</li>
<li>Pokud je definováno <var>total</var> pøepíše vıchozí normalizaèní hodnotu.</li>
<li>Vıpoèty se provádí jako desetinné jakmile je jeden element z <var>horizontal</var> nebo <var>vertical</var> desetinnı (float).</li>
</ul><p></p>
<h3><a name="mt_mappedblur"></a>mt_mappedblur</h3>
<p><code>mt_mappedblur</code> : <var>clip c, clip map, string kernel("1 1 1 1 1 1 1 1 1"), string mode("replace")</var></p>
<p></p><ul>
<li>Aplikuje konvoluèní jádro na klip, ale zvláštním zpùsobem, v souladu s <var>mode</var> : <ul>
<li><b>"replace"</b> : pokud se pixel liší o více ne <var>map</var> od støedového pixelu konvoluce, je nahrazen støedovou hodnotou.</li>
<li><b>"dump"</b> : pokud se pixel liší o více ne <var>map</var> od støedového pixelu konvoluce, není zahrnut.</li>
</ul></li>
</ul><p></p>
<h3><a name="mt_square_mt_circle_mt_diamond"></a>mt_square, mt_circle, mt_diamond</h3>
<p><code>mt_square</code> : <var>int radius(1), bool zero(true)</var><br>
<code>mt_circle</code> : <var>int radius(1), bool zero(true)</var><br>
<code>mt_diamond</code> : <var>int radius(1), bool zero(true)</var></p>
<p></p><ul>
<li>Vytváøí seznam relativních souøadnic, kterı mùe bıt pouit v <code>luts</code>, <code>mt_expand</code> a <code>mt_inpand</code></li>
<li><var>zero</var> rozhoduje zda støed formy je zahrnut nebo ne.</li>
</ul><p></p>
<h3><a name="mt_rectangle_mt_ellipse_mt_losange"></a>mt_rectangle, mt_ellipse, mt_losange</h3>
<p><code>mt_rectangle</code> : <var>int hor_radius(1), int ver_radius(1), bool zero(true)</var><br>
<code>mt_ellipse</code> : <var>int hor_radius(1), int ver_radius(1), bool zero(true)</var><br>
<code>mt_losange</code> : <var>int hor_radius(1), int ver_radius(1), bool zero(true)</var></p>
<p></p><ul>
<li>Vytváøí seznam relativních souøadnic, kterı mùe bıt pouit v <code>luts</code>, <code>mt_expand</code> a <code>mt_inpand</code></li>
<li><var>zero</var> rozhoduje zda støed formy je zahrnut nebo ne.</li>
</ul><p></p>
<h3><a name="mt_freerectangle_mt_freeellipse_mt_freelosange"></a>mt_freerectangle, mt_freeellipse, mt_freelosange</h3>
<p><code>mt_freerectangle</code> : <var>int top_x(-1), int top_y(-1), int bottom_x(1), int bottom_y(1), bool zero(true)</var><br>
<code>mt_freeellipse</code> : <var>int top_x(-1), int top_y(-1), int bottom_x(1), int bottom_y(1), bool zero(true)</var><br>
<code>mt_freelosange</code> : <var>int top_x(-1), int top_y(-1), int bottom_x(1), int bottom_y(1), bool zero(true)</var></p>
<p><ul>
<li>Vytváøí seznam relativních souøadnic, kterı mùe bıt pouit v <code>luts</code>, <code>mt_expand</code> a <code>mt_inpand</code></li>
<li><var>zero</var> rozhoduje zda (0,0) pixel je zahrnut nebo ne.</li>
</ul></p>
<h3><a name="mt_polish"></a>mt_polish</h3>
<p><code>mt_polish</code> : <var>string expr("x")</var></p>
<p></p><ul>
<li>Vytváøí obrácenı polskı vıraz (reverse polish expression) z bìného (infix).</li>
</ul><p></p>
<h2><a name="reverse_polish_notation"></a>V) Obrácenı polskı zápis (Reverse polish notation).</h2>
Hodnì filtrù pøijímá uivatelské funkce definované vırazem zapsanım v obráceném polském
zápisu. Nemusíte bıt zvyklí na tento zápis, take zde je nìkolik vodítek :
<ul>
<li>Základní koncept zápisu je zapsat operátor / funkci za argumenty.
Take, "x + y" v bìném zápisu se stane v obráceném polském "x y +". "(3 + 5) * x" by se stalo
"3 5 + x *". </li>
<ul>
  <li>Jak jste si všimli v posledním pøíkladu, velkou vıhodou tohoto zápisu je,
  e nepotøebuje závorky. Vıraz, kterı by byl uzavøen
  v závorkách ( "3 + 5" ) je správnì vypoèítán, protoe èteme
  vyraz zleva doprava, a proto kdy se setkáme s "+" , jeho dva
  operandy jsou neomylnì známy.
  <li>Podporované operátory jsou : "+", "-", "*", "/", "%" ( modulo ) a "^" (
  power )
  <li>Podporované funkce jsou : "sin", "cos", "tan", "asin", "acos", "atan",
  "exp", "log", "abs", "round", "clip", "min", "max".
  <li>Kdy budeme pøedpokládat, e kladné desetinné (float) èíslo je "true", a záporné
  je "false", mùeme také definovat logické operátory : "&amp;", "|", "&amp;!" (
  a not ), "Â" ( xor ).
  <li>Mùeme vytvoøit logické hodnoty s následujícími operátory srovnávání:
  "&lt;", "&gt;", "&lt;=", "&gt;=", "!=", "==", "=".
  <li>Promìnné "x" a "y" ( kdy je pouitelná ) obsahují hodnotu
  pixelu. Je to celé èíslo v rozsahu od 0 do 255.
  <li>Mùe bıt pouita konstanta "pi" .
  <li>Nakonec, existuje trojitı (ternary) operátor : "?", kterı pracuje jako "if .. then
  .. else .." ("jestlie .. pak .. jinak ..")
  <li>Všechny vıpoèty jsou provádìny v desetinnıch èíslech (floats), a koneènı vısledek je zaokrouhlen
  na nejbliší celé èíslo v rozsahu [0..255].
  <li>V celé dokumentaci najdete mnoho
  pøíkladù. </li></ul>
<h2><a name=changelog></a>VI) Seznam zmìn</h2>

<p>
<b>Alpha 36 :</b>
<ul>
<li>fixed : "pi" wasn't properly defined for all luts</li>
</ul>
</p>

<p>
<b>Alpha 35 :</b>
<ul>
<li>added : mt_lutspa</li>
</ul>
</p>

<p>
<b>Alpha 34 :</b>
<ul>
<li>added : support for interleaved2planar hack, enabling 422 support</li>
<li>changed : both avisynth 2.5 and 2.6 version are built</li>
</ul>
</p>

<p>
<b>Alpha 32 :</b>
<ul>
<li>added : mt_lutxyz</li>
<li>added : mt_lutsx</li>
<li>fixed : small memory leak in mt_luts</li>
</ul>
</p>
<p>
<b>Alpha 31 :</b>
<ul>
<li>fixed : mt_hysteresis was randomly crashing.</li>
<li>fixed : mt_polish is back.</li>
<li>added : round, clip, min, max and = for lut.</li>
<li>adapted : to msvc8 / yasm.</li>
</ul>
</p>

<p><b>Alpha 30 :</b>
<ul>
<li>fixed : luts was crashing if some pixels didn't have any neighbours in the pixels list.</li>
<li>added : mt_freerectangle, mt_freeellipse and mt_freelosange helpers.</li>
</ul>
</p>


<p><b>Alpha 29 :</b>
<ul>
<li>fixed : intern float to integer conversion that were badly rounding negative number. That resulted in -1.0 been rounded into 0 (!). Most notably affected was mt_convolution. Thanks redfordxx for pointing that out.</li>
</ul>
</p>

<p><b>Alpha 28 :</b>
<ul>
<li>fixed : mt_expand / mt_inpand / mt_convolution / mt_edge optimizations ( were borked
when width-16 was mod 64, and that could be noticed only with avs 2.5.7 )</li>
</ul>
</p>

<p><b>Alpha 27 :</b>
</p><ul>
<li>fixed : mt_binarize asm optimizations that borked with some thresholds</li>
</ul>
<p></p>

<p><b>Alpha 26 :</b>
</p><ul>
<li>fixed : avs closing issue.</li>
</ul><p></p>

<p><b>Alpha 25 :</b>
</p><ul>
<li>added : new html documentation.</li>
<li>fixed : wrong frame issue.</li>
<li>fixed : mt_merge with luma=true.</li>
</ul><p></p>

<p><b>Alpha 24 :</b>
</p><ul>
<li>fixed : issues with MT.dll ( thanks tsp, Boulder, vanessam and all those who suffered the bug ).</li>
<li>fixed : check for YV12 colorspace, and report an error if it isn't ( thanks Boulder ).</li>
<li>speed up : median mode for luts ( once again, thanks to tsp ).</li>
</ul><p></p>

<p><b>Alpha 23 :</b>
</p><ul>
<li>fix &amp; speed up : median mode, thanks to tsp's insightfull remark. Note to self : think
less like a mathematician, and more like a programmer. Simpler, faster &amp; not bugged.</li>
</ul><p></p>

<p><b>Alpha 22 :</b>
</p><ul>
<li>added : "med"/"median" mode to luts/lutf.</li>
<li>changed : luts doesn't necessarily consider the center pixel.</li>
<li>changed back : forms helpers prepends (0, 0).</li>
<li>changed : forms helpers now have a bool "zero" parameter, defaulted to true.</li>
<li>added : bool "luma" parameter to mt_merge, which makes it use the luma mask for
all three planes, and which forces chroma modes to "process" ( u=v=3 ).</li>
</ul><p></p>

<p><b>Alpha 21 :</b>
</p><ul>
<li>fixed : two &amp; three input clips filters where requesting wrong frames
leading to ghost artefacts.</li>
</ul><p></p>

<p><b>Alpha 20 :</b>
</p><ul>
<li>fixed : huge bug preventing most filters from working.</li>
</ul><p></p>

<p><b>Alpha 19 :</b>
</p><ul>
<li>code refactoring.</li>
<li>fixed : bug with asm and width lower than 64.</li>
<li>fixed : doesn't prepend (0, 0) pixel to the forms helpers.</li>
<li>added : "min/max" mode to mt_edge. The edge value is local max - local min ( taken on a
3x3 square ).</li>
<li>added : mt_lutf : a frame lut, see the description above.</li>
<li>added : mt_luts : a spatial lut, see the description above.</li>
</ul><p></p>

<p><b>Alpha 18 :</b>
</p><ul>
<li>added : mt_makediff, mt_adddiff, mt_average and mt_clamp, ported from mg262's
limitedsupport plugin. The asm code is his, though it has been ported to nasm. They
respectively amount to MakeDiff, AddDiff, SimpleAverage and Clamp.</li>
<li>added : mt_edge : "prewitt" kernel, taken from mg262's Prewitt filter. Unlike mg262's filter,
there's no multiplier ( it's always 1 ), but mt_edge's thresholds still apply. Results,
and speed, are identical except for the borders, which are now filtered.</li>
<li>added : "chroma" parameter, taken from mg262's excellent idea. It's a string that,
if used, overrides U and V values. It can be either "process", "copy", "copy first",
"copy second" or a number. "copy" and "copy second" work alike.</li>
<li>added : vmToon-0.74, adapted to masktools 2.0.</li>
<li>added : LimitedSharpenFaster, with LimitedSupport functions imported into the masktools.</li>
</ul><p></p>

<p><b>Alpha 17 :</b>
</p><ul>
<li>changed : behavior of mt_edge with a custom kernel : the automatic normalization factor
is now the sum of the absolute value of the coefficients, ceiled to the next power of two
if that power is &lt;= 128 ( else, it isn't ceiled ).</li>
<li>added : cartoon mode for mt_edge.</li>
<li>added : modified mfToon script, for masktools v2. mfToonLite's speed goes from 30 fps
to 70 fps, mfToon from 4.5 to 6.5.</li>
</ul><p></p>

<p><b>Alpha 16 :</b>
</p><ul>
<li>fixed : some asm code used in invert, binarize and memset to a particular value.
Bug made the first 8 pixels of the picture to be incorrect. Also, avoid another nasty issue
that arise when cropping ( not my fault this time, though ).</li>
</ul><p></p>

<p><b>Alpha 15 :</b>
</p><ul>
<li>fixed : bugs from inflate &amp; deflate ( thx you know you ).</li>
<li>reversed : inflate and deflate now match their masktools' v1 counterparts' behavior.
( if anybody used the new buggy one, let him speak quickly ).</li>
</ul><p></p>

<p><b>Alpha 14 :</b>
</p><ul>
<li>fixed : random crashes with some width and asm functions ( thx Didee ).</li>
</ul><p></p>

<p><b>Alpha 13 :</b>
</p><ul>
<li>fixed : mt_merge order swapped for mask operation ( no comment... ).</li>
</ul><p></p>

<p><b>Alpha 12 :</b>
</p><ul>
<li>fixed : bug with some width ( mod4 ) for the non processing mode ( != 1 or 3 ).</li>
<li>changed : mt_merge order swapped for mask operation.</li>
</ul><p></p>

<p><b>Alpha 11 :</b>
</p><ul>
<li>fixed : mt_convolution's multiple instanciation bug.</li>
</ul><p></p>

<p><b>Alpha 10 :</b>
</p><ul>
<li>fixed : offY was always set to offX.</li>
<li>fixed : offset quirk.</li>
<li>fixed : mt_convolution was crashing with floats.</li>
<li>changed : luts' equal operator is now equivalent to abs(x-y) &lt; 0.000001.</li>
<li>added : bool saturate(true) parameter to mt_convolution.</li>
<li>added : float total(1.0) parameter to mt_convolution.</li>
</ul><p></p>

<p><b>Alpha 9 :</b>
</p><ul>
<li>fixed : mt_lut, mt_lutxy : even faster loading.</li>
<li>fixed : mt_convolution : negative coefficients were offseted by 1.</li>
<li>fixed : mt_convolution : division by zero if the sum of the coefficients was 0.</li>
</ul><p></p>

<p><b>Alpha 8 :</b>
</p><ul>
<li>fixed : mt_edge in custom mode wasn't working properly.</li>
<li>fixed : mt_edge in custom mode, optimized wasn't working properly either.</li>
<li>fixed : mt_lutxy was slow to load, it's better now.</li>
</ul><p></p>

<p><b>Alpha 7 :</b>
</p><ul>
<li>fixed : forgot to add functions to the parser. Thanks Didee for pointing that out.</li>
</ul><p></p>

<p><b>Alpha 6 :</b>
</p><ul>
<li>fixed : mt_polish was having some trouble with functions.</li>
</ul><p></p>

<p><b>Alpha 5 :</b>
</p><ul>
<li>added : helpers for creating string for inpand / expand custom modes :<ul>
<li>mt_circle</li>
<li>mt_square</li>
<li>mt_diamond</li>
<li>mt_ellipse</li>
<li>mt_rectangle</li>
<li>mt_losange</li>
</ul></li>
<li>added : helper for lut : consersion from infix to reverse polish notation : <ul>
<li>mt_polish</li></ul></li>
</ul><p></p>

<p><b>Alpha 4 :</b>
</p><ul>
<li>added : custom modes for inpand / expand.</li>
</ul><p></p>

<p><b>Alpha 3 :</b>
</p><ul>
<li>Fixed : mt_invert, mt_binarize, mt_lutxy, which weren't working properly anymore.</li>
<li>Fixed : offset created by incorrect rounding in mt_convolution.</li>
<li>Fixed : mmx version of edges filters ( soft thresholding, and roberts ).</li>
<li>Fixed : mmx version of motion edge ( soft thresholding ).</li>
<li>added : mt_mappedblur.</li>
</ul><p></p>

<p><b>Alpha 2 :</b>
</p><ul>
<li>added functions to luts : sin, abs, cos, tan, exp, log, acos, atan, asin.</li>
<li>added "vertical", "horizontal" and "both" mode to mt_inpand / mt_expand.</li>
<li>added mt_convolution.</li>
<li>fixed mt_merge behavior for y, u, v = 2.</li>
<li>added y, u, v = 4, for masked merge : copy the second clip channel. It's worth for any two clips input filters.</li>
<li>internal changes ( code reorganization ).</li>
 </ul><p></p>

<p><b>Alpha 1 :</b>
</p><ul><li>Original release.</li></ul><p></p>

<p><kbd>Èeskı pøeklad:22.5.2009</kbd>
</body></html>