<html>
<head>
<title>SimpleResize</title>
<link rel="stylesheet" type="text/css" href="../../avisynth.css">
<!--
Automatically generated, don't change:
$Id: simpleresize.htm,v 1.1 2010/02/27 14:50:14 wilbertd Exp $
-->
</head>
<body>
<h1>SimpleResize</h1>
<h2>Pøehled</h2>
<b>autor:</b> Tom Barry
<br><b>verze:</b> 0.3.3.0
<br><b>stáhnout:</b> <a href="http://www6.impacthosting.com/trbarry/downloads.htm">http://www6.impacthosting.com/trbarry/downloads.htm</a>,
<a href="http://www.avisynth.org/warpenterprises/">http://www.avisynth.org/warpenterprises/</a><br>
<b>kategorie:</b> Filtry pro zmìnu velikosti
<br><b>požadavky:</b> YV12 &amp; YUY2 Barevné prostøedí
<hr>
<h2>Popis</h2>
SimpleResize je Avisynth filtr, který provede velmi jednoduchou 2 vývodovou (tap) lineární interpolaci. Je nefiltrovaný, což znamená, že moc nezmìkèuje.
<p><code>InterlacedResize</code> &amp; <code> InterlacedWarpedResize</code> jsou navrženy pro práci s prokládaným
materiálem (více na konci dokumentace).</p>
<p>Jeho hlavní výhodou je, že pobìží o nìco rychleji než jiné.</p>
<h3>Aby jste ho použili prostì:</h3>
<p> použijte ve vašem Avisynth souboru pøíkazy podobné tìmto </p>
<pre>LoadPlugin(&quot;F:\SimpleResize\SimpleResize.dll&quot;)
Avisource(&quot;D:\kdekoli\mujsoubor.avi&quot;)
SimpleResize(width, height)</pre>
<p> Samozøejmì nahraïte jména souboru a složek vašimi vlastními a doplòte
  celá èísla za <var>width</var> &amp; <var>height</var>. </p>
<p><code>SimpleResize</code> by mìl bìžet na všech MMX strojích. Obsahuje také nìjaký (volitelný)
kód pro SSE2 instrukce k práci na P4 a také nìjaký kód pro SSEMMX
  k práci na P3 &amp; Athlonech, jestliže je používají. Lituji, ale neplánuji zvláštní kód pro
  3DNow.</p>
<h3>WarpedResize</h3>
<p><code>WarpedResize</code> je do SimpleResize.dll také zahrnut. <code>WarpedResize</code>
provede nelineární protažení/stlaèení jak v horizontálním tak vertikálním rozmìru. To mùže být užiteèné,
  když chcete zmìnit pomìr stran video klipu a mít ho nejvíc zdeformovaný
  nahoøe, dole, a na boèních stranách. Je to pøedevším experimentální filtr, ale pøidal jsem ho, protože
  jsem potøeboval nìjaké zmìny kódu a ty se témìø nedotkly výkonu. Použijte ho takto:</p>
<pre>LoadPlugin(&quot;F:\SimpleResize\SimpleResize.dll&quot;)
AviSource(&quot;D:\kdekoli\mujsoubor.avi&quot;)
WarpedResize(width, height, hWarp, vWarp)</pre>
<p>kde <var>hWarp</var> &amp; <var>vWarp</var> jsou horizontální
  a vertikální deformaèní (warp) souèinitele. Jsou to reálná èísla, obvykle mezi 0.8 a 1.3 , které urèují jak nelineární výstup opravdu chcete.</p>
<p>Hodnoty nad 1.0 zpùsobí, že výstupní obraz bude více ve støedu a
  potlaèen na okrajích. Hodnoty pod 1.0 budou dìlat opak. Zadáním 1.0 pro jeden z nich
  provede lineární zmìnu velikosti v daném rozmìru, právì jako kdyby jste použili
<code>SimpleResize</code>.
Hodnoty daleko od 1.0 dají nìkteré velmi zvláštní výsledky. Viz. &quot;Poznámky pro
  Matematiky&quot; níže.</p>
<p>Jeden dùvod pro použití <code>WarpedResize</code> by byl, když máte klip s pomìrem stran 16:9
  a chcete zmìnit velikost na pomìr stran 4:3 bez vyøíznutí
  cenných informací nebo bez nutnosti zobrazovat èerné pruhy. (nebo naopak)</p>
<p>Pøíklad obrazu s použitím <code>WarpedResize</code> pro tento úèel je (prozatím) na <a href="http://www.trbarry.com/warptest.jpg"><cite>www.trbarry.com/warptest.jpg</cite></a>.
  Tento obraz byl z krátké HDTV digitální nahrávky, která mìla rozlišení 1280x720, a pomìr stran 16:9. Byl zmenšen a deformován (warped) na
  640x480 s pomìrem stran 4:3 , použitím následujícího skriptového pøíkazu:</p>
<pre>WarpedResize(640,480,1.15,0.95))</pre>
<p>Také napøíklad nahrávka 4:3 deformovaná na 16:9 obrazovku vypadá takto <a href="http://www.trbarry.com/Warptest2.jpg"><cite>www.trbarry.com/Warptest2.jpg</cite></a></p>
<h3>Souèasná omezení pro SimpleResize/WarpedResize</h3>
<p>1) V souèasnosti je podporován jen YUY2 barevný režim. Pokud je to potøeba pøidejte napøed pøíkaz ConvertToYuY2.</p>
<p>2) Cílová šíøka už NEMUSÍ být dìlitelná 4 pixely.</p>
<p>3) Pobìží rychleji na SSE2 strojích, pokud bude cílová šíøka dìlitelná
  8 pixely a pokud data zaèínají na 8 pixelové hranici. Nevím jestli ho døívìjší použití pøíkazu Clip()
  ovlivní nebo ne.</p>
<p>4) Jestli nìkdo ví, jak z tohoto filtru udìlat DirectShow filtr byl bych rád kdyby se o to se mnou podìlil. ;-)</p>
<h3>Poznámky pro matematiky: (a otázky)</h3>
<p>Pøedstavte si obrazovku s rozmìry od -1.0 do 1.0. Prozatím budeme uvažovat jen
  horizontální rozmìr a jen pravou polovinu obrazovky.
  Dejme tomu, že chceme vypoèítat hodnotu výstupního pixelu v místì x, kde 0 &lt;=
  x &lt;=1.</p>
<p>Výstupní hodnota bude zdrojová hodnota pro vstupní obrazovku se stejnými rozmìry
  v místì s. Teï prostì vypoèítáme s = (1-w) * x^3 + w * x, kde w
  je deformaèní (warp) souèinitel zmínìný výše (Pozdìjší poznámka: w = 2 - warp souèinitel, pro kompaktnost s prvním vydáním).
  Toto provede svou práci a vytváøí plynulá èísla od 0 do jedné, bez velkého pokøivení
  dokud je w poblíž 1.0. </p>
<p>Stejná formule odráží práci v levé polovinì obrazovky.</p>
<p>Deformaèní rovnice jsou navrženy tak aby:</p>
<p>* Vždy rostly, ale dávaly výsledky od 0 do 1</p>
<p>* Jsme mìli první odvozeninu, která se neblíží k 0 nebo nekoneènu, a pokud možno poblíž støedu obrazovky</p>
<p>* Jsme mìli køivku (absolutní hodnota 2. odvozeniny), která je malá uprostøed a plynule se zvyšuje smìrem ke krajùm. Chtìli bychom køivku,
aby byla kdekoli = 0 když je warp souèinitel = 1</p>
<p>Øekl bych, že køivka je více èi ménì urèena absolutní hodnotou
  druhé odvozeniny. Takže pokud jsme chtìli malou køivku pøi x = 0 a
  aby se zvyšovala smìrem k okrajùm, jaká deformaèní (warp) funkce by byla užiteèná? Funkce výše už
reprezentuje zmìnu od V 0.1 , ale stále si nejsem jistý jestli je nejlepší. </p>
<p>Je snadné napsat ještì jednu deformaèní funkci. A pøitom není žádná ztráta výkonu,
protože je to vypoèteno a zaneseno do tabulek pøi spuštìní. Poté
  to bìží stejnou rychlostí jako SimpleResize.</p>
<p>Má nìkdo nìjaký nápad? (Zajímá nìkoho tato èást?)</p>
<h3>InterlacedResize a InterlacedWarpedResize</h3>
<p>Pokud chcete zmìnit velikost prokládaného zdroje, mùžete použít toto:</p>
<p><code>InterlacedResize</code> (<var>width, height</var>)</p>
<p>nebo</p>
<p><code>InterlacedWarpedResize</code> (<var>width, height, hWarp, vWarp</var>)</p>
<p>Obì funkce mají stejné parametry jako pøedchozí, ale jsou navrženy pro práci s prokládaným zdrojem
  bez smíchání (blending) dat sudých/lichých polí a bez popletení souøadnic kvùli
  posunùm sudých/lichých øádkù. Teoreticky mohou ztratit malé množství vertikálních
  detailù nebo zmást další deinterlaèní nebo IVTC funkce, ale dosud jsem ve svých testech
  nenašel takové problémy.</p>
<p>Takže pokud zamýšlíte zachovat vaše video v prokládané podobì, urèitì toto použijte.
  A pokud zmenšujete mùžete si všimnout, že stojí za to provést napøed InterlacedResize pøed
  nároènìjším odstraòováním prokládání, protože získáte malou výkonovou výhodu.
  Ale je to stále experimentální. YMMV.
</p>
<p><kbd>$English Date: 2005/06/09 20:43:30 $</kbd></p>
<p><kbd>Èeský pøeklad:30.4.2009</kbd></p>
</body>
</html>
