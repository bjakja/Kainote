<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="en">
<head>
<title>MVTools</title>

<link rel="stylesheet" type="text/css" href="../../avisynth.css"/>



</head>
<body>
<h1>MVTools</h1>
<h2>Pøehled</h2>
<b>autoøi:</b> Manao, Fizick (Alexandr Balachnin), Tsp, TSchniede
<br><b>verze:</b> 2.4.2
<br><b>stáhnout:</b> <a href="http://avisynth.org.ru/">http://avisynth.org.ru/</a> <br>
<b>kategorie:</b>  Rùzné pluginy<br>
<b>poadavky:</b> YV12 nebo YUY2 barevnı formát<br>
<b>licence:</b> GPL
<hr>
<h2>Obsah
</h2>
<ul>
  <li><a href="#mvtools">
I) O pluginu MVTools</a>
  </li>
  <li><a href="#version2">Ia) O verzi 2 MVTools</a></li>
  <li><a href="#functions">II) Popisy funkcí</a></li>
  <li><a href="#examples">III) Pøíklady</a></li>
  <li><a href="#disclaimer">IV) Odmítnutí záruk (nepøeskakujte tuto èást, ale nenutím vás
to nauèit se)</a></li>
  <li><a href="#revisions">V) Revize</a></li>
</ul>
<h2><a name="MVTools"></a>I) O pluginu MVTools
</h2>
<p>MVTools - plugin pro AviSynth 2.5 je kolekce funkcí
pro odhadnutí a kompenzaci pohybu objektù ve video klipech.
Kompenzace pohybu mùe bıt pouita pro silné èasové (temporal) odšumìní, pokroèilé pøevody snímkovıch frekvencí,
restauraci obrazu a další úlohy.
</p>
<p>Plugin obsahuje server-funkci odhadu pohybu MAnalyse pro nalezení vektorù pohybu a
 nìkolik klient-funkcí kompenzace pohybu (MCompensate, MMask a další)
které pouívají tyto vektory.
</p>
<p>Plugin pouívá metodu srovnávání blokù pro odhad pohybu (podobné metody jsou pouity v MPEG2, MPEG4, atd).
Ve fázi analızy plugin rozdìluje snímky na malé bloky a snaí se najít pro kadı blok v aktuálním snímku
nejpodobnìjší (odpovídající) blok v druhém snímku (pøedchozím nebo následujícím).
Relativní posunutí tìchto blokù je vektor pohybu.
Hlavním mìøítkem podobnosti blokù je souèet absolutních rozdílù (SAD)
všech pixelù tìchto dvou porovnávanıch blokù.
SAD je hodnota, která øíká, jak dobrı byl odhad pohybu.
<p>Vıstupem MAnalyse (server) je speciální klip s informacemi o vektorech pohybu v nìjakém formátu.
</p>
<p>Ve fázi kompenzace klient-funkce pluginu ètou vektory pohybu
a pouijí je k vyjmutí blokù a zformování snímku s kompenzovanım pohybem
(nebo realizuje nìjakou jinou plnou nebo èásteènou kompenzaci pohybu nebo funkci interpolace).
Kadı objekt (blok) v tomto (plnì) kompenzovaném snímku je umístìn na stejnou pozici v jaké je v aktuálním snímku.
Tedy, mùeme (napøíklad) pouít silné èasové odšumìní dokonce pro docela rychle se pohybující objekty
bez vytváøení nepøíjemnıch artefaktù a duchù
(rysy objektu a hrany jsou shodné pokud je kompenzace perfektní).
Plugin mùe vytvoøit kompenzované sousední snímky pro kadı aktuální snímek,
a odstranit v nich šum vnitøní funkcí (MDenoise).
Nebo mùete pouít kompenzované a pùvodní snímky k vytvoøení prolínaného (interleaved) klipu,
odstranit v nich šum jakımkoliv externím èasovım (temporal) filtrem,
a vybrat centrální vyèištìné pùvodní snímky pro vıstup (viz pøíklady).
</p>
<p>Odhad pohybu a jeho kompenzace nejsou samozøejmì ideální a dokonale pøesné.
V nìkterıch komplikovanıch pøípadech (video se stmíváním - fading, ultra-rychlého pohybu, nebo periodickıch struktur)
mùe bıt odhad pohybu zcela chybnı, a kompenzovanı (obzvláštì interpolovanı) snímek mùe bıt kostkatı a (nebo) ošklivı.
Tìké potíe jsou také kvùli vzájemnému zastínìní jednoho objektu druhım nebo obrácenì odkrıvání.
Sloité Avisynth skripty s øadou funkcí pro kompenzaci pohybu mohou spotøebovat velkı objem pamìti
a vısledkem je velmi pomalé zpracování.
Nejedná se o jednoduchı, ale o docela pokroèilı plugin. Pouívejte ho jen ve vhodnıch pøípadech a snate se vyladit jeho parametry.
Existuje mnoho diskuzí o pouití kompenzace pohybu na doom9 Avisynth fóru.
Pøedevším se podívejte na starší vlákno <a href="http://forum.doom9.org/showthread.php?t=76041">MVTools</a>,
vlákno <a href="http://forum.doom9.org/showthread.php?t=102071">true motion</a>,
nové vlákno <a href="http://forum.doom9.org/showthread.php?t=84770">MVTools</a> a nìkterá další.
Snate se èíst pøíspìvky jako doplnìk této dokumentace a ádejte zde o pomoc.
Pokud se skuteènì zajímáte o témata odhadu a kompenzace pohybu,
mùete snadno najít øadu vìdeckıch publikací (pouijte WWW vyhedávání).
</p>
<p>Poznámky: Plugin je stále ve vıvoji. Aktuální verze má nìkterá omezení.
Podporováno je jen progresivní YV12, YUY2 video.
Pouijte pøevod barevného formátu a zkuste pouít (smart) bob-deinterlace pro prokládané video
(mùe také pracovat rozdìlení na pole SeparateFields s nebo bez SelectEven/SelectOdd).
Nìkteré komplikované skripty (MVBOB, MCBOB, TempGaussMC) pouívají MVTools pro
<a href="http://forum.doom9.org/showthread.php?t=84725">odstranìní prokládání s kompenzací pohybu.</a>
 </p>
 <p>Alternativnì mùete zkusit pouít <a href="http://forum.doom9.org/showthread.php?t=101859">plugin Motion</a> od mg262.
</p>
<h2><a name="version2"></a>Ia) O verzi 2 MVTools</h2>

<p>MVTools verze 2 je vıznamnou vnitøní i vnìjší aktualizací.
Hlavními cíly MVTools v2.X jsou jasnost a stabilita
(pøedevším pro vícevláknová prostøedí na vícejádrovıch CPU) a samozøejmì zlepšení vıkonu i vyuití pamìti.</p>
<p>Hlavní prostøedek k dosaení cílù je odstranìní vnitøního bufferu MVTools
s mysteriózním (pro øadu lidí) indexem (idx) a dále nìkteré další vnitøní triky
(viz vlákno <a href="http://forum.doom9.org/showthread.php?t=131033">MVTools without idx</a>).
Pro implementování tohoto bez sníení vıkonu pouíváme normální efektivní snímkovı keš (cache) Avisynthu
a uvadíme nové povinné pøípravné stadium (pøed odhadem pohybu pomocí <code>MAnalyse</code>).
V tomto stadiu bude nová funkce <code>MSuper</code> dostávat zdrojovı klip a pøipraví speciální klip "super"
s víceúrovòovımi (hierarchicky upavovanımi) daty snímkù
(V pøedchozích verzích MVTools 0.X-1.X byla tato víceúrovòová data pøipravena, uloena a kešována vnitønì
pomocí idx jako indexem pseudo-klipu tìchto "supersnímkù" ).
Super klip je pak pouit jak ve funkci <code>MAnalyse</code> tak klientskıch funkcí kompenzace pohybu.</p>
<p>Odpovídající zmìna syntaxe: nìkteré parametry (pel, sharp) funkce <code>MAnalyse</code> jsou pøesunuty do funkce <code>MSuper</code>.</p>
<p>Další podstanou vnìjší zmìnou je nahrazení všech jmennıch klipovıch parametrù nejmennımi
(povinné, bez dvojtıch uvozovek v popisu) pro normální práci implicitního klipu "last" v Avisynthu.</p>
<p>Ve v.2.0 je implementováno také rychlejší planární zpracování pro YUY2.</p>
<p>Od v2.2 je MVTools.dll pøejmenováno na MVTools2.dll, a
od v2.3  jsou všechny funkce pøejmenovány z MVxxx na Mxxx (t.j. z MVAnalyse na MAnalyse),
take mùete pokraèovat v pouívání starıch MVTools 1.x s vašimi starımi skripty,
a jste schopni pouít / vytvoøit nové skripty s MvTools 2.x beze zmìny naèítané dll.</p>
<p>Také mám v úmyslu odstranit (neimplementovat) nìkteré zastaralé funkce jako MVDenoise, MVFlowFps2 (hlasujte prosím).</p>
<p>Úplnı seznam zmìn viz kapitola <a href="#revisions">Revize</a> .</p>
<p>Obecnì, nové MVTools 2.0 by mìly poskytnout podobné vısledky jako v1.11.4.
Vylepšení algoritmu je plánováno ve v2.1 a pozdìjších.</p>
<p>Poznámka: v2 má v souèasnosti alfa (beta?) status (mìla by bıt pøi zpracování stabilní, ale nìkterá syntaxe se mùe zmìnit).
Vítají se oznámení monıch chyb a návrhy (poadavky na funkce).</p>
<p>Poslední poznámka: MVTools v1.x se u nevyvíjí a nepodporuje (Fizick).
</p>

<h2><a name="functions"></a>II) Popisy funkcí
</h2>

<h3>Bìné parametry</h3>

<p>Filtry, které pouívají vektory pohybu mají bìné parametry.
Ty jsou prahovımi hodnotami detekce zmìny scény,
a mají znaky isse mmx. Také pouívají jeden nebo více
vektorovıch streamù, které jsou vytváøeny funkcí <code>MAnalyse</code>.
</p>
<p><var>int "thSCD1"</var> : prahová hodnota, která rozhoduje, zda se blok zmìnil
mezi pøedchozím snímkem a aktuálním. Kdy se blok zmìnil, znamená to,
e odhad pohybu pro toto není vıznamnı. To nastává
napøíklad pøi zmìnì scény. Tedy to je jedna z prahovıch hodnot pouitıch k nastavení
mechanismu zmìny scény. Jeho zvìtšení sníí
poèet blokù detekovanıch jako zmìnìné. Mùe to bıt uiteèné pro zašumìlé nebo blikající video.
Prahová hodnota je porovnána s hodnotou SAD
(Sum of Absolute Differences - souèet absolutních rozdílù, hodnotou, která øíká jak špatnı byl odhad pohybu ).
Pro pøesnì identické bloky máme SAD=0. Ale skuteèné bloky se vdy liší kvùli sloitému pohybu objektù
(pøiblíení, rotaci, deformaci), diskrétnosti vzorkování pixelù, a šumu.
Pøedpokládejme, e máme dva porovnané bloky 8x8 s kadım pixelem lišícím se o 5.
V tomto pøípadì bude SAD 8x8x5 = 320 (blok nebude detekován jako zmìnìnı pro thSCD1=400).
Pokud pouijete bloky 4x4, SAD bude 320/4.
Pokud pouijete bloky 16x16, SAD bude 320*4.
Ve skuteènosti se tento parametr násobí vnitønì v MVTools,
a vy musíte vdy pouít hodnotu redukovanou na velikost bloku 8x8.
Vıchozí je 400 (od v.1.4.1).
</p>
<p><var>int "thSCD2"</var> : prahová hodnota, která nastavuje kolik blokù ve snímku se musí zmìnit
aby se rozhodlo, e se jedná o zmìnu scény. Je to v rozsahu 0 a 255, 0
znamená 0 %, 255 znamená 100 %. vıchozí je 130 ( co znamená 51 % ).
</p>
<p><var>bool "isse"</var> : znak, kterı umoòuje vypnout ISSE a MMX optimalizace pokud se nastaví na false (pro odladìní).
Vıchozí je true. Pokud váš procesor nepodporuje ISSE MMX optimalizace, bude to kadopádnì
vypnuto ( a vy nebudete schopni je aktivovat )</p>
<p><var>bool "planar"</var> : znak pro pouití speciálního planárního barevného formátu pro YUY2 klipy, jak pro vstup tak pro vıstup funkce.
Vyuívá zvláštní trik pro uchování snímkù s planární organizací dat barev
(oddìlené Y, U, V plochy v pamìti) v normálním prolínaném (interleaved) formátu YUY2 jako kontejneru.
Tak se mùeme vyhnout øadì vnitøních pøevodù prolínaného (interleaved) formátu do planárního a tím zvıšíme rychlost.
Mùete pøevést normalní prolínanı YUY2 zdrojovı klip na planární formát pomocí funkce <code>Interleaved2planar</code>
z pluginu <a href="http://home.pages.at/kassandro/RemoveGrain/">RemoveGrain od kassandra</a>,
a pøevést koneènı vısledek pomocí funkce <code>Planar2interleaved</code> .
Tento speciální planární YUY2 formát je podporovanı také v pluginu Removegrain od Kassandra, pluginu MaskTools2 od Manaa a nìkterıch dalších.
Tento trik nebude nutnı v Avisynthu v2.6 s nativní podporou planárního formátu YV16.
Tento parametr je ignorován u YV12 klipù. Poznámka: klip super je vdy planární.
Vıchozí je planar=false. </p>

<h3>MSuper</h3>

<p><code>MSuper</code> (<var>clip, int "hpad", int "vpad", int "pel", int "levels", bool "chroma",
int "sharp", int "rfilter", clip "pelclip", bool "isse", bool "planar"</var>)
</p>
<p>Dostává vstupní klip a pøipravuje speciální "super" klip s víceúrovòovımi (hierarchicky upravenımi) daty snímkù.
Superklip je pouit jak v <code>MAnalyse</code> tak ve (klientskıch) funkcích kompenzace pohybu.
Pro uchování a pøedání jejích parametrù pouijeme vlastností audia superklipu (jmenovitì, num_audio_samples) jako triku.
Tedy, audio je v superklipu zabito. To je jeden z dùvodù, proè dodateènì pouíváme zdrojovı klip s klient funkcemi.
Mùete se podívat na superklip sami (má normální formát).</p>
</p>
<p><var>hpad</var> : je to horizontální vyplnìní (pruh) pøidané do zdrojového snímku (vlevo i vpravo).
Malé vyplnìní je dodáno pro správnìjší odhad pohybu v blízkosti okrajù snímku.
(V MVTools pøed v2.0 byla vdy vnitønì pouita hodnota padding = velikosti bloku. Nyní to není striktní, ale doporuèená hodnota.) Vıchozí=8.
</p>
<p><var>vpad</var> : je to vertikální vyplnìní (pruh) pøidané do zdrojového snímku (nahoøe i dole). Vıchozí=8.
</p>
<p><var>pel</var> : je to pøesnost odhadu pohybu.  Hodnota mùe bıt jen 1, 2 nebo 4. 1 znamená
pøesnost na pixel. 2 znamená pøesnost na pùl pixelu, 4 znamená pøesnost na ètvrtinu pixelu,
tvoøenou prostorovou (spatial) interpolací (pøesnìjší ale pomalejší a ne vdy lepší kvùli velkému kroku násobení mezi úrovnìmi).
Vıchozí je 2 od v1.4.10.</p>
<p><var>levels</var> : je to poèet hierarchickıch úrovní ve snímcích superklipu.
MAnalyse je potøebná ve vešch úrovních,
ale pro jiné klient funkce je jedna jemná úroveò dostateèná (hrubší úrovnì se nepouívají).
Vıchozí : 0 (auto, vytváøí se všechny moné úrovnì).
</p>
<p><var>chroma</var> : je-li nastaven na true, umoòuje pøipravit i barevnostní plochy v superklipu. (false - jen jas (luma)). Vıchozí je true.
<p><var>sharp</var>:  metoda subpixelové interpolace pro <var>pel</var>=2,4. <br>
Pouijte 0 pro mìkkou interpolaci (bilineární), 1 pro bikubickou interpolaci (4 vıvodová Catmull-Rom),
 2 pro ostøejší Wiener interpolaci (6 vıvodová, podobná Lanczos).<br>
Vıchozí je 2.
</p>
<p><var>rfilter</var>:  filtr vyhlazování a zmenšování (pùlení) hierarchickıch úrovní.<br>
0 je jednoduché zprùmìrování 4 pixelù jako nefiltrovanı SimpleResize (stará metoda);<br>
1 je trojúhelníkovı (posunutı) filtr jako ReduceBy2 pro více vyhlazení (sniuje aliasing);<br>
2 je trojúhelníkovı filtr jako BilinearResize pro ještì více vyhlazení;<br>
3 je kvadratickı filtr pro ještì více vyhlazení;<br>
4 je kubickı filtr jako BicubicResize(b=1,c=0) pro ještì více vyhlazení.<br>
Vıchozí je 2 (od v2.3.1).
Mùete také zkusit pouít nìkterı externí filtr na superklip nebo jeho hrubou spodní èást (vhodnım oøíznutím a navrstvením).
</p>
<p><var>pelclip</var>: volitelnı nadvzorkovanı zdrojovı klip pro pouití místo vnitøní subpixelové interpolace (pro pel>1).<br>
Pixely v øádcích a sloupcích dìlitelnıch pel (0,2,4,... pro pel=2) (bez vyplnìní) musí bıt pùvodní zdrojové pixely,
jiné pixely musí bıt interpolovány.<br>
Pøíklad pro pel=2: <code>LanczosResize(width*2,height*2,src_left=0.25, src_top=0.25)</code>.
(Nedávná poznámka: je to správné pro jas, ale ne pøesnì odpovídá pozicím pixelù barevnosti vnitøní interpolace v MVTools.
Pøesto jsou vektory a kompenzace pohybu celkem podobné pro bìné klipy,
stejná barevnost by byla u src_left=0.5 pro YUY2 a dodateènì src_top=0.5 pro YV12).<br>
Další uiteènı pøíklad je EEDI2 hranovì-namíøenı resampler.<br>
Vıchozí není definováno.
</p>

<h3>MAnalyse</h3>

<p><code>MAnalyse</code> (<var>clip super, int "blksize", int "blksizeV", int "level", int "search",
int "searchparam", int "pelsearch", bool "isb", int "lambda", bool "chroma", int "delta",
bool "truemotion", int "lsad", int "plevel", bool "global", int "pnew", int "pzero", int "pglobal", int "overlap", int "overlapV",
string "outfile", int "dct", int "divide", int "sadx264", int "badSAD", int "badrange", bool "isse"</var>)
</p>
<p>Dostává pøipravenı víceúrovòovı superklip, odhaduje metodou srovnávání blokù
a vytváøí speciální vıstupní klip s daty vektorù pohybu (pouívanıch jinımi funkcemi).<br>
Nìkteré hierarchické víceúrovòové metody vyhledávání jsou implementovány (od hrubého mìøítka obrazu k nejjemnìjšímu).
Funkce pouívá nulovı vektor a vektory sousedních blokù jako prediktory pro aktuální blok.
Nejdøíve je odhadnut rozdíl (SAD) pro prediktory,
pak se zkušební vektor zmìní o nìjakou hodnotu v nìkterém smìru, odhadne se SAD, a tak dále.
Pøijmutı novı vektor je vektor s minimální hodnotou SAD (s urèitou úpravou pro soudrnost pohybu).
</p>
<p><var>super</var> (nejmennı) je víceúrovòovı superklip pøipravenı funkcí MSuper.</p>
<p><var>blksize</var> : Velikot bloku (horizontální). Je buï 4, 8 nebo 16 ( vıchozí je 8 ).
Vìtší bloky jsou ménì citlivé na šum, jsou rychlejší, ale také ménì pøesné.</p>
<p><var>blksizeV</var> : vertikální velikost bloku. Vıchozí je rovna horizontální velikosti.
Doplòkové monosti: 4 pro blksize=8 a 8 nebo 2 pro blksize=16.</p>
<p><var>level</var> : je poèet Nepouitıch hrubıch úrovní v hierarchické
analıze provádìné pøi vyhledávání vektorù pohybu. Obvykle èím niší, tím lepší (lze nalézt vektory s jakoukoliv délkou).
Promìnná je zachována pro studijní (testovací) úèely.
Nìkdy je <var>level</var> uiteènı pro vylouèení velkıch (livıch) vektorù (poèítaèové grafiky, atd).
Vıchozí = 1 odv.2.3 (jsou pouity všechny úrovnì kromì jedné).</p>
<p><var>search, searchparam, pelsearch</var> : <var>search</var> urèuje typ vyhledávání v kadé úrovni, a
<var>searchparam</var> je pøídavnı parametr (krok, rádius) pro toto vyhledávání,
a <var>pelsearch</var> je parametr na nejjemnìjší (pel) úrovni:
<ul>
	<li><var>search </var>= 0 : 'jednoprùchodové vyhledávání'. <var>searchparam</var> je krok mezi
  kadımi zkoušenımi vektory ( pokud <var>searchparam</var> je vìtší ne 1, krok se bude progresivnì upøesòovat
  - postupnì zmenšovat ).</li>
	<li><var>search </var>= 1 : 'N-prùchodové'. N je nastaveno parametrem <var>searchparam</var>. Je to
  nejznámìjší algoritmus vyhledávání vektorù pohybu.</li>
  <li><var>search </var>= 2 : Logaritmické vyhledávání, také nazıvané Diamantové vyhledávání.
  <var>searchparam</var> je úvodní krok vyhledávání, a také se postupnì zmenšuje.</li>
  <li><var>search </var>= 3 : Vyèerpávající vyhledávání, <var>searchparam</var> je rádius (ètvercová strana je 2*radius+1). Je
  pomalı, ale dává nejlepší vısledky podle hodnot SAD.</li>
  <li><var>search </var>= 4 : Hexagonální vyhledávání, <var>searchparam</var> je rozsah. (podobné x264).</li>
  <li><var>search </var>= 5 : Nerovnomìrné Multi Hexagonální (UMH) vyhledávání, <var>searchparam</var> je rozsah. (podobné x264).</li>
</ul>
Vıchozí jsou: <var>search</var>=4, <var>searchparam</var>=2, <var>pelsearch</var>=<var>pel</var>.</p>
<p><var>isb</var> : umoní volit mezi dopøednım vyhledáváním (pohyb z
pøedchozího snímku do aktuálního) pro <var>isb</var>=false a zpìtnım vyhledáváním (pohyb z následujícího
snímku do aktuálního) pro <var>isb</var>=true (isb znamená "IS Backward",
je to implementováno a nazváno pøesnì tak jak je zde popsáno, neptejte se na to :-). Vıchozí je <var>isb</var>=false.</p>
<p><var>chroma</var> : nastavení na true umoní zahrnout také barevnost pøi
odhadu pohybu (false - pouze jas). Vıchozí je true.
</p><p><var>delta</var> : nastavuje interval snímkù mezi referenèním snímkem a aktuálním
snímkem. Vıchozí je 1, co znamená, e vektory pohybu jsou vyhledávány mezi aktuálním snímkem
a pøedchozím ( nebo dalším ) snímkem. Nastavení na 2 vám umoní vyhledávat vektory pohybu mezi snímkem n a n-2
nebo n+2 ( v závislosti na nastavení <var>isb</var> ).</p>

<p> Existuje nìkolik pokroèilıch parametrù, které nastavují souvislost vektorù pohybu pro odhad takzvaného skuteèného pohybu (true motion).
Nìkteré porovnané bloky z jiného snímku mohou bıt nejpodobnìjší vzorovım blokùm aktuálního snímku podle kriteria intenzity (SAD),
ale neodpovídají skuteènému pohybu objektu.
Napøíklad, mohou pøíslušet jinému podobnému objektu v jiném rohu snímku nebo nìjaké periodické struktuøe.
Parametry "True motion" se snaí udret pohybová pole více soudrná, namísto nìkterıch náhodnıch distribucí vektorù.
Je to obzvláš dùleité pro jednotlivé kompenzace pohybu a interpolace.
Nìkteré parametry jsou experimentální a mohou bıt odstranìny (nahrazeny) v pøíštích verzích po vyzkoušení. Oznamujte prosím své závìry.
</p>
<p><var>truemotion</var> je pøednastavení hodnot tìchto parametrù.
Umoòuje snadno pøepnout vıchozí hodnoty všech "true motion" parametrù najednou.
Nastavte <var>true</var> pro vyhledávání skuteèného pohybu - true motion (vyšší soudrnost vektorù),
Nastavte <var>false</var> pro vyhledávání vektorù pohybu s nejlepší SAD.
Vıchozí je true od v1.4.10.
V kadém pøípadì mùete nastavit kadı parametr samostatnì.</p>
<p><var>lambda</var> : nastavuje soudrnost polí vektorù. Èím vyšší,
tím soudrnìjší. Nicménì, pokud je pøíliš vysokı, mohou bıt nìkteré nejlepší vektory pohybu
opomenuty. Velmi se doporuèují hodnoty kolem 400 - 2000 (pro velikost bloku 8).
Vnitønì je to koeficient pro penalizaci (úpravu) SAD od kvadratického rozdílu vektoru od prediktoru (sousedù),
násobenım 256. <br>
Vıchozí je 0 pro <var>truemotion</var>=false a 1000*blksize*blksizeV/64 pro <var>truemotion</var>=true.
</p>
<p><var>lsad</var>: SAD limit pro pouití <var>lambda</var> . Lokální <var>lambda</var> je sníeno (plynule od v1.10.2)
pokud hodnota SAD vektoru prediktoru (zhotovená ze sousedních blokù) je vìtší ne tento limit.
Brání to pouití špatnıch prediktorù, ale sniuje soudrnost pohybu.
Pro skuteènı pohyb (true motion) jsou doporuèeny hodnoty nad 1000. Vnitønì upravené na velikost bloku blocksize=8 (od v2.0.11).<br>
Vıchozí je 400 pro <var>truemotion</var>=false a 1200 pro <var>truemotion</var>=true.
</p>
<p><var>pnew</var>: relativní penalizace (násobena 256) k odchylce (SAD) nového kandidujícího vektoru.
Novı kandidující vektor musí bıt lepší, aby byl pøijat jako novı vektor jen, kdy jeho
SAD s penalizací (SAD + SAD*pnew/256) jen niší ne odchylka prediktoru (staré SAD).
To brání nahrazení docela dobrıch prediktorù novımi vektory s o trochu lepším SAD
ale jinou délkou a smìrem.<br>
Vıchozí je 0 pro <var>truemotion</var>=false a 50 pro <var>truemotion</var>=true.
</p>
<p><var>plevel</var>:  reim násobení penalizaèního koeficientu <var>lambda</var> úrovnì.
Hodnota=0 - bez násobení, 1 - lineární, 2 - kvadratická závislost na velikosti hierarchické úrovnì.
Všimnìte si, e délka vektoru je menší na niší úrovni.<br>
Vıchozí je 0 pro <var>truemotion</var>=false a 1 pro <var>truemotion</var>=true
</p>
<p><var>global</var>:  odhaduje globální pohyb (v kadé úrovni) a pouívá ho jako doplòkovı prediktor.
Je odhadován pouze (panoramatickı) posun kamery (ne pøibliování ani rotace).
Pouijte false pro vypnutí, pouijte true pro zapnutí.
Vıchozí je false pro <var>truemotion</var>=false a true pro <var>truemotion</var>=true.
</p>
<p><var>pzero</var>: relativní penalizace (násobena 256) k odchylce (SAD) pro nulovı vektor.
Brání nahrazení docela dobrıch prediktorù nulovımi vektory s o trochu lepší SAD
(<var>lambda</var> se pro nulovı vektor nepouívá). Vıchozí je roven <var>pnew</var> od v1.11.
</p>
<p><var>pglobal</var>: relativní penalizace (upravená do rozsahu 256) k chybì SAD pro globální prediktor.
(<var>lambda</var> se nepouívá pro globální vektor). Vıchozí je 0.
</p>
<p><var>overlap</var>:  hodnota pøekrytí blokù (horizontální). Musí bıt sudá a menší ne velikost bloku
(do blksize/2 pro MCompensate).
Krok mezi bloky pro odhad pohybu je roven (blksize-overlap).
N blokù pokrıvá velikost ((blksize-overlap)*N + overlap)  na snímku.
Zkuste pouít hodnotu pøekrytí od blksize/4 do blksize/2.
Èím vìtší pøekrytí, tím vìtší poèet blokù, a tím menší rychlost zpracování.
Vıchozí hodnota je 0. <br>
Funkce s podporou pøekrytí jsou: MFlow, MFlowInter, MFlowFps, MShow, MMask, MCompensate, MDeGrain1, MDeGrain2, MDeGrain3.
</p><p><var>overlapv</var>:  vertikální hodnota pøekrytí blokù. Vıchozí je rovna horizontální.
Musí bıt sudá pro YV12 a menší ne velikost bloku.
</p><p><var>outfile</var>:  Jméno souboru pro zápis dat vektorù pohybu.
Tato data mohou bıt pouita nìkterım externím programem
nebo mohou bıt dalšími verzemi MVTools pro kódování druhého prùchodu, atd. <br>
Vytváøenı binární soubor má hlavièku (struktura MVAnalysisData, viz MVInterface.h ve zdrojovém kódu),
a sekvenci dat:<br>
èíslo snímku, data vektoru (Vx, Vy, SAD) kadého bloku,
pøíští platné èíslo snímku, data vektoru tohoto snímku, atd.<br>
Vıchozí - Prázdnı øetìzec, nezapisuje soubor.</p>
<p><var>dct</var>: pouití blokù DCT (frekvenèní spektrum) pro vıpoèet rozdílu blokù (SAD).
Zvláštì mùe zlepšit odhad vektoru pohybu pøi blikání a stmívání jasu.<br>
0 - obvyklé prostorové (spatial) bloky, nepouívat DCT;<br>
1 - pouít bloky DCT místo prostorovıch dat (pomalé pro velikost bloku 8x8 a velmi pomalé pro jiné velikosti);<br>
2 - smíchaná prostorová a DCT data; váha závisí na støedním rozdílu jasu;<br>
3 - adaptivní pøepínání po blocích z prostorového na ekvivalentní-váenı smíšenı reim (experimentální, o nìco rychlejší).<br>
4 - adaptivní pøepínání po blocích z prostorového na smíšenı reim s vìtší váhou DCT (experimentální, o nìco rychlejší).<br>
pøidané reimy ve v1.9.5.3:  (vyadují sadx264 0-7, pouívají nejrychlejší SATD funkce, pouze jas!) <br>
5 - SATD místo SAD pro jas<br>
6 - stejné jako 2 jen pouívají SATD<br>
7 - stejné jako 3 jen pouívají SATD<br>
8 - stejné jako 4 jen pouívají SATD<br>
9 - podobné jako 2, pouívají SATD a váené rozsahy od SAD jen k ekvivalentním SAD &amp; SATD<br>
10 - podobné jako 3/4,pouívají SATD váha je na SAD, jen na velké zmìny jasu<br>
Vıchozí = 0.
</p>
<p><var>divide</var>: post-processing vektorù pohybu rozdìlením kadého bloku na 4 podbloky.<br>
0 - nedìlit;<br>
1 - rozdìlit bloky a pøipsat originální vektor všem 4 podblokùm;<br>
2 - rozdìlit bloky a pøipsat støední (se 2 sousedními) vektory podblokùm;<br>
Vıchozí je = 0. Hodnoty velikosti bloku pøekrytí musí bıt zvoleny, aby byly pøijatelné po vnitøním dìlení.
</p>
<p><var>sadx264</var>: vyuívá SAD funkcí z kodeku x264 pokud jsou dostupné pro velikost bloku<br>
0 - Autodetekovat CPU a vybrat nejlepší funkce<br>
1 - pouít MMX 16x16, 16x8, 8x8, 8x4, 4x4 (8x16, 4x8 pouito jen na barevnost - chroma)<br>
2 - pouít MMX 16x16, 16x8, 8x8, 8x4 (8x16, pouito jen na barevnost - chroma) zarovnáno na 32 bajtové bloky<br>
3 - pouít MMX 16x16, 16x8, 8x8, 8x4 (8x16, pouito jen na barevnost - chroma) zarovnáno na 64 bajtové bloky, nejlepší pro Pentium M<br>
4 - pouít SSE2 16x16, 16x8 (ádné zvláštní zarovnání)<br>
5 - pouít SSE2 16x16, 16x8, zarovnáno na 64 bajtové bloky (dobrá volba pro Core)<br>
6 - pouít SSE3 16x16, 16x8 (zdá se, e rychleji pracuje jen na Pentium 4E &amp; Core1)<br>
7 - pouít SSSES3 16x16, 16x8, zarovnáno na 64 bajtové bloky (dobrá volba pro Core2)<br>
Reimy 8-12 jsou urèeny jen pro ladìní a testování - pouijte místo nich dct &gt;4.<br>
Pouití sadx264 &gt; 7 znamená: pouít vybranı místo SAD pro jakoukoliv jasové/barevnostní (luma/chroma) SAD kde je to moné!<br>
pro SAD / SATD mix a pouze luma pouijte dct<br>
8 - pouít SSD mmx, pracuje podobnì jako 1<br>
9 - pouít SATD mmx, pracuje podobnì jako 1<br>
10 - pouít SATD SSE2, pracuje podobnì jako 2<br>
11 - pouít SATD SSSE3, pracuje podobnì jako 2<br>
12 - pouít SATD SSSE3 s PHADD na 8xY, pracuje podobnì jako 2<br>
Vıchozí je 0, pouijte -1 nebo &gt;=13 pro pouití starého algoritmy v1.9.4 SAD a úplnou deaktivaci x264 SAD funkcí.<br>
</p>
<p><var>badSAD</var>: prahová hodnota SAD pro vytvoøení širšího druhého vyhledávání špatnıch vektorù. Hodnota je pøepoèítána ne velikost bloku 8x8.
Vıchozí je 10000 (hodnota vypnutí), doporuèená je kolem 1000-2000.<br>
</p>
<p><var>badrange</var>: rozsah (rádius) šíøky vyhledávání špatnıch blokù.
Vıchozí je 24 (v jednotkách pixelù obrazu). Pouijte kladné hodnoty pro UMH vyhledávání a záporné pro Vyèerpávající (Exhaustive) vyhledávání.
</p>

<p>Zkuste pouít funkci <code>MShow</code> pro kontrolu odhadnutıch polí pohybu a vyladìní parametrù.</p>
<p>Poznámka: MAnalyse (pokud Pel=2) detekuje znak videa zaloeného na polích (po SeparateFields) a automaticky
dìlá opravu vektorù pohybu v souladu s vertikálním posunem polí s rùznou paritou.
Zkuste pouít AssumeFrameBased pokud to nepotøebujete.</p>

<h3>MCompensate</h3>

<p><code>MCompensate</code> (<var>clip source, clip super, clip vectors, bool "scbehavior", float "recursion", int "thSAD",
bool "fields", int "thSCD1", int "thSCD2", bool "isse", bool "planar"</var>)
</p>
<p>Provádí plnou kompenzaci pohybu ve snímku. To znamená, e bloky ukázané
pomocí vektorù pohybu v referenèním snímku budou posunuty podle vektorù k dosaení jejich umístìní
v aktuálním snímku.</p>
<p><var>super</var> (nejmennı) je víceúrovòovı superklip pøipravenı funkcí MSuper.</p>
<p><var>vectors</var> (nejmennı) je klip s daty vektorù pohybu vytváøenı funkcí MAnalyse.</p>
<p><var>scbehavior</var> ( vıchozí je true ), rozhoduje, kterı snímek bude zachován
pøi zmìnì scény. Je-li true, snímek je ponechán nezmìnìnı. Jinak je do aktuálního snímku
zkopírován referenèní snímek.</p>
<p><var>recursion</var> je procentuální šíøe døíve kompenzovanıch snímkù pouitıch pro novou kompenzaci
ve speciálním rekurzivním reimu. Zbylá šíøka je brána (uniformì) z daného referenèního snímku (pouitého v obyèejném reimu).
Recursion=100 je plná rekurze podobná kruhovému reimu mode=2 starıch MVTools v0.9.x.
Nepouívejte rekurzivní reim, kdy nevíte co dìláte. Vıchozí je recursion=0.</p>
<p><var>thSAD</var> je prahová hodnota SAD pro bezpeènou (dummy) kompenzaci. Pokud je blok SAD nad thSAD,
pak je blok špatnı, a my pouijeme zdrojovı blok místo kompenzovaného bloku. Vıchozí je 10000 (prakticky vypnuto).
</p>
<p><var>fields</var>: je-li nastaven na true a <var>pel=2</var>, pak pøidáváme vhodná vertikální posunutí
 (po pùlpixelu) polí pro video zaloené na polích.
 Zkuste to pouít pro odstranìní prokládání (ne pro odšumìní).<br>
Vıchozí je false.
</p>
<p>Zpracování pøekrytıch blokù je implementováno jako okenní sumarizace blokù
(jako FFT3DFilter, hodnota pøekrytí do blksize/2) pro sníení blocking artefaktù (kostkatìní).
</p>

<h3>MMask</h3>

<p><code>MMask</code> (<var>clip source, clip vectors, float "ml", float "gamma",
int "kind", int "Ysc", int "thSCD1", int "thSCD2", bool "isse", bool "planar"</var>)
</p>
<p>Vytváøí klip masek ze zdrojového klipu s daty vektorù pohybu.
Maska je definována daty blokù, ale je interpolovaná, aby zapadla na celou velikost snímku.
Maska je vytvoøena jak na jasové (luma) tak na barevnostních (chroma) plochách. Hodnoty masky mohou bıt od 0 (min) do 255 (max).</p>
<p><var>kind</var> parametr definuje druh masky.
</p><p>Reim <var>kind=0</var> vytváøí masku pohybu z délek vektorù pohybu. Vytváøí lepší
masku ne funkce <code>MotionMask</code> pluginu MaskTools protoe vektory pohybu jsou mnohem víc vìrohodné ne
algoritmus MotionMask. Hodnota masky 0 znamená nikde ádnı pohyb ( délka
vektorù pohybu je nulová ). Èím vìtší délka vektoru, tím vìtší hodnota masky (nasycené do 255),
mìøítko je definováno pomocí <var>ml</var>.</p>
</p><p><var>kind=1</var> umoní vytvoøit masku hodnot SAD (souèet absolutních rozdílù) místo
délek vektorù. Mùe to bıt uiteèné k nalezení problémovıch oblastí se špatnım odhadem pohybu.
(Je pouit vnitøní faktor blocksize*blocksize/4 pro normalizaci mìøítka <var>ml</var>.)
<p><var>kind=2</var> umoòuje vytvoøit okluzní masku (špatné bloky v dùsledku roztrení, napìtí).
V souèasnosti se pouívá nìjakı normalizovanı souèet kladnıch rozdílù pohybu blokù. Mùe to bıt násobeno pomocí mìøítka <var>ml</var>.</p>
<p><var>kind=3</var> umoòuje vytvoøit masku horizontální komponenty vektoru pohybu v jednotkách pel plus 128.
Násobené koeficienty se nepouívají.</p>
<p><var>kind=4</var> umoòuje vytvoøit masku vertikální komponenty vektoru pohybu v jednotkách pel plus 128.
Násobené koeficienty se nepouívají.</p>
<p><var>kind=5</var> - barevná mapa pohybu jako x,y komponent vektorù pohybu zobrazenıch v U, V barevnıch plochách
(v jednotkách pel plus 128, násobené koeficienty se nepouívají).</p>
<p><var>ml</var> definuje mìøítko masky pohybu.
Kdy délka vektoru (nebo hodnota jiného typu) je vyšší nebo rovna <var>ml</var>, bude vıstupní
hodnota nasycena do 255. Menší hodnoty vedou k menším vıstupùm.
</p><p><var>gamma</var> je pouito pro definování ukazatele závislosti vıstupu na vstupu.
<var>gamma</var> = 1.0 znamená lineární závislost, zatímco <var>gamma</var> = 2.0 dává
kvadratickou závislost.</p>
<p>A nakonec, <var>Ysc</var> je hodnota vzatá maskou pøi zmìnì scény</p>
<p>Vıchozí jsou: <var>kind</var> = 0,  <var>ml</var> = 100, <var>gamma</var> = 1.0, a
<var>Ysc</var> = 0.</p>

<h3>MSCDetection</h3>

<p><code>MSCDetection</code> (<var>clip source, clip vectors, int "Ysc", int "thSCD1", int "thSCD2", bool "isse"</var>)
</p>
<p>Vytváøí masku detekce scény z dat vektorù pohybu.
Maska je vytvoøena jak na jasové (luma) tak i na barevnostních (chroma) plochách. Vıstup beze zmìny scény je 0.</p>
<p><var>Ysc</var> je hodnota braná maskou pøi zmìnì scény, vıchozí je 255.</p>

<h3>MShow</h3>

<p><code>MShow</code> (<var>clip super, clip vectors, int "scale", int
"sil", int "tol", bool "showsad", int "number", int "thSCD1", int "thSCD2", bool "isse", bool "planar"</var>)
</p>
<p>Zobrazuje vektory pohybu ve zdroji doplnìném pruhy otevøením superklipu (od v2.0.11).
</p>
<p><var>scale</var> umoòuje zvìtšit vektory
pohybu, napøíklad za úèelem zvıšení pøesnosti ( kdy je
<var>pel</var> &gt; 1 a <var>scale</var> = 1, neuvidíte
odchylky menší ne jeden pixel ).
</p>
<p><var>sil</var> umoní vidìt rùzné úrovnì analızy ( kdy se pøi vyhledávání
vektorù pohybu provádí hierarchická analıza, a mùe to bıt zajímavé pro pozorování
co se dìje ve vyšších úrovních ).
</p>
<p><var>tol</var> je prahová hodnota tolerance. Pokud deformace vyvolaná
vektorem pohybu vìtším ne <var>tol</var>, vektor není zobrazen.
</p>
<p><var>showsad</var> umoní zobrazit støední (pøepoèítanou na blok 8x8) SAD po kompenování
obrazu a mnoství (ThSCD1) špatnıch (ThSCD1) blokù.
</p>
<p><var>number</var> umoòuje oznaèit danı blok (jeho èíslem) bíle. Vıchozí=-1.
</p>
<p>Vıchozí jsou : <var>scale</var> = 1, <var>sil</var> = 0, <var>tol</var> =
20000 a <var>showsad</var> = false ( co zobrazí všechny vektory ).</p>

<h3>MDepan</h3>

<p>Dostává vektory pohybu, odhaduje globální pohyb a vkládá data do
vıstupního snímku ve zvláštním formátu pro plugin <code>DePan</code> (od Fizick).</p>
<p>Globální pohyb uvnitø snímku (panoramování, zoom, rotace) je odhadnut iterativní
procedurou, za pouití pouze dobrıch blokù.
</p>
<p>Odmítnuté bloky: 1) poblí okrajù snímkù; 2) s velkım SAD (podle parametru <var>thSCD1</var>
); 3) s pohybem lišícím se od sousedù nebo globálu.</p>
<p>Parametry <i>zoom</i> a <i>rot</i> pøepínají odhad zoom (pøiblíení, vzdálení)) a rotaci, <var>
pixaspect </var> je protaení pixelu (1.094 pro standardní PAL, 0.911 pro
standardní NTSC), <var>error </var>je maximální støední odchylka pohybu.</p>
<p>Vyhodnocenı globální pohyb ve snímku se pøepne na nulu pro velké chyby pohybu nebo
pøi zmìnì scény (podle parametrù <var>thSCD1, thSCD2</var> ).
</p>
<p>parametr <var>info</var> umoòuje zapsat informace o globálním pohybu pro ladìní.
</p>
<p>parametr <var>log</var> umoòuje nastavit jméno log souboru ve formátu DeShaker, Depan.</p>
<p>parametr <var>wrong</var> definuje limit pro vypnutí blokù velmi odlišnıch od sousedních.
</p>
<p>parametr <var>zerow</var> definuje váhu nulovıch vektorù pohybu (pro sníení jejich vlivu).
</p>
<p><var>range</var> - poèet pøedchozích (a také následujících) snímkù (polí) v blízkosti ádaného snímku pro odhad jejich pohybu.
</p>
<p>Vıchozí jsou : <var>zoom</var> = true, <var>rot</var> = true, <var>pixaspect</var> = 1.0,
<var>error</var> = 15.0, <var>info</var> = false, <var>wrong</var>=10, <var>zerow</var>=0.05, <var>range</var>=0.</p>
<p>Pro odhad globálního pohybu prokládaného zdroje musíte rozdìlit pole
(jak pro MAnalyse tak pro MDepan).</p>

<h3>MFlow</h3>

<p><code>MFlow</code> (<var>clip source, clip super, clip vectors, float "time", int "mode", bool "fields",
int "thSCD1", int "thSCD2", bool "isse", bool "planar"</var>)
</p>
<p>Provádí kompenzaci pohybu ve snímku ne po blocích (jako MCompensation), ale po pixelech.
Vektor pohybu pro kadı pixel je vypoèítán bilineární interpolací vektorù pohybu
aktuálních a sousedních blokù (v souladu s pozicí pixelu).
To znamená, e pixely ukázané vektorem v referenèním snímku
budou posunuty (flow - proudí) podle vektorù pro dosaení jejich umístìní v aktuálním snímku.
Tato flow motion (proudící) kompenzaèní metoda neprodukuje ádné blokové artefakty, a je dobrá pro odšumìní,
ale obèas mùe vytváøet velmi zvláštnì deformované obrazy :).
Pro tuto funkci se dùraznì doporuèuje skuteènı odhad pohybu (true motion).
Kompenzace pohybu mùe bıt úplná nebo èásteèná (v mezièase).<br>
Omezení: vektory s komponentami nad 127 budou resetovány na nulovou délku.
</p>
<p><var>super</var> (nejmennı) je víceúrovòovı superklip pøipravenı funkcí MSuper.</p>
<p><var>vectors</var> (nejmenı) je klip s daty vektorù pohybu vytvoøenı funkcí MAnalyse.</p>
<p><var>time</var>:  procento kompenzace pohybu (vıchozí=100.0, úplná kompenzace),
definuje èasovı moment mezi referenèním a aktuálním snímkem.</p>
<p><var>mode</var> mùe bıt buï 0 ( vıchozí ), nebo 1. <br>
mode=0 - pøinést pixely na kadé místo cílového snímku. Je to hlavní produkèní reim.<br>
mode=1 - posunout pixely z kadého místa zdroje (reference).
Je to ladící (uèební) reim s nìjakımi prázdnımi místy (s nulovou intensitou).
Mùe bıt pouit pro vytvoøení masky okluzí.
</p>
<p><var>fields</var>: je-li nastaven na true a <var>pel=2</var>, pak pøidáváme vhodná vertikální posunutí
 (po pùlpixelu) polí pro video zaloené na polích.
 Zkuste ho pouít pro odstranìní prokládání (ne pro odšumìní).<br>
Vıchozí je false.
</p>

<h3>MFlowInter</h3>

<p><code>MFlowInter</code> (<var>clip source, clip super, clip mvbw, clip mvfw, float "time", float "mL",
bool "blend", int "thSCD1", int "thSCD2", bool "isse", bool "planar"</var>)
</p><p>Funkce interpolace pohybu. Není stejná (ale podobná) jako funkce MVInterpolate strších verzí MVTools.
Pouívá zpìtnıch "mvbw" a dopøednıch "mvfw" vektorù pohybu
pro vytvoøení obrazu v nìjakém mezièase mezi aktuálním a následujícím (podle delta) snímkem.
Pouívá pixelovou (podle metody MFlow) kompenzaci pohybu z obou snímkù.
Vnitøní zpìtné a dopøedné masky okluze (metoda MMask <var>kind=2</var>)
a èasovì váené souèinitele jsou pouity pro vytvoøení vıstupního obrazu s minimálními artefakty.
Pro tuto funkci se dùraznì doporuèuje skuteènı odhad pohybu (true motion).</p>
<p><var>super</var> (nejmennı) je víceúrovòovı superklip pøipravenı funkcí MSuper.</p>
<p><var>mvbw, mvfw</var> (nejmenı) je klip s daty zpìtnıch a dopøednıch vektorù vektorù pohybu vytvoøenı funkcí MAnalyse.</p>
<p><var>time</var>:  pozice interpolaèního èasu mezi snímky (v procentech, vıchozí=50.0, polovièní zpùsob)</p>
<p><var>mL</var>: násobící parametr masky. Niší hodnoty odpovídají silnìjším maskám okluzí
(jako ve funkci MMask, pouijte ho pro vyladìní a odstranìní chyb). Vıchozí=100.
<p>
	<var>blend</var>: smíchá snímky na zmìnì scény jako kdy je ConvertFps true,
	nebo opakuje poslední snímek jako kdy je ChangeFps false.
	Vychozí je true.
</p>

<h3>MFlowFps</h3>

<p><code>MFlowFps</code> (<var>clip, clip "mvbw", clip "mvfw", int "num", int "den", int "mask", float "ml", clip "pelclip", int "idx"</var>)
</p><p>Zmìní frekvenci snímkù (fps) klipu (a poèet snímkù).
Funkce mùe bıt pouita pro pøevod frekvence snímkù, efekt pomalého pohybu, atd.
Pouívá zpìtnıch "mvbw" a dopøednıch "mvfw" vektorù pohybu
pro vytvoøení obrazu v nìjakém mezièase mezi snímky.
Pouívá pixelovou kompenzaci pohybu (jako MFlow, MFlowInter).
Vnitøní zpìtné a dopøedné masky okluze (metoda MMask <var>kind=2</var>)
a èasovì váené souèinitele jsou pouity pro vytvoøení vıstupního obrazu s minimálními artefakty.
Pro tuto funkci se dùraznì doporuèuje skuteènı odhad pohybu (true motion).</p>
<p><var>super</var> (nejmennı) je víceúrovòovı superklip pøipravenı funkcí MSuper.</p>
<p><var>mvbw, mvfw</var> (nejmenı) je klip s daty zpìtnıch a dopøednıch vektorù vektorù pohybu vytvoøenı funkcí MAnalyse.</p>
<p><var>num</var>:  èitatel fps vıstupního klipu. Vıchozí=25.</p>
<p><var>den</var>:  jmenovatel fps (vıchozí=1). Vısledná fps = num/den.
Pøedevším pro dvojnásobnou NTSC fps=2*29.97 pouijte <var>num</var>=60000 a <var>den</var>=1001,
a pro dvojnásobnou NTSC FILM fps=2*23.976 pouijte <var>num</var>=48000 a <var>den</var>=1001.
Kdy <var>num</var> nebo <var>den</var> je rovno 0, pak je pro vıstup brána dvojnásobná fps vstupního klipu (od v1.8.1).</p>
<p><var>mask</var>: reim masky zpracování:<br>
mask=0 jsou jednoduché zpìtné a dopøedné masky okluze (pouité ve verzích do 1.4.x, nejrychlejší);<br>
mask=1 je podobná maska s dodateènım pøepínáním na statické nulové vektory v okluzních oblastech (podobné do v1.5.x);<br>
mask=2 je pro pouití zvláštních vektorù ze sousedních snímkù pro sníení
halo efektu u objektù v okluzních oblastech (v1.8, nejpomalejší). Vıchozí=2.</p>
<p><var>ml</var>: parametr mìøítka masky. Vìtší hodnoty odpovídají slabší masce okluze
(jako ve funkci MMask, pouijte ho pro vyladìní a odstranìní chyb). Vıchozí=100.
<p>
	<var>blend</var>: smíchá snímky na zmìnì scény jako kdy je ConvertFps true,
	nebo opakuje poslední snímek jako kdy je ChangeFps false.
	Vychozí je true.
</p>


<h3>MBlockFps</h3>

<p><code>MBlockFps</code> (<var>clip, clip super, clip mvbw, clip mvfw, int "num", int "den", int "mode", float "thres",
bool "blend", int "thSCD1", int "thSCD2", bool "isse", bool "planar"</var>)
<p>Funkce pouívá èásteènou kompenzaci pohybu zaloenou na blocích
ke zmìnì frekvence snímkù (fps) klipu (a poètu snímkù).
Pouívá zpìtné "mvbw" a dopøedné "mvfw" vektory pohybu
pro vytvoøení interpolovanıch obrazù v nìjakém mezièase mezi snímky.
Pro vytvoøení vıstupního obrazu se pouívají nìkteré vnitøní zpìtné a dopøedné masky
a èasovì váené souèinitele.
(Algoritmus je zaloen na funkci MVInter starıch MVTools v1.9.12.)
Je to obvykle rychlejší ne MFlowFps , ale mùe vytváøet kostkatìní a jiné artefakty.
Pro tuto funkci se dùraznì doporuèuje skuteènı odhad pohybu (true motion).</p>
<p><var>super</var> (nejmennı) je víceúrovòovı superklip pøipravenı funkcí MSuper.</p>
<p><var>mvbw, mvfw</var> (nejmenı) je klip s daty zpìtnıch a dopøednıch vektorù vektorù pohybu vytvoøenı funkcí MAnalyse.</p>
<p><var>num</var>:  èitatel fps vıstupního klipu. Vıchozí=25.</p>
<p><var>den</var>:  jmenovatel fps (vıchozí=1). Vısledná fps = num/den.
Pøedevším pro dvojnásobnou NTSC fps=2*29.97 pouijte <var>num</var>=60000 a <var>den</var>=1001,
a pro dvojnásobnou NTSC FILM fps=2*23.976 pouijte <var>num</var>=48000 a <var>den</var>=1001.
Kdy <var>num</var> nebo <var>den</var> je rovno 0, pak je pro vıstup brána dvojnásobná fps vstupního klipu.</p>
<p><var>mode</var>: reim zpracování:<br>
0 - prùmìr dopøedné a zpìtné èásteèné kompenzace pohybu (nejrychlejší, vıchozí).<br>
1 - statickı støed.<br>
2 - dynamickı støed.<br>
3 - èasovì váená kombinace pøenesenıch dopøednıch blokù maskovanıch posunutımi zpìtnımi
a pøenesenıch zpìtnıch maskovanıch posunutımi dopøednımi.<br>
4 - reim 3 smíchanı s jednoduchım statickım èasovım prùmìrem podle masky okluze posynutıch blokù.<br>
5 - maska okluze (pro ladìní).
</p><p><var>thres</var>: prahová hodnota mnoství okluzí na blok pro binarizaci masky.
Vıchozí=0, co je vnitønì = blksize*blksizeV/4.
</p>
<p><var>blend</var>: smíchá snímky na zmìnì scény jako kdy je ConvertFps true,
	nebo opakuje poslední snímek jako kdy je ChangeFps false.
	Vychozí je true.
</p>

	<h3>MFlowBlur</h3>

<p><code>MFlowBlur</code> (<var>clip, clip super, clip mvbw, clip mvfw, float "blur", int "prec",
int "thSCD1", int "thSCD2", bool "isse", bool "planar"</var>)
<p>Experimentální jednoduchá funkce rozmazání pohybu. Mùe bıt pouita pro FILM-efekt (simulaci konce otevøení závìrky kamery).
Pouívá zpìtné "mvbw" a dopøedné "mvfw" vektory pohybu
pro vytvoøení a pøekrytí mnoha kopií èásteènì kompenzovanıch pixelù
v mezièase v nìjakém intervalu rozmazání (blurring) kolem aktuálního snímku.
Pouívá pixelovou kompenzaci pohybu (jako MFlow).
Pro tuto funkci se dùraznì doporuèuje skuteènı odhad pohybu (true motion).</p>
<p><var>super</var> (nejmennı) je víceúrovòovı superklip pøipravenı funkcí MSuper.</p>
<p><var>mvbw, mvfw</var> (nejmenı) je klip s daty zpìtnıch a dopøednıch vektorù vektorù pohybu vytvoøenı funkcí MAnalyse.</p>
<p><var>blur</var>: èasovı interval rozmazání (blur) mezi snímky, èas otevøení závìrky (v procentech, vıchozí=50.0)</p>
<p><var>prec</var>: pøesnost rozmazání v jednotkách pixelù. Maximální krok mezi kompenzovanımi rozmazanımi pixely. Vıchozí =1 (nejpøesnìjší).
</p>

<h3>MDeGrain1, MDeGrain2 and MDegrain3</h3>

<p><code>MDeGrain1</code> (<var>clip, clip super, clip mvbw, clip mvfw, int "thSAD", int "thSADC", int "plane", int "limit",
int "thSCD1", int "thSCD2", bool "isse", bool "planar"</var>)</p>
<p><code>MDeGrain2</code> (<var>clip, clip super, clip mvbw, clip mvfw, clip mvbw2, clip mvfw2, int "thSAD", int "thSADC", int "plane", int "limit",
int "thSCD1", int "thSCD2", bool "isse", bool "planar"</var>)</p>
<p><code>MDeGrain3</code> (<var>clip, clip super, clip mvbw, clip mvfw, clip mvbw2, clip mvfw2,
   clip mvbw3, clip mvfw3,int "thSAD", int "thSADC", int "plane", int "limit",
   int "thSCD1", int "thSCD2", bool "isse", bool "planar"</var>)</p>
<p>Provádí èasové (temporal) odšumìní s kompenzací pohybu.
Bloky pøedchozích a následujících snímkù jsou pohybovì kompenzovány a pak zprùmìrovány s aktuálním snímkem
s váenımi souèinitely závislımi na rozdílech blokù od aktuálního (SAD). Funkce podporují reim pøekrıvání blokù.
</p><p>Zpracování pøekrıvajících se blokù je implementována jako okenní sumarizace blokù
(jako FFT3DFilter, hodnoty pøekrytí do blksize/2) pro sníení artefaktù kostkatìní.
</p>
<p>MDeGrain1 má èasovı (temporal) rádius 1 (pouívá vektory pøedchozího <var>mvfw</var> a následujícího <var>mvbw</var> snímku).</p>
MDeGrain2 má èasovı (temporal) rádius 2 (pouívá vektory dvou pøedchozích <var>mvfw2, mvfw</var> a dvou následujících <var>mvbw,mvbw2</var> snímkù).
MDeGrain3 má èasovı (temporal) rádius 3 (pouívá vektory tøí pøedchozích <var>mvfw3, mvfw2, mvfw</var> a tøí následujících <var>mvbw, mvbw2, mvbw3</var> snímkù).
Je to pomalejší, ale produkuje trochu lepší vısledky (silnìjší odšumìní).</p>
<p><var>super</var> (nejmennı) je víceúrovòovı superklip pøipravenı funkcí MSuper.</p>
<p><var>mvbw, mvfw</var> (nejmenı) je klip s daty zpìtnıch a dopøednıch vektorù vektorù pohybu vytvoøenı funkcí MAnalyse.</p>
<p>parametr <var>"thSAD"</var> definuje mìkkou prahovou hodnotu souètu absolutních rozdílù bloku.
Blok se SAD nad prahovou hodnotou <var>thSAD</var> má nulovou váhu pøi prùmìrování (odšumìní).
Blok s nízkou hodnotou SAD má nejvìtší váhu. Zbytek váhy se bere z pixelù zdrojového klipu.
Musíte zadat hodnotu <var>thSAD</var> redukovanou na velikost bloku 8x8.
Nízké hodnoty mohou vést k šachovnicovému odšumìní, velké hodnoty mohou vést k duchùm a artefaktùm.
<br>
Vıchozí <var>thSAD</var>=400.</p>
<p><var>"thSADC"</var> je prahová hodnota pro plochy barevnosti (chroma).<br>
Vıchozí (není-li zadána) : <var>thSADC</var>=<var>thSAD</var>.
Pokud je zadána pak <var>thSADC</var>je pouito pro barevnost a <var>thSAD</var> je pouito pro jas (luma).</p>
<p>parametr <var>plane</var> nastavuje zpracovanou barevnou plochu:<br>
0 - jas, 1 - barevnost U, 2 - barevnost V, 3 - obì barevné roviny, 4 - vše. Vıchozí je 4.
</p>
<p><var>limit</var>: maximální zmìna pixelu (jako plugin DeGrainMedian pro zabránìní nìkterım artefaktùm).
Vıchozí je 255 (bez omezení).
</p>

<h3>MRecalculate</h3>

<p><code>MRecalculate</code> (<var>clip super, clip vectors, int "thSAD", int "smooth", int "blksize", int "blksizeV",
int "search", int "searchparam", int "lambda", bool "chroma",
bool "truemotion", int "pnew", int "overlap", int "overlapV",
string "outfile", int "dct", int "divide", bool "mc", int "sadx264", bool "isse", bool "planar"</var>)
</p>
<p>Upøesòuje a pøepoèítává døíve odhadnutá (z MAnalyse) data vektorù pohybu  <var>vectors</var>
pro jinı klip <var>super</var> nebo nastavení novıch parametrù (napø. menší velikost bloku), po dìlení, atd.
Tato dvou fázová metoda mùe bıt také uiteèná pro stabilnìjší (robustnìjší) odhad pohybu.
Upøesnìní se provádí jen na nejjemnìjší hierarchické úrovni.
Interpolované vektory starıch blokù jsou pouity jako prediktory pro nové vektory, s pøepoètem SAD.
Jen nové vektory špatné kvality se SAD vyšší ne prahová hodnota <var>thSAD</var> budou znovu odhadnuty vyhledáváním.
Zadávejte hodnotu <var>thSAD</var> redukovanou (násobenou) na velikost bloku 8x8. Vıchozí <var>thSAD</var>=200.
Dobré vektory jsou nezmìnìny, ale jejich SAD bude aktualizováno (pøepoèítáno).
</p>
<p><var>smooth</var> je metoda jak rozdìlit hrubé bloky na menší.
0 - pouije pohyb na nejbliší blok, 1 - bilineární interpolace 4 sousedù. Vıchozí 1.</p>
<p>Další parametry mají stejnı vıznam jako v MAnalyse (ale mùete pouít jiné hodnoty).
</p>


<h2><a name="examples"></a>III) Pøíklady
</h2>

<p>Zobrazení vektorù pohybu ( dopøednıch ) :
</p>
<pre>AVISource("c:\test.avi") # nebo MPEG2Source, DirectShowSource, nìkterı pøedchozí filtr, atd.
vectors = MSuper().MAnalyse(isb = false)
MShow(vectors) # implicitní last pracuje správnì</pre>

<p>Zobrazení zpìtnıch vektorù :
</p>
<pre>AVISource("c:\test.avi") # nebo MPEG2Source, DirectShowSource, nìkterı pøedchozí filtr, atd.
vectors = MSuper().MAnalyse(isb = true)
MShow(vectors)</pre>

<p>Pouití MMask :
</p>
<pre>AVISource("c:\test.avi") # nebo MPEG2Source, DirectShowSource, nìkterı pøedchozí filtr, atd.
vectors = MSuper().MAnalyse(isb = false)
MMask(vectors)</pre>

<p>Pouití MDepan s pluginem <a href="depan.htm">Depan</a> pro prokládanı zdroj
 (pøíklad funkce DepanStabilize):</p>
<pre>AVISource("c:\test.avi") # nebo MPEG2Source, DirectShowSource, nìkterı pøedchozí filtr, atd.
AssumeTFF().SeparateFields() # nastavení správného poøadí polí
vectors = MSuper().MAnalyse(isb = false)
globalmotion = MDepan(vectors, pixaspect=1.094, thSCD1=400)
DepanStabilize(data=globalmotion, cutoff=2.0, mirror=15, pixaspect=1.094)
Weave()
</pre>

<p>Rozmazání problémovıch (kostkatıch) oblastí kompenzovanıch snímkù s maskou okluze:</p>
<pre>AVISource("c:\test.avi") # nebo MPEG2Source, DirectShowSource, nìkterı pøedchozí filtr, atd.
super = MSuper()
vectors = MAnalyse(super, isb = false)
compensation = MCompensate(super,vectors) # nebo zde pouijte funkci MFlow
# pøipravíme rozmazanı snímek s nìjakou silnou funkcí rozmazání nebo deblokování:
blurred = compensation.DeBlock(quant=51) # pouijeme zde funkci DeBlock
badmask = MMask(vectors, kind = 2, ml=50)
overlay(compensation,blurred,mask=badmask) # nebo pouijeme rychlejší funkci MaskedMerge z MaskTools
</pre>

<p>Nové vytvoøení špatnıch snímkù interpolací pomocí MFlowInter:</p>
<pre>AVISource("c:\test.avi") # nebo MPEG2Source, DirectShowSource, nìkterı pøedchozí filtr, atd.
super = MSuper()
backward_vectors = MAnalyse(super, isb = true, delta=2)
forward_vectors = MAnalyse(super, isb = false, delta=2)
inter = MFlowInter(super, backward_vectors, forward_vectors, time=50, ml=70)
# Pøedpokládejme, e špatné snímky jsou 50 a 60
trim(0,49) ++ inter.trim(49,-1) \
 ++ trim(51,59) ++ inter.trim(59,-1) ++ trim(61,0)
</pre>

<p>Zmìna fps pomocí MFlowFps:</p>
<pre>AVISource("c:\test.avi") # nebo MPEG2Source, DirectShowSource, nìkterı pøedchozí filtr, atd.
# Pøedpokládáme progresivní zdroj PAL 25 fps
super = MSuper(pel=2)
backward_vec = MAnalyse(super, isb = true)
forward_vec = MAnalyse(super, isb = false)
MFlowFps(super, backward_vec, forward_vec, num=50, den=1, ml=100) # získáme 50 fps
</pre>

<p>Zdvojnásobení fps pomocí MFlowFps pro nejrychlejší (témìø) k pøehrávání v reálném èase</p>
<pre>AVISource("c:\test.avi") # nebo MPEG2Source, DirectShowSource, nìkterı pøedchozí filtr, atd.
# Pøedpokládáme progresivní zdroj PAL 25 fps nebo NTSC Film 23.976
super = MSuper(pel=1,hpad=16,vpad=16)
backward_vec = MAnalyse(super, blksize=16, isb = true, chroma=false, searchparam=1)
forward_vec = MAnalyse(super, blksize=16, isb = false, chroma=false, searchparam=1)
MFlowFps(super, backward_vec, forward_vec, num=2*FramerateNumerator(last), \
   den=FramerateDenominator(last), mask=0)
</pre>

<p>Zdvojnásobení fps pomocí MFlowFps pro 'nejlepší' vısledky (ale pomalejší zpracování):</p>
<pre>AVISource("c:\test.avi") # nebo MPEG2Source, DirectShowSource, nìkterı pøedchozí filtr, atd.
# Pøedpokládáme progresivní zdroj PAL 25 fps nebo NTSC Film 23.976
super = MSuper(pel=2)
backward_vec = MAnalyse(super, overlap=4, isb = true, search=3)
# pouijeme pøekrıvání blokù, pøesnost na pùl pixelu a Vyèerpávající vyhledávání
forward_vec = MAnalyse(super, overlap=4, isb = false, search=3)
MFlowFps(super, backward_vec, forward_vec, num=2*FramerateNumerator(last), \
   den=FramerateDenominator(last))
</pre>

<p>Generování pìkného rozmazání pohybu pomocí MFlowBlur:</p>
<pre>AVISource("c:\test.avi") # nebo MPEG2Source, DirectShowSource, nìkterı pøedchozí filtr, atd.
super = MSuper()
backward_vectors = MAnalyse(super, isb = true)
forward_vectors = MAnalyse(super, isb = false)
MFlowBlur(super, backward_vectors, forward_vectors, blur=15)
</pre>

<p>Odšumìní pomocí nìjakého externího filtru pro odstranìní šumu (kterı pouívá 3 snímky: pøedchozí, aktuální, následující):</p>
<pre>AVISource("c:\test.avi") # nebo MPEG2Source, DirectShowSource, nìkterı pøedchozí filtr, atd.
super = MSuper()
backward_vectors = MAnalyse(super, isb = true)
forward_vectors = MAnalyse(super, isb = false)
forward_compensation = MFlow(super, forward_vectors, thSCD1=500) # nebo pouijte MCompensate
backward_compensation = MFlow(super, backward_vectors, thSCD1=500)
# vytvoøíme postupné 3-snímkové sekvence
interleave(forward_compensation, last, backward_compensation)

DeGrainMedian() # umístìte sem váš oblíbenı èasovı nebo èasovì-prostorovı (temporal nebo spatial-temporal) odšumovaè

selectevery(3,1) # vrací jen filtrované centrální (nekompenzované) snímky
</pre>

<p>Pouití pøedfiltrovaného klipu pro spolehlivìjší odhad pohybu,
ale kompenzaci pohybu nepøedfiltrovaného klipu (pøíklad odšumìní)</p>

<pre>AVISource("c:\test.avi") # nebo MPEG2Source, DirectShowSource, nìkterı pøedchozí filtr, atd.
# Pouijte nìkterı odšumovaè (rozmazávaè) nebo odstraòovaè blikání (deflicker) pro pøedfiltrování
prefiltered = blur(1.0)
super = MSuper(levels=1) # jedna úroveò je pro MCompensate dostaèující
superfilt = MSuper(prefiltered) # všechny úrovnì pro MAnalyse
backward_vectors = MAnalyse(superfilt, isb = true)
forward_vectors = MAnalyse(superfilt, isb = false)
# pouijeme nepøedfiltrovanı (super) klip pro kompenzaci pohybu
forward_compensation = MCompensate(super, forward_vectors)
backward_compensation = MCompensate(super, backward_vectors)
# vytvoøíme postupné 3-snímkové sekvence
interleave(forward_compensation, last, backward_compensation)

DeGrainMedian() # umístìte sem váš oblíbenı èasovı nebo èasovì-prostorovı (temporal nebo spatial-temporal) odšumovaè

selectevery(3,1) # vrací jen filtrované centrální (nekompenzované) snímky
</pre>

<p>Odšumìní pomocí MDegrain2 s pøekrytımi bloky (blksize=8) a subpixelovou pøesností:</p>
<pre>AVISource("c:\test.avi") # nebo MPEG2Source, DirectShowSource, nìkterı pøedchozí filtr, atd.
super = MSuper(pel=2, sharp=1)
backward_vec2 = MAnalyse(super, isb = true, delta = 2, overlap=4)
backward_vec1 = MAnalyse(super, isb = true, delta = 1, overlap=4)
forward_vec1 = MAnalyse(super, isb = false, delta = 1, overlap=4)
forward_vec2 = MAnalyse(super, isb = false, delta = 2, overlap=4)
MDegrain2(super, backward_vec1,forward_vec1,backward_vec2,forward_vec2,thSAD=400)</pre>

<p>Odšumìní prokládaného zdroje pomocí MDegrain1 s pøekrıvajícími se bloky (blksize=8) a subpixelovou pøesností:</p>
<pre>AVISource("c:\test.avi") # nebo MPEG2Source, DirectShowSource, nìkterı pøedchozí filtr, atd.
fields=AssumeTFF().SeparateFields() # nebo AssumeBFF
super = MSuper(fields)
backward_vec2 = MAnalyse(super, isb = true, delta = 2, overlap=2)
forward_vec2 = MAnalyse(super, isb = false, delta = 2, overlap=2)
MDegrain1(fields, super, backward_vec2,forward_vec2,thSAD=400)
Weave()</pre>

<p>Odšumìní prokládaného zdroje pomocí funkce  MDegrain2i2:</p>
<pre>function MDegrain2i2(clip source, int "overlap", int "dct")
{
overlap=default(overlap,0) # hodnota pøekrytí (0 a 4 pro blksize=8)
dct=default(dct,0) # pouijte dct=1 pro klip se slabım blikáním
fields=source.SeparateFields() # rozdìlíme pole
super = fields.MSuper()
backward_vec2 = super.MAnalyse(isb = true, delta = 2, overlap=overlap, dct=dct)
forward_vec2 = super.MAnalyse(isb = false, delta = 2, overlap=overlap, dct=dct)
backward_vec4 = super.MAnalyse(isb = true, delta = 4, overlap=overlap, dct=dct)
forward_vec4 = super.MAnalyse(isb = false, delta = 4, overlap=overlap, dct=dct)
fields.MDegrain2(super, backward_vec2,forward_vec2,backward_vec4,forward_vec4,thSAD=400)
Weave()
}

AVISource("video.avi")
mvdegrain2i2(4,0)
</pre>

<p>Jak pouít externí klip subpixelové interpolace::</p>
<pre># Naètìte plugin Eedi2 (<a href="http://bengal.missouri.edu/~kes25c/">by tritical</a>) s funkcí interpolace se zohlednìním smìrù obrysù
LoadPlugin("Eedi2.dll")
AVISource("c:\test.avi") # nebo MPEG2Source, DirectShowSource, nìkterı pøedchozí filtr, atd.
# vytvoøíme ze zdroje nadvzorkovanı klip
ups = EEDI2(field=1).LanczosResize(2*width(last), 2*height(last), src_left=0.25)
super = MSuper(pel=2, pelclip=ups)
bv = MAnalyse(super, isb = true, overlap=4)
MCompensate(super, bv)
</pre>

<p>Jak pouít s MT filtrem a speciální <a href="http://forum.doom9.org/showthread.php?t=94996">vícevláknovou verzí AviSynthu</a>:</p>
<pre># Naètìte MT plugin od TSP
LoadPlugin("MT.dll")
avisource("some.avi")
MT("""
super = MSuper(pel=2, sharp=1)
backward_vec2 = super.MAnalyse(isb = true, delta = 2, overlap=4)
backward_vec1 = super.MAnalyse(isb = true, delta = 1, overlap=4)
forward_vec1 = super.MAnalyse(isb = false, delta = 1, overlap=4)
forward_vec2 = super.MAnalyse(isb = false, delta = 2, overlap=4)
MDegrain2(super, backward_vec1,forward_vec1,backward_vec2,forward_vec2,thSAD=400)
""",2) # dvì vlákna
</pre>
<p>Poznámka: Reim SetMTMode(2) vícevláknového AviSynthu je podporován od MVTools v.1.8.4.1 (beta testing).
MVtools verze 2 by mìla pracovat stabilnìji.
Stejnı pøíklad se SetMTMode:</p>
<pre>SetMTMode(5)
FFmpegSource("some.avi") # avisource nepracuje se SetMTMode na mém stroji - TSchniede

SetMTMode(2)
super = MSuper(pel=2)
backward_vec2 = MAnalyse(super, isb = true, delta = 2, overlap=4)
backward_vec1 = MAnalyse(super, isb = true, delta = 1, overlap=4)
forward_vec1 = MAnalyse(super, isb = false, delta = 1, overlap=4)
forward_vec2 = MAnalyse(super, isb = false, delta = 2, overlap=4)
MDegrain2(super, backward_vec1,forward_vec1,backward_vec2,forward_vec2,thSAD=400)
</pre>

<p>Jak pouít pøedfiltrovanı klip a pøepoèítat data pohybu pùvodního zdroje (MFlowFPS pøíklad)</p>
<pre>AVISource("c:\test.avi") # nebo MPEG2Source, DirectShowSource, nìkterı pøedchozí filtr, atd.
prefiltered = DeGrainMedian() # trocha vyhlazení
super = MSuper(hpad=16, vpad=16, levels=1) # jedna úroveò pro MRecalculate staèí
superfilt = MSuper(prefiltered, hpad=16, vpad=16) # všechny úrovnì pro MAnalyse
backward = MAnalyse(superfilt, isb = true, blksize=16)
forward = MAnalyse(superfilt, isb = false, blksize=16)
# pøepoèítání pùvodního zdrojového klipu s jinou velikostí bloku
forward_re = MRecalculate(super, forward, blksize=8, thSAD=100)
backward_re = MRecalculate(super, backward, blksize=8, thSAD=100)
MFlowFps(super, backward_re, forward_re, num=50, den=1)</pre>

<p>Jak pouít monost planar pro rychlejší zpracování YUY2 (pøíklad MDegrain3):</p>
<pre>LoadPlugin("RemovegrainS.dll") # pro pøevod funkcí
AVISource("c:\test.avi") # nebo MPEG2Source, DirectShowSource, nìkterı pøedchozí filtr, atd.
Interleaved2Planar() # pøevede klip na planární
super = MSuper(planar=true)
bv1 = MAnalyse(super, isb = true, delta = 1, overlap=4)
fv1 = MAnalyse(super, isb = false, delta = 1, overlap=4)
bv2 = MAnalyse(super, isb = true, delta = 2, overlap=4)
fv2 = MAnalyse(super, isb = false, delta = 2, overlap=4)
bv3 = MAnalyse(super, isb = true, delta = 3, overlap=4)
fv3 = MAnalyse(super, isb = false, delta = 3, overlap=4)
MDegrain3(super,bv1,fv1,bv2,fv2,bv3,fw3,thSAD=400,planar=true)
Planar2Interleaved() # pøevede zpìt na normální prolínané YUY2
</pre>

<h2><a name="disclaimer"></a>IV) Odmítnutí záruk
</h2>
<p>Tento plugin je šíøen za podmínek GNU GPL licence, bez jakıchkoli záruk. Viz. 'gpl.txt'.<br>
Dokumentace je šíøena pod <a href="http://creativecommons.org/licenses/by-sa/3.0/">CreativeCommons BY-SA 3.0 license.</a><br>
</p><p>Zvate prosím provedení nìjaké <a href="http://avisynth.org.ru/donate.html">dotace</a> pro podporu.</p>
<p>MVTools pouívají èásti kódu z následujících projektù:<br>
Resizer (SimpleResize.cpp) je z Avisynth pluginu SimpleResize od Toma Barryho. http://www.trbarry.com<br>
Fast DCT (fdct_mmx.asm) je z XVID MPEG-4 VIDEO KODEKU. http://www.xvid.org<br>
DCT general transform (viz. fftwlite.h) je z FFTW knihovny (jako DLL vızva). http://www.fftw.org<br>
Satd. (pixel-32.asm, pixel.asm) a alternative SADx264 (sad-a.asm,
x86inc.asm, x86inc-32.asm, cpu-32.asm) jsou z projektu x264.
http://www.videolan.org/developers/x264.html
(Loren Merritt, Laurent Aimar, Alex Izvorski et al).
</p>

<h2><a name="revisions"></a>V) Revize
</h2>
<p>2.4.2 (07.04.2009 by Fizick)</p>
<ul>
<li>MAnalyze: Fixed valid vector range for case of padding lesser than block size, with program crash (thanks to FuPP for bug report).</li>
</ul>
<p>2.4.1 beta (24.01.2009 by Fizick)</p>
<ul>
<li>MDegrain: Fixed weight for hight threshold and big block size.</li>
</ul>
<p>2.4.0 beta (09.01.2009 by Fizick)</p>
<ul>
<li>MDegrain: Changed degrain weight method to more strong, some internal rewriting.</li>
<li>Fixed documenation.</li>
</ul>
<p>2.3.1 (14.12.2008 by Fizick)</p>
<ul>
<li>MSuper: added more smoothing reducing filters rfilter=2,3,4, by default 2.</li>
<li>MAnalyse: fixed bug with plevel parameter (version 2.3.0).</li>
</ul>
<p>2.3.0 (6.12.2008 by Fizick)</p>
<ul>
<li>Renamed all functions from MVxxx to Mxxx (some renaming was requested by LaTo, Mystery Keeper, Sagekilla).
Error messages is still not updated.</li>
<li>MAnalyse: added pglobal parameter (with small changes), changed default level=1.</li>
</ul>
<p>2.2.2 (30.11.2008 by Fizick)</p>
<ul>
<li>MVShow: changes SAD by reduced to block size 8x8, added quantity of bad blocks.</li>
<li>MVCompensate: fixed bug at scene changes (thanks to AVIL for bug report about YUY2).</li>
<li>MVAnalyse: fixed chroma=false (thanks to LaTo for bug report).</li>
<li>Renamed to mvtools2.dll (requested by Naito).</li>
</ul>
<p>2.2.1 (27.11.2008 by Fizick)</p>
<ul>
<li>MVAnalyse: fixed wrong scaling of LSAD to block size (thanks to Shon for bug report).</li>
<li>MVCompensate: removed mode parameter, added recursion.</li>
</ul>
<p>2.1.2 (23.11.2008 by Fizick)</p>
<ul>
<li>MVAnalyse: removed option mc. Reduced size of block data (increment version of vector stream).</li>
<li>MVDegrain: fixed bug with block size 32x16</li>
</ul>
<p>2.1.1 (18.11.2008 by Fizick)</p>
<ul>
<li>MVBlockFps: fixed left border bug</li>
</ul>
<p>2.1.0 (8.11.2008 by Fizick)</p>
<ul>
<li>MVFlowFps, MVBlockFps, MVFlowInter: added blend parameter for ChangeFps-like mode at scene changes</li>
<li>MVFlowFps, MVBlockFps: more safe for big nominator and denominator.</li>
</ul>
<p>2.0.11.2 (6.11.2008 by Fizick)</p>
<ul>
<li>MVDegrain2,3: fixed crashes at scene changes for YUY2</li>
</ul>
<p>2.0.11.1 (5.11.2008 by Fizick)</p>
<ul>
<li>MVAnalyse: added second wide search for bad blocks (badSAD, badrange parameters).</li>
<li>MVAnalyse: added Hexagon and Uneven Multi Hexagon (UMH) search types.
Changed (not intentionally :) the default method from Logarithmic to Hexagon.</li>
<li>MVAnalyse: fixed exhaustive search to static center.</li>
<li>MVAnalyse: lsad is now scaled to blksize 8.</li>
<li>MVShow: use super clip, padded output, added number block option.</li>
</ul>
<p>2.0.9.2 (3.11.2008 by Fizick)</p>
<ul>
<li>Some performance improving</li>
</ul>
<p>2.0.9.1 (20.10.2008 by Fizick)</p>
<ul>
<li>More memory-optimal MVFlowXXX functions for pel=1</li>
<li>Disabled plugin debug mode</li>
<li>Added Russian documentation</li>
</ul>
<p>2.0.9.0 alpha (13.10.2008 by Fizick)</p>
<ul>
<li>Implemented more functions without idx: MVSCDetection, MVDepan, MVFlowInter, MVBlockFps, MVFlowBlur, MVDegrain3, MVRecalculate</li>
<li>Fixed crashes with MVSuper(chroma=false)</li>
<li>Some small changes and fixes for v2.0 of course :)</li>
<li>Documentation for v2.0</li>
</ul>
<p>2.0.7.0 alpha (02.10.2008 by Fizick)</p>
<ul>
<li>Implemented functions without idx: MVSuper, MVAnalyse, MVFlowFps, MVFlow,
MVCompensate, MVShow, MVMask, MVDegrain1, MVDegrain2</li>
<li>All functions (besides MVAnalyse) got planar parameter for YUY2 planar input and output.
Default = false (i.e. normal interleaved YUY2), slower.</li>
<li>All (mandatory) clip parameters lost their names, and mvbw=vb is not correct syntax now.
Use unnamed syntax instead. </li>
</ul>
<p>2.0.0.3 alpha (28.09.2008 by Fizick)</p>
<ul>
<li>First 2.0 branch public alpha with MVSuper function to kill idx.</li>
<li>MVAnalyse and MVDegrain1 are implemented only.</li>
</ul>
<small>
<p>1.11.4.4 (15.10.2008 by Fizick)</p>
<ul>
<li>Restore old internal cache size growing as before v1.11.4.2 (some crashes reported).</li>
</ul>
<p>1.11.4.3 (08.10.2008 by Fizick)</p>
<ul>
<li>MVDenoise: fixed error of v.1.11.4 with luma correction.</li>
<li>MVCompensate: fix potential memory leakage (in constructor).</li>
</ul>
<p>1.11.4.2 (26.09.2008 by Fizick)</p>
<ul>
<li>MVAnalyse: cut unused compensation memory space from vector clip (mc parameter).</li>
<li>Decreased internal cache size growing.</li>
<li>All MVFlow functions: fixed old bug with pixels for pel=4.</li>
<li>MVAnalyse: added rfilter parameter (smooth method).</li>
<li>MVBlockFps: added YUY2 and pelclip support.</li>
<li>Tiny stability fixes for MT.</li>
</ul>
<p>1.11.0.1 beta (08.09.2008 by Fizick)</p>
<ul>
<li>New MVBlockFps for simple fps change (almost realtime :-).</li>
<li>MVAnalyse: more smooth method of frame hierarchical level reducing (like ReduceBy2) for smoothing at every level.</li>
<li>MVAnalyse: Added pzero parameter of zero vector cost for more coherent motion vectors (now switched ON by default, set to 0 if you need in old algo).</li>
<li>MVAnalyse: Decreased pelsearch internal clipping from pel to 1 (asked by somebody for speed).</li>
<li>MVFlowFps,MVFlowFps2, MVFlowInter: removed thSAD parameter.</li>
<li>All functions: Removed mmx parameter.</li>
</ul>
<p>1.10.2.1 (28.08.2008 by Fizick)</p>
<ul>
<li>MVDegrain1-3: fixed old rounding error resulted in some chroma tint
(some thanks to Didee for bugreport, but it could be more persevering in official MVTools forum thread :)</li>
<li>Made doc about pelclip more accurate (hopely).</li>
</ul>
<p>1.10.2.0 beta (27.08.2008 by Fizick)</p>
<ul>
<li>Debugged and renamed MVRefine back to new MVRecalculate :).</li>
<li>MVAnalyse: changed LSAD threshold from hard by soft for a little more coherent motion at bad areas.</li>
<li>MVAnalyse: fixed old bug for (rarely used) different horizontal and vertical overlap sizes.</li>
</ul>
<p>1.10.1.0 not public (22.08.2008 by Fizick)</p>
<ul>
<li>Change MVRecalculate by more general function (MVRefine) which can re-estimate vectors.</li>
</ul>
<p>1.10.0.0 not public (18.08.2008 by Fizick)</p>
<ul>
<li>Added MVRecalculate function to update SAD (as requested by Didee).</li>
<li>Fixed possible memory leaks (thanks to josey_wells for note)</li>
<li>Other changes of v1.9.6-1.9.7 branch by josey_wells are still not merged -
 too many work to analyse new code and numerous cosmetic rewriting,
 so based on v1.9.5.7</li>
</ul>
<p>1.9.6.x-1.9.7.x series branch (01.08.2008-26.08.2008 by josey_wells)</p>
<ul>
<li>Added MVAnalyseMulti, MVDegrain, MVMultiExtract functions with internal multitheading
(that does not require any special AviSynth, SetMTMode or MT) </li>
<li>Some bug fixes (memory leaks), code consolidation (rewriting) for stability and performance improvements.
Also there is a multitude of changes due to the addition of threading class,
semaphore class, critical section class, thread files for MVDegrain, MVAnalyseMulti
as well as factoring out common code for MVDegrain into a single base class moving out common code etc.
There are no changes of algorithms.
See <a href="http://forum.doom9.org/showthread.php?t=84770">messages at forum</a> since August 2008 for download, syntax and discussion.</li>
</ul>
<p>1.9.5.7 public beta (03.07.2008 by Fizick)</p>
<ul>
<li>Fixed Overlap_2xY_mmx</li>
<li>Added (incomplete?) list of used projects to doc.</li>
</ul>
<p>1.9.5.6 (02.07.2008 by TSchniede)</p>
<ul>
<li>Improved my, added Overlap_2xY_mmx, optimized CheckMV2 and LumaSAD.</li>
</ul>
<p>1.9.5.5 (28.06.2008 by TSchniede)</p>
<ul>
<li>Improved default 2xY SAD and added new faster 2xY SAD.</li>
</ul>
<p>1.9.5.4 (27.06.2008 by TSchniede)</p>
<ul>
<li>Ported CPU detection from x264.</li>
<li>Now using x264 SAD autoddetect is default</li>
<li>Merge with 1.9.5.1, re-enabled 32x16 mode (only default functions)</li>
</ul>
<p>1.9.5.3 (26.06.2008 by TSchniede)</p>
<ul>
<li>Imported SSD and SATD functions.</li>
<li>access using sadx264 > 7 or dct > 4.</li>
</ul>
<p>1.9.5.2 (24.06.2008 by TSchniede)</p>
<ul>
<li>Buffered source block in aligned area before calculating SAD.</li>
<li>This fixes crashes if source block was unaligned due to overlaped blocks.</li>
<li>Worst case was &lt; 1% slower, most of the time it further increases performance.</li>
</ul>
<p>1.9.5.1 public beta (21.06.2008 by Fizick)</p>
<ul>
<li>Merge v.1.9.5 changes by TSchniede.</li>
</ul>
<p>1.9.5 (21.06.2008 by TSchniede), based on v.1.9.3</p>
<ul>
<li>MVAnalyse: added sadx264 option.</li>
<li>Internal modifications - aligned memory of luma&chroma planes and modified MVTools to the interface of the SAD functions used in x264.</li>
<li>minor bugfix (deactivate DebugPrint possible)</li>
</ul>
<p>1.9.4.1 beta (12.06.2008 by Fizick, released 21.06.2008)</p>
<ul>
<li>Fixed bug for pel=4 with sharp=2 (thanks to Pustovetov for report and fix).</li>
<li>MVCompensate: added block size 16x2 (bug reported by AVIL).</li>
</ul>
<p>1.9.4 not public beta (08.06.2008 by Fizick)</p>
<ul>
<li>MVAnalyse and other: added block size 32x16 (requested by MAG79).</li>
</ul>
<p>1.9.3.1 (05.06.2008 by Fizick)</p>
<ul>
<li>MVIncrease: was broken (as noted by MAG79).</li>
</ul>
<p>1.9.3 (20.04.2008 by Fizick)</p>
<ul>
<li>MVAnalyse: fixed bug for pelclip (broken since v1.8.5).</li>
<li>MVDegrain: added thSADC as chroma threshold (request by Terranigma).</li>
</ul>
<p>1.9.2 (29.01.2008, all bugs were found by josey_wells)</p>
<ul>
<li>MVDegrain3: fixed bug in code for 16x8 block; fix typo (MVDegrain2 instead of MVDegrain3).</li>
<li>MVAnalyse: fixed old bug in NStepSearch.</li>
</ul>
<p>1.9.1 beta (15.12.2007 by Fizick)</p>
<ul>
<li>MVAnalyse: Increased speed (by 20%) of global motion estimation (other algo).</li>
<li>MVAnalyse: Added assembler optimization for small blocksizes SAD (speed by 50%).</li>
<li>MVMask: Added kind=5 motion colormap as x,y components of motion vector shown in U, V color planes.</li>
</ul>
<p>1.9.0 (04.12.2007 by Fizick)</p>
<ul>
<li>Added MVDegrain3.</li>
</ul>
<p>1.8.6 (02.12.2007 by Fizick)</p>
<ul>
<li>Added components x,y motion vector mask kind=3,4 to MVMask (requested by Terka).</li>
</ul>
<p>1.8.5.1 (12.11.2007 by we:)</p>
<ul>
<li>Merge v1.8.4.3 and v1.8.5 changes, added MT example.</li>
</ul>
<p>1.8.4.3 (05.10.2007 by Tsp)</p>
<ul>
<li>Implemented internal cache buffer miss detection with buffer growing (as suggested by IanB).</li>
</ul>
<p>1.8.5 (05.11.2007 by Fizick)</p>
<ul>
<li>Added pelsearch parameter as search parameter (radius) at finest level (request by Terranigma).</li>
<li>Decreased internal buffer to decrease memory usage, with some changes in critical sections.</li>
<li>Added block size 16x2 (requested by ab_99).</li>
</ul>
<p>1.8.4.2 (25.10.2007 by Tsp)</p>
<ul>
<li>Added critical section in frame refining to fix rare bug in multi-threaded processing.</li>
</ul>
<p>1.8.4.1 (23.10.2007 by Tsp)</p>
<ul>
<li>Implemented thread-safe internal buffer access
for correct multithreaded processing with SetMTmode(2) in Avisynth MT version (for multi CPU).</li>
</ul>
<p>1.8.4 (22.08.2007 by Fizick)</p>
<ul>
<li>"divide" now works with "overlap".</li>
</ul>
<p>1.8.3 (17-20.08.2007 by Fizick)</p>
<ul>
<li>MVFlowFps: renamed "mode" parameter to "mask".</li>
<li>MVFlowFps2: added "mask" parameter.</li>
<li>MVFlowFPS, MVFlowFPS2: Restored default values num=25, den=1 (as was in version 1.7 and early)</li>
<li>MVDegrain1, MVGegrain2 - added "limit" parameter.</li>
</ul>
<p>1.8.2 beta (30.07.2007 by Fizick)</p>
<ul>
<li>MVAnalyse: corrected (increased) search radius at finest level for pel>1.</li>
<li>Added pel=4 option for quarter pixel precision.</li>
<li>Renamed clip2x parameter to pelclip.</li>
</ul>
<p>1.8.1 beta (28.06.2007 by Fizick)</p>
<ul>
<li>MVAnalyse: added postrocessing motion vectores by dividing blocks into subblocks to decrease zone of motion vectors interpolation.</li>
<li>MVFlowFps: added "mode" parameter to select processing method at occlusion areas (and speed).</li>
<li>Some internal changes (padding in MVAnalysisData, header to vector stream frames, etc).</li>
</ul>
<p>1.8.0 beta (22.06.2007 by Fizick)</p>
<ul>
<li>MVFlowInter, MVFlowFPS, MVFlowFPS2, MVMask: improved occlusion mask by extent</li>
<li>MVFlowInter, MVFlowFPS: decreased objects halo at occlusion areas by using motion vectors of adjacent frames</li>
<li>MVFlowInter, MVFlowFPS: disabled SAD mask and thSAD parameter</li>
<li>MVShow: fixed drawn positon of vectors</li>
<li>MVFlowFPS, MVFlowFPS2: Changed default output fps to double of input (default num, den = 0) </li>
<li>Added error messages on missed vector clips</li>
</ul>
<p>1.7.0 beta (05.06.2007 by Fizick)</p>
<ul>
<li>MVAnalyse: added blksizeV and overlapV parameters for non-square blocks 8x4 and 16x8.</li>
</ul>
<p>1.6.4 (30.05.2007 by Fizick)</p>
<ul>
<li>MVAnalyse: modified vectors order for Enhausted search (expanding squares).</li>
<li>MVAnalyse: fixed bug with dct=3.</li>
<li>MVFlowFps, MVFlowFPS2, MVFlowInter: now blend frames with bad motion estimaton (at scenechanges, flashes).</li>
<li>MVFlowFps, MVFlowFPS2: fixed bug with thSAD parameter (and correspondent mask).</li>
</ul>
<p>1.6.3 (06.05.2007 by Fizick)</p>
<ul>
<li>MVDepan: more compatible with DepanEstimate (range parameter, etc).</li>
</ul>
<p>1.6.2 (11.11.2006 by Fizick)</p>
<ul>
<li>MVAnalyse: changed DCT=2 mode to global luma dependent.</li>
</ul>
<p>1.6.1 beta (25.10.2006 by Fizick)</p>
<ul>
<li>MVAnalyse: added experimental DCT mode to improve motion estimation at luma flicker and fades (fast for blksize=8 only).</li>
</ul>
<p>1.5.8 beta (14.10.2006 by Fizick)</p>
<ul>
<li>Many functions: added <var>clip2x</var> parameter to use 2X upsampled clip instead of internal subpixel interpolation for pel=2</li>
<li>MVFlowFps, MVFlowFps2: added <var>thSAD</var> parameter; use local blending of neighbour frames pixels
 in regions with bad motion vectors</li>
<li>MVFlowFps, MVFlowFps2: may use motion vectors for any frames <var>delta</var></li>
<li>MVFlowFps, MVFlowFps2: fixed a bug for video with big nominators and denominators (thanks to Trixter for report)</li>
<li>MVCompensate: added experimental <var>fields</var> parameter
 to compensate fields shift of fieldbased video for pel=2</li>
<li>MVAnalyse: changed pnew parameter to relative of SAD</li>
</ul>
<p>1.5.3 beta (01.10.2006 by Fizick)</p>
<ul>
<li>MVAnalyse: improved zero motion estimation for fieldbased video for pel=2</li>
<li>Merged v1.4.12-1.4.13 changes</li>
<li>Temporary restored MVIncrease, MVChangeCompensation, MVDenoise (with compensation stored in vector clip)</li>
</ul>
<p>1.5.1 beta (05.09.2006 by Fizick)</p>
<ul>
<li>Merged v1.4.11 changes</li>
</ul>
<p>1.5.0 beta (23.08.2006 by Fizick)</p>
<ul>
<li>Corrected vector predictors interpolation (from coarse to fine scale) for overlap>0.</li>
<li>MVFlowInter: added thSAD parameter.</li>
<li>MVFlowInter: local blending of neighbour frames pixels
 in regions with bad motion vectors.</li>
<li>Removed compensation storage in vector clip</li>
<li>Removed functions MVIncrease, MVChangeCompensation, MVDenoise
(it used compensation in vector clip, and did not support overlapping).</li>
<li>Removed  mode=2 loop option of MVCompensation, mode=0 is processed as mode=1 now.</li>
<li>Added thSAD parameter to MVCompensation for safe (dummy) compensation as requested by Didee</li>
</ul>
<p>1.4.13 (28.09.2006 by Fizick)</p>
<ul>
<li>Fixed bug with possible wrong frames pointers in core (MVClip.Update),
hided by caching (thanks to IanB for advice)</li>
</ul>
<p>1.4.12 (25.09.2006 by Fizick)</p>
<ul>
<li>Seems fixed bug with frames caching in MVDenoise (and possible in MVDegrain) (thanks to il9ad for report)</li>
</ul>
<p>1.4.11 (06.09.2006 by Fizick)</p>
<ul>
<li>Corrected vector predictors interpolation (from coarse to fine scale) for overlap>0.</li>
<li>Fixed bug with pitch for overlap=0, YV12 in MVDegrain1 (thanks to Boulder for report)</li>
</ul>
<p>1.4.10 (18.08.2006 by Fizick)</p>
<ul>
<li>Corrected right and bottom borders processing in MVCompensate for arbitrary frame sizes.</li>
<li>Changed defaults in MVAnalyse: pel=2, truemotion=true, sharp=2.</li>
</ul>
<p>1.4.9 (14.08.2006 by Fizick)</p>
<ul>
<li>Fixes a bug in MMX optimization of overlap mode in MVDeGrain, MVCompensate for YUY2 with blksize=8
 (thanks to TSchniede for report).</li>
</ul>
<p>1.4.8 (31.07.2006 by Fizick)</p>
<ul>
<li>Added some MMX optimization of overlap mode in MVDeGrain, MVCompensate.</li>
<li>Fixed a bug with last (not processed) rows in MVDeGrain.</li>
</ul>
<p>1.4.7 (25.07.2006 by Fizick)</p>
<ul>
<li>Decreased overlap gridness in MVDeGrain1, MVDeGrain2, MVCompensate.</li>
<li>Added example with MVDeGrain1 for interlaced.</li>
</ul>
<p>1.4.6 (24.07.2006 by Fizick)</p>
<ul>
<li>Decreased denoising in MVDeGrain1, MVDeGrain2.</li>
<li>Plane parameter in MVDeGrain1, MVDeGrain2 now works :)</li>
</ul>
<p>1.4.5 (22.07.2006 by Fizick)</p>
<ul>
<li>Added plane parameter to MVDeGrain1, MVDeGrain2.</li>
</ul>
<p>1.4.4 (19.07.2006 by Fizick)</p>
<ul>
<li>Corrected default thSAD=400 in MVDeGrain1, MVDeGrain2.</li>
<li>Fixed a bug with V color plane in MVChangeCompensate.</li>
</ul>
<p>1.4.3 (17.07.2006 by Fizick)</p>
<ul>
<li>Decrease overlap gridness in MVDeGrain1, MVDeGrain2.</li>
</ul>
<p>1.4.2 (16.07.2006 by Fizick)</p>
<ul>
<li>Fixed a memory access bug in MVDeGrain1, MVDeGrain2. Thanks to krieger2005 for report.</li>
</ul>
<p>1.4.1 (23.06.2006 by Fizick)</p>
<ul>
<li>Changed MVDeGrain1, MVDeGrain2 mode to SAD weigthing.</li>
<li>Chanded thSCD1 default from 300 to 400.</li>
</ul>
<p>1.4.0 (19.06.2006 by Fizick)</p>
<ul>
<li>Added MVDeGrain1, MVDeGrain2 limited averaging denoisers.</li>
<li>Corrected thSAD scale in MVDenoise.</li>
<li>Corrected documentation about SAD.</li>
</ul>
<p>1.3.1 (11.06.2006 by Fizick)</p>
<ul>
<li>Added bicubic subpixel interpolation method for pel=2 (with iSSE optinization for sharp=1,2).</li>
<li>Assembler iSSE speed optimization for overlapped block compensation.</li>
</ul>
<p>1.3.0 (05.06.2006 by Fizick)</p>
<ul>
<li>Implemented overlapped block motion compensation to MVCompensation(mode=1).</li>
<li>Changed default to mode=1 in MVCompensation as the most universal.</li>
<li>Added sharp subpixel interpolation method for pel=2.</li>
<li>Fixed bug for blksize=16 with YUY2.</li>
<li>(To-do list: assembler SSE speed optimization for new compensation and interpolation methods.)</li>
</ul>
<p>1.2.6 beta (21.05.2006 by Fizick)</p>
<ul>
<li>Added option to write motion vectors data to log file as requested by Endre.</li>
</ul>
<p>1.2.5 (08.05.2006 by Fizick)</p>
<ul>
<li>Decreased zero vector weight, iteration accuracy in MVDepan</li>
</ul>
<p>1.2.4 (07.04.2006 by Fizick)</p>
<ul>
<li>Fixed bug v.1.2.3 with info mode in MVDepan</li>
</ul>
<p>1.2.3 (31.03.2006 by Fizick)</p>
<ul>
<li>Implemented MVDepan for interlaced source separated by fields;</li>
<li>added optional MVDepan log file.</li>
</ul>
<p>1.2.2 beta (01.03.2006 by Fizick)</p>
<ul>
<li>Fixed frame shift bug of v1.2.1 with mmx YUY2 conversion (thanks to <b>WorBry</b> for bug report)</li>
</ul>
<p>1.2.1 beta (20.02.2006 by Fizick)</p>
<ul>
<li>Fixed bug of v1.2,</li>
<li>Speed restored,</li>
<li>mmx YUY2 conversion (from avisynth 2.6 function by sh0dan) </li>
<li>But it seems, overlap mode still does not work properly</li>
</ul>
<p>1.2 beta (17.02.2006 by Fizick)</p>
<ul>
<li>YUY2 format support (besides MVIncrease), no optimization</li>
</ul>
<p>1.1.1 (16.02.2006 by Fizick)</p>
<ul>
<li>Removed DeBlock and Corrector filters (will be separate plugins)</li>
<li>Documented old MVSCDetection function.</li>
<li>Cleaned project from unused source files.</li>
</ul>
<p>1.1 (non-public build 9.01.2006 by Fizick)</p>
<ul>
<li>Quite large revision (beta). New option for overlapped block motion estimation in MVAnalyse
for usage in MVFlow, MVFlowInter, MVFlowFps for improved motion compensation.</li>
<li>Lookup tables for motion interpolation.</li>
<li>Small correction of  displacement value in MVFlowFps2.</li>
</ul>
<p>1.0.3 (Released 30.12.2005 by Fizick)</p>
<ul>
<li>Fixed bug with displacement in MVFlowInter, MVFlowFps (introduced in v1.0.2).</li>
</ul>
<p>1.0.2 (Released 28.12.2005 by Fizick)</p>
<ul>
<li>Corrected value of displacement in MVFlow (a little).</li>
</ul>
<p>1.0.1 (Released 24.12.2005 by Fizick)</p>
<ul>
<li>Fixed memory leakage bug in MVAnalyse with global motion (thanks to <b>AI</b> for report).</li>
<li>Removed penalty for zero vector predictor in MVAnalyse (was introduced in v1.0).</li>
<li>Changed chroma=true as default in MVAnalyse.</li>
</ul>
<p>1.0 (Released 29.11.2005 by Fizick)</p>
<ul>
<li>I'm tired of long version numbers :). But the plugin is stil experimental :(.</li>
<li>Restored zero vector predictor in MVAnalyse.</li>
<li>Changed blur time scale in MVFlowBlur (100 is fully open shutter now) as <b>Mug Funky</b> requested.</li>
</ul>
<p>0.9.13.3 (Released 27.11.2005 by Fizick)</p>
<ul>
<li>Added global motion (simple method) vector predictor to MVAnalyse.</li>
<li>Vector search is skipped (for speed) if good predictor was found (with SAD &lt; pnew).</li>
<li>Parameter <var>scale</var> in MVShow works properly now.</li>
<li>Disabled some debug and profiling info output (for speed increasing).</li>
<li>Changed default <var>prec</var>=1 (was 2) in MVFlowBlur.</li>
</ul>
<p>0.9.13.2 (Released 22.11.2005 by Fizick)</p>
<ul>
<li>Fixed bug in MVFlowFps, MVFlowFps2 for non-integer fps.</li>
</ul>
<p>0.9.13.1 (Released 21.11.2005 by Fizick)</p>
<ul>
<li>Fixed bug in MVFlowFps, MVFlowFps2, MVFlowInter, MVFlowBlur (introduced in v0.9.13).</li>
<li>Removed <var>plen</var> parameter from MVAnalyse as not useful.</li>
</ul>
<p>0.9.13 (Released 20.11.2005 by Fizick)</p>
<ul>
<li>Added <var>truemotion</var> preset to MVAnalyse.</li>
<li>Added experimental MVFlowFps2.</li>
<li>Change interpolated vector rounding method in all MVFLow... functions.</li>
<li>Edited documentation a little.</li>
</ul>
<p>0.9.12.4 (Released 15.11.2005 by Fizick)</p>
<ul>
<li>Changed type of <var>ml</var> parameter in MVMask, MVFlowInter, MVFlowFps from int to float.</li>
<li>Added bound check of <var>ml, time, blur</var> parameters.</li>
<li>Small possible bug fixed (emms).</li>
<li>Partially updated documentation. But I am not sure that <b>sh0dan</b> requested <b>exactly such</b> updating :).
It is still not user guide but functions reference.</li>
</ul>
<p>0.9.12.3 (Released 14.11.2005 by Fizick)</p>
<ul>
<li>Fixed bug for chroma for width not divisible by 16 in MVMask (introduced in v0.9.11).</li>
<li>Some speed optimizing of MVFlowFps.</li>
<li>Reset size of internal frames buffer to original value 10. Try various versions.</li>
</ul>
<p>0.9.12.2 (Released 13.11.2005 by Fizick)</p>
<ul>
<li>Added experimental precise but slow MVFlowBlur function as <b>scharfis_brain</b> requested.</li>
<li>Temporary changed size of internal frames buffer to 5.</li>
</ul>
<p>0.9.12.1 (Released 12.11.2005 by Fizick)</p>
<ul>
<li>Added experimental MVFlowFps function.</li>
<li>Disabled MVInter function.</li>
<li>Temporary changed size of internal frames buffer from 10 to 3 for memory usage decreasing.
Speed must be tested for complex scripts.</li>
</ul>
<p>0.9.12 (Released 09.11.2005 by Fizick)</p>
<ul>
<li>Added MVFlowInter function. MVInter function will be removed in next release (it is worse).</li>
<li>Changed scale of <var>ml</var> parameter for kind=2 of MVMask to more optimal default.</li>
<li>Fixed small bug in Bilinear.asm (strange pixels near right border for pel=2).</li>
</ul>
<p>0.9.11.1 (Released 06.11.2005 by Fizick)</p>
<ul>
<li>Added half-pel support to MVFlow.</li>
<li>Increased max <var>quant</var> from 51 to 60 in DeBlock for very strong deblocking .</li>
<li>Corrected documentation.</li>
</ul>
<p>0.9.11 (Released 04.11.2005 by Fizick)</p>
<ul>
<li>Improved MVMask: Replaced boolean <var>showsad</var> parameter to integer <var>kind</var>,
added occlusion mask option. Changed bilinear resize code to more correct and fast SimpleResize.</li>
</ul>
<p>0.9.10.1 (Released 01.11.2005 by Fizick)</p>
<ul>
<li>Fixed bug with chroma and luma small changes in MVInter (rounding error).</li>
<li>Vector interpolation in MVFlow and mask in MVInter are correct now (due to fixing bug in SimpleResize).</li>
</ul>
<p>0.9.10 (Released 31.10.2005 by Fizick)</p>
<ul>
<li>Added some true motion (smoothed) estimation options to MVAnalyse</li>
<li>Added function MVFlow for per-pixel motion compensation</li>
<li>Added function MVInter for motion interpolation (very experimental)</li>
</ul>
<p>0.9.9.1 (Released 20.01.2005 by Manao)</p>
<ul>
<li>No need anymore of stlport_vcxxxx.dll</li>
</ul>
<p>0.9.9</p>
<ul>
<li>Filter added : Corrector</li>
<li>Filter added : MVIncrease</li>
<li>New available blocksize : 16</li>
<li>New parameter in MVAnalyse : <var>chroma</var></li>
<li>Changes in the core</li>
</ul>
<p>0.9.8.5</p>
<ul><li><code>MVCompensate</code> changed : a new parameter, idx, which works as idx in <code>MVAnalyse</code>,
and which allows speed up when compensating the same frames several times.</li>
</ul>
<p>0.9.8.4</p>
<ul><li>ME takes into account the chroma now, as requested by tsp.</li>
</ul>
<p>0.9.8.3</p>
<ul><li>Added <code>Corrector</code> function, as requested by scharfi.</li>
</ul>
<p>0.9.8.2</p>
<ul><li>New function <code>MVDepan</code> (added by Fizick) for Depan plugin.</li>
</ul>
<p>0.9.8.1</p>
<ul><li>Several bugfixes</li>
</ul>
<p>0.9.8</p>
<ul><li>Yet another little changes in the filters' syntax. The core changed a lot,
in order to gain speed were it was possible. However, by default, the speed gain won't be
visible, you'll need to configure correctly the analysis filter through its "idx"
parameter in order to gain speed ( in the mode "pel" = 2 ).</li>
<li>Bugfixes in MVDenoise, and chroma denoising in MVDenoise.</li>
<li>Now, the filters down the filter's chain tell to the analysis filter if they need
the compensation, so you don't have to worry about that at the analysis stage.</li>
</ul>
<p>0.9.7</p>
<ul><li>Yet again, a lot of rewriting. Interpolating filters are disabled ( for the moment ),
all the other filters work and should be considered as stable. Syntax has changed a lot,
and will change again before reaching 1.0 ( if it's reached one day ). Changes mainly affect
<code>MVAnalyse</code>. New filter :  <code>MVChangeCompensate</code>.
</li></ul>
<p>0.9.6.2</p>
<ul>
<li> Fixed bug in <code>MVMask</code> parameters.</li>
</ul>

<p>0.9.6.1</p>
<ul>
<li>Lot of bugfixes for the existing filters. MVMask, MVShow, MVCompensate, MVDenoise and MVSCDetection, and MVAnalyse should work .
Other may crash unexpectedly.</li>
<li>Now, for the three new filters. Two have nothing to do with motion compensation,
but I didn't want to put them in separate binaries, since they'll mainly be used with filters from this package.
The third one uses vectors, and integrates somehow the two others.</li>
<li>QDeQuant(clip c, int quant, int level) : takes a clip and quantizes it, using an approximation of the H264 DCT.
It filters the three planes ( 4x4 blocks for each of them, so the chroma isn't processed as in H264 ).
It's not exactly the H264 DCT because at q1, it's lossless, and a q51 it's not that bad, but you can raise quant over 51.
Level is the reference level of the picture.
By default it's zero, but it can be set, for example, to 128.
The picture is then treates as if pixels were ranging from -128 to 127, hence avoiding errors around 128.</li>
<li>Deblock(clip c, int quant, int aOffset, int bOffset ) : takes a clip, and deblock it using H264 deblocking,
as if the picture was made only of inter blocks. This time, quant ranges from 0 to 51 as in H264, and has the same impact.
aOffset and bOffset allow to raise / lower the quant when deciding for some internal thresholds.
They are set by default to 0. Be warned that the filter should do nothing at quant lesser 16, if aOffset and bOffset are both zero.
It's a wanted behavior ( thus it respect the partially the norm ).</li>
<li>EncDenoise(clip c, clip vectors, bool scbehavior, int quant, int aOffset, int bOffset, int thSCD1, int thSCD2) :
it merges Deblock, QDeQuant and MVCompensate, taking from them the name and behavior of their parameters.
It basically does a h264 encode as if all blocks were 8x8 inter blocks.
Reference frame is the previous frame output by the filter ( if it is the correct one, else it's the previous frame of the source ),
mvs are those given by mvanalyse on the source. The reference frame is compensated by the vectors,
then the residual difference is quantized / dequantized and added to the result of the motion compensation.
Finally, the frame is deblocked, and serves as reference for the next one.</li>
</ul>

<p>0.9.5.3</p>
<ul>
<li>Mainly a bugfixe ( several filters were affected by a silly bug , and MVCompensate now do padded motion compensation,
and compensate also the chroma ( though it rounds the vector to odd coordinates to do so )</li>
<li>A new feature, as asked by Fizick, for mvcompensate :
"scbehavior", a boolean set to true by default, will allow you to keep the previous frame over a scenechange if you set it to false.</li>
</ul>

<p>0.9.5.2</p>
<ul>
<li>MVMask has two new parameters : showsad (bool) which allows to build the mask of the SAD values instead of the mask of the vectors' length.
Ysc allows you to set the value taken by the mask on scene changes</li>
<li>MVCompensate : behavior modification on scene changes. Now, the current frame is left untouched if a scene change was detected.</li>
<li>New filter : MVSCDetection, with one parameter, Ysc, which works as previously.</li>
<li>MVInterpolate, MVConvertFPS and MVBlur are enabled, but may be buggy ( though I wasn't able to make MVConvertFPS crash )</li>
</ul>

<p>0.9.5
</p>
<ul>
  <li>Huge rewritting of the core engine. Vectors are now searched with a
   precision up to the pixel ( because no other filters can use yet more
   precise vectors, except MVShow ). The search engine is now fast ( which
   doesn't mean necessarily that the filters which use it are fast )</li>
   <li>A new parameter for MVAnalyse : lambda. See the documentation of the
   filter to see how it works</li>
   <li>MVDenoise works better.</li>
</ul>
<p>0.9.4
</p>
<ul>
  <li>Vectors can be saved to a file. In order to do so, add the parameter
filename="C:\foo.bar" to the filter MVAnalyse. If the file doesn't exist,
vectors will be saved into it. If it exists, vectors will be read from it. But,
be warned :
    <ul>
      <li>The file for a whole movie will be around 500 MB</li>
      <li>Saving / reading from a file need for the moment a linear access to
the frames, so it has to be used only when encoding the movie, not when doing
random access in it.</li>
      <li>The speed gain is not as great as one may hope, because SADs can't be
saved ( it would take too much space ) and so have to be recomputed.</li>
    </ul>
  </li>
  <li>The filter MVDenoise now works on 5 frames, and its parameters are now
"thT" and "sadT" ( have a look in the documentation to see how they work ). It
works nice ( very good for heavy denoising )</li>
  <li>The scene change detection thresholds have slightly changed. Now, a block
has changed if its SAD it over thSCD1. The default for thSCD1 is 300, and for
thSCD2 it is 130. It orks well ( better than the previous SCD engine ).<br>
  </li>
</ul>
<p>0.9.3</p>
<ul>
  <li>Last cleanings in the search of the motion vectors. It should be slightly
faster</li>
  <li>More search parameters can be set by the user, especially the search
algorithm. See the documentation</li>
  <li>Server / client implemented. You now first have to use MVAnalyse, and
then the filter you want. Look at the documentation and at the examples I'll
give alter.</li>
  <li>MVCompensate is separated from MVShow ( it's more logic that way ). For
the moment, it doesn't move the chroma ( same behavior as MVShow in the latest
releases )</li>
  <li>Some cleaning in MVBlur / MVInterpolate / MVConvertFPS, but still some
work to do. Now, MVBlur blurs around the frame, not between the frame and the
previous one.</li>
  <li>Half of the work is done for writing vectors to a file. But the resulting
file will be large ( around 500 MB - 1 GB I guess ).</li>
  <li>MVDenoise is slightly faster ( at least it should )</li>
  <li>Copies are optimized inside the filter, thanks to avisynth's copy
functions.</li>
  <li>MVShow can display the mean SAD of the compensation ( using showsad =
true )</li>
</ul>
<p>0.9.2.1</p>
<ul>
  <li>MVInterpolate makes its come back.</li>
  <li>MVConvertFPS should work on the last few frames of the clip</li>
</ul>
<p>0.9.2</p>
<ul>
  <li>MVInterpolate doesn't exist anymore.</li>
  <li>MVBlur and MVConvertFPS have been improved. They also have got new
parameters, have a look at the documentation.</li>
  <li>MVShow gets back its compensate mode ( MVShow(cm = true) )</li>
</ul>
<p>0.9.1 - 12.05.2004</p>
<ul>
  <li>First version renamed to MVTools. </li>
</ul>
<p>0.1-0.6 Released 24.01.2004 - 01.04.2004 by Manao</p>
<ul>
  <li>First public versions MotionVectors (Motion.dll). </li>
</ul>
</small>

<h2><a name="download"></a>VI) Stáhnout</h2>

<h3><a href="http://www.avisynth.org.ru/mvtools/mvtools-v2.4.2.zip">Stáhnout MVTools v2.4.2</a></h3>

<p>Starší verzi 1.X dokumentaci a odkaz na její staení je na
<a href="http://avisynth.org.ru/mvtools/mvtools.html">http://avisynth.org.ru/mvtools/mvtools.html</a></p>

<p>Starší MVTools v.0.9.9.1 mùete stáhnout z <a href="http://manao4.free.fr/">Manaovıch stránek</a></p>

</body>
<p><kbd>Èeskı pøeklad:22.5.2009</kbd>
</html>
