<html><head>
		<title>RemoveGrain</title>
<link rel="stylesheet" type="text/css" href="../../avisynth.css">
	</head>
  <body>
		<h1>RemoveGrain</h1>
<h2>Pøehled</h2>
<b>autor:</b> Rainer Wittmann (aka kassandro)
<br><b>verze:</b>   0.9<br>
<b>stáhnout:</b>  <a href="http://www.removegrain.de.tf/">http://www.removegrain.de.tf/</a><br>
<b>kategorie:</b>  Prostorové vyhlazovaèe<br>
<b>poadavky:</b>
<ul>
  <li>YV12 &amp; YUY2 Barevné prostøedí</li><br>
  <li><a href="avsrecursion.htm">AvsRecursion</a></li><br>
  <li><a href="http://www.geocities.com/wilbertdijkhof/71.cab">msvcp71.dll/msvcr71.dll</A></li><br>
<b>licence:</b>  GNU General Public License<br>
</ul>
<hr>
		<p><b><a href="http://home.pages.at/kassandro/RemoveGrain/RemoveGrain.zip">Plugin</a> a
    <a href="http://home.pages.at/kassandro/RemoveGrain/RemoveGrain-src.zip">zdrojovı kód</a>
    jsou pøedmìtem <a href="http://www.gnu.org/copyleft/gpl.html" target="_blank">
					GNU General Public License</a>.&nbsp; Navíc odpíráme jakákoli práva
				pro odvozování Photoshop pluginù ze zdrojového kódu RemoveGrain. Toto
				omezení bylo provedeno s ohledem na zpùsob jak Adobe zachází s filtry vıvojáøù tøetích stran,
				kterı je absolutnì nepøijatelnı. Poslední zmìna 1.kvìtna
				2005.</b></p>
		<h2>Instalace</h2>
		<p>Binární balík obsahuje ètyøi verze RemoveGrain, tøi malé
			dynamicky pøipojované verze RemoveGrain.dll, RemoveGrainSSE2.dll,
			RemoveGrainSSE3.dll&nbsp; a velkou staticky pøipojovanou
			RemoveGrainS.dll.&nbsp;První vyaduje jen integer SSE (Athlon
			a&nbsp;Pentium 3), druhı vyaduje SSE2 kompatibilní cpu (Pentium 4
			nebo Athlon 64) a tøetí je jen pro Prescott P4. Pokud ádná z tìchto dll
			nepracuje, protoe chybí dll, musí se buï nakopírovat chybìjící dll systémové
			sloky windows nebo se musí pouít RemoveGrainS.dll, kterı vyaduje jen
			SSE. Vlote prosím jen jeden ze tøí pluginù do sloky Avisynth pluginù.
			RemoveGrain podporuje všechna barevná prostøedí. YV12 je podporované pøímo
			a YUY2, RGB24, RGB32 jsou podporovány v planární formì (viz kapitola Barevná
			prostøedí).&nbsp;Poèínaje verzí 0.6 byl pøidán pomocnı filtr Clense
			do RemoveGrain.dll a plugin Repair.dll byl vloen do svého binárního balíku.
			Znovu jsou ètyøi verze tohoto
			pluginu.&nbsp;Pøestoe je Repair.dll odvozen ze stejného zdrojového kódu,
			je urèen pro docela jiné úèely. Tento plugin obsahuje filtry Repair
			a TemporalRepair. Všechny tøi nové filtry jsou popsány níe. Posílejte prosím
			dotazy, problémy, komentáøe atd.&nbsp;na&nbsp;<a href="http://forum.doom9.org/showthread.php?s=&amp;threadid=79751">vlákno RemoveGrain
				</a> &nbsp;na fóru doom9 radìji, ne aby jste mi posílali email.&nbsp;V
			zásadì bych ocenil zprávy o artefaktech a kompresním zesílení
			rùznıch reimù. S vıbìrem správného reimu mohou pomoci také ostatní.
		</p>
		<h2>Jak pracuje</h2>
		<p>RemoveGrain je èistì prostorovı odšumovaè pro Avisynth.&nbsp;Nicménì, v
			kombinaci s Clense a Repair pluginem&nbsp;vıkonnìjšími
			prostorovì èasovımi odšumovaèi a odstraòovaèi prokládání (deinterlacery) mohou bıt sestaveny Avisynth funkce
			(viz pøíklady níe). Reimy 1-10,17,18&nbsp;jsou jen pro skuteènì progresivní
			vstup, zatímco reimy 13-16 jsou primárnì pro prokládanı vstup a jsou
			pouity pro konstruktivní odstraòovaèe prokládání.&nbsp;Zatímco&nbsp;reimy 1-10,17,18&nbsp;mohou
			bıt pouity pro prokládanı a telecine materiál jejich pouitím na oddìlená pole,
			kvalita je horší, protoe sousední pixely
			mají dvojnásobnou vertikální vzdálenost, co má jasnì negativní dopad na
			kvalitu. S RemoveGrain nelze odstraòovat velké skvrny nebo škrábance z
			klipu. Byl navren spíše pro velmi malé skvrny - ne o moc
			vìtší ne pixel. Aèkoliv zmìny provedené RemoveGrain jsou tìko
			viditelné, dopad na kompresi mùe bıt docela velkı. V reimech 1-10,17,18
			je hodnota støedového pixelu nahrazena hodnotou jednoho z jeho osmi
			sousedù. To se aplikuje na jas (luma) i na barevnost (chroma). Pøesnìji,
			pro danı pixel x se RemoveGrain dívá na osm prostorovıch sousedù tohoto
			pixelu a vybírá dva z tìchto sousedù, øeknìme, a,b pro <i>minmax oøíznutí</i>,
			t.j. x je nahrazeno min(max(x, min(a,b)), max(a,b)). Vıbìr a,b
			silnì závisí na promìnné <i>mode</i> . Pokud&nbsp;1 &lt;= mode &lt;= 4
			minmax oøíznutí je provedeno&nbsp;v a(mode), a(9-mode), kde a(1) &lt;= a(2) &lt;=
			a(3) &lt;= a(4) &lt;= a(5) &lt;= a(6) &lt;= a(7) &lt;= a(8) je posloupnost
			sousedù seøazenıch podle jasu.&nbsp;Tak, pokud je poèet sousedù
			s jasem (luma) &gt;=&nbsp;x&nbsp;vìtší ne hodnota promìnné <i>mode </i> a
			pokud je poèet sousedù s jasem (luma) &lt;=&nbsp;x&nbsp;&nbsp;vìtší
			ne <i>mode</i>&nbsp;, pak jas tohoto pixelu je ponechán nezmìnìn.
			Samozøejmì má tato metoda smysl jen pro 1 &lt;= mode &lt;= 4. Pokud je mode=1, pak
			RemoveGrain(mode=1) je identickı s trbarryho <a href="http://www.trbarry.com/" target="_blank">
				Undot</a> &nbsp;(dokonce rychlost SSE verze je témìø identická
			jako u Undot, ale SSE2 a zvláš SSE3 verze jsou
			vıraznì rychlejší).&nbsp;S hodnotami barevnosti je pracováno podobnì,
			ale místo promìnné <i>mode</i> , je pouita promìnná <i>modeU</i>
			pro plochu U a <i>modeV</i> je pouito pro plochu V. Nicménì,
			hodnota promìnné <i>mode </i>je vıchozí hodnotou pro promìnnou <i>modeU</i>
			a hodnota promìnné <i>modeU</i> je vıchozí hodnotou pro promìnnou
			<i>modeV</i> . Podívejme se na pøíklad:&nbsp;pøedpokládejme, e
			pixel má jasovou hodnotu 32 a e osm sousedù má jasové hodnoty
			21, 122, 77, 25, 56, 200, 133, 45. Pøi <i>mode </i>&lt;= 2, pak pixel
			zùstává nezmìnìnı, protoe existují dva sousedi s menším jasem
			a šest s vìtším jasem. Pokud je <i>mode</i>=3, pak je jas
			pixelu zvıšen na 45. Nakonec, pokud je <i>mode</i>=4, tak je jas
			zvıšen na 56. Pøi <i>mode</i>=1,2 je filtr docela bez artefaktù.
			Tenké èáry jsou tìmito reimy zachovány vèetnì dvou koncovıch bodù. Pokud je<i> mode</i>=3
			nebo 4, pak mohou bıt tenké èáry pùsobením RemoveGrain znièeny.&nbsp;Proto mùe bıt RemoveGrain(<i>mode</i>=3
			nebo <i>mode</i>=4) pouito jen s urèitou opatrností. Slušná hodnota bez rizika <i>mode</i>=2
			je vıchozí. Stále dìlá vıraznì silnìjší odšumìní ne
			Undot, t.j.&nbsp;<i>mode</i>= 1. Èím vìtší hodnota mode (jen mezi 1 a
			4), tím mìkèeji vypadá vıstup a tím vyšší je kompresní pomìr.
			Smart mode  (chytrı reim) 17, uvedenı ve verzi 0.8, má zvláštní vıznam.
			Je to varianta reimu mode 4. Nicménì, na rozdíl od mode 4,
			zachovává tenké èáry, aèkoli pixely na dvou koncích tenké èáry
			se mohou ztratit. Kdykoli mode= 4 neznièí tenké èáry pøes pixel,
			pak mode 17 zpracuje pixel právì jako mode 4, jinak se pouije mírnì
			agresivnìjší reim ne mode&nbsp;2. Narozdíl od
			reimù &lt;= 4, reimy mezi 5-9,17,18 jsou <i>citlivé k hranám</i> . Zatímco
			v mode &lt;= 4 jakıkoli pár sousedù je monou volbou pro minmax
			oøíznutí, v reimech 5-9,18 jsou pouity jen páry øádkù. Existují ètyøi takové páry:
			první horizontální pár sestávající z levého a pravého souseda
			pixelu, druhı vertikální pár sestávající z horního a spodního
			souseda, tøetí diagonální pár sestávající ze spodního levého a horního
			pravého souseda a nakonec diagonální pár sestávajcí z horního levého a
			spodního pravého souseda.&nbsp; Pøi <i>mode</i>=9, vybíráme jednoduše ten pár øádkù
			(a,b) pro minmax oøíznutí, pro které je&nbsp;|a - b|&nbsp;minimální (jako
			obvykle |y| = max(y,-y)&nbsp;oznaèuje absolutní hodnotu èísla y)&nbsp;.
			Tedy RemoveGrain(mode= 9) je prostì èistì prostorová varianta trbarryho filtru <a href="http://www.trbarry.com/" target="_blank">
				ST Median</a> . Pøi <i>mode</i>=5, je tento pár øádkù (a,b)
			zvolen pro minmax oøíznutí, pro které je |x - y| minimální (zde je x
			pùvodní jasová hodnota pixelu a y=min(max(x, min(a,b)), max(a,b)) je
			hodnota získaná pøi minmax oøíznutí). Reimy 6,7,8 jsou støední reimy
			mezi <i>mode</i>=5 a <i>mode</i>=9. <i>mode</i>=6 je blíe <i>mode</i>=5
			zatímco <i>mode</i>=8 je bliší <i>mode</i>=9 a <i>mode</i>=7 je
			právì ve støedu mezi <i>mode</i>=5 a <i>mode</i> =9.&nbsp; Mode 5
			zachovává tenké èáry vèetnì dvou posledních bodù. Mode 6-8&nbsp;také zachovává
			tenké èáry, ale koncové body se mohou ztratit (pravdìpodobnost takové ztráty
			se zvyšuje s èíslem reimu). Fizick rozšíøil mode 5-9 do èasové
			(temporal) oblasti ve svém pluginu <a href="http://bag.hotmail.ru/">DeGrainMedian</a>.
			Protoe nyní existuje 26 místo 8 sousedních pixelù, je toto rozšíøení
			nutnì pomalejší. Pøesto má èasové rozšíøení velkı smysl.
			Mode 18 (pøidanı ve verzi 0.9) zachová tenké èáry
			èasto také se dvìma koncovımi body, ale mìlo by to bıt horší ne
			v mode 17 pokud se tıká komprese. &nbsp;
		</p>
		<p>Od verze 0.6 jsme také pøidali rychlou implementaci
			nejdùleitìjších 3x3 konvolucí jako mode 11. Pokud y(i,j) oznaèuje
			jas pixelu se souøadnicemi i,j, pak mode 11 nahradí y(i,j) tímto
			(4*c(i,j) + 2*(c(i-1,j) + c(i+1,j) + c(i,j-1) + c(i,j+1)) + (c(i-1,j-1) +
			c(i-1,j+1) + c(i+1,j-1) + c(i+1,j+1)) + 8)/16 (+8 je nezbytné pro správné
			zaokrouhlení). Tak jsou všechny pixely vertikálnì a horizontálnì rozmazány s
			(1/4,1/2,1/4) jádrem. Vestavìnı Blur(1) vyaduje dìlat to samé, ale ve skuteènosti
			to nedìlá. Mode 12 (pøidanı ve verzi 0.7) je vıraznì rychlejší verzí reimu
			mode 11, kterı je trochu ménì pøesnı (rozdíl mezi obìma je vdy
			&lt;=1). Tedy, pokud nejste pedanti, mìli by jste vdy pouít mode 12 místo
			11. Ve verzi 0.7 byly pøidány dva reimy bob 13 a 14 . Mode 13
			nechává spodní pole nezmìnìné a interpoluje horní pole. Mode 14
			nechává horní pole nezmìnìné a interpoluje spodní pole.
			Interpolace v mode 13, 14 je podobná jako u Trbarryho weird bobu, kterı
			je èástí Trbarryho <a href="http://www.trbarry.com/" target="_blank">Tomsmocomp</a>.
			Nicménì, místo optimalizování pøes 5 párù øádkù optimalizujeme jen kadé 3
			páry øádkù. Pøesnìji,&nbsp;c(i,j) je nahrazeno buï (c(i-1,j-1) +
			c(i&nbsp;+1,j+1)+1)/2 or (c(i-1,j+1) + c(i&nbsp;+1,j-1)+1)/2 nebo (c(i,j-1) +
			c(i,j+1)+1)/2, podle toho, která ze tøí vzdáleností
			|c(i-1,j-1)&nbsp;- c(i&nbsp;+1,j+1)|, &nbsp;|c(i-1,j+1)&nbsp;-
			c(i&nbsp;+1,j-1)|, &nbsp;|c(i,j-1) - c(i,j+1)| je minimální. V Trbarryho weird
			bobu (c(i-2,j-2) + c(i&nbsp;+2,j+2)+1)/2&nbsp;a (c(i-2,j+2) +
			c(i&nbsp;+2,j-2)+1)/2 jsou moné interpolaèní hodnoty. Tedy weird bob
			je k hranám citlivìjší, ale také je vyšší pravdìpodobnost smart edge artefaktù
			a samozøejmì je pomalejší. Vzetí jen 3 párù øádkù se zdá bıt nejlepším kompromisem
			pro nás. Spolu s filtrem TemporalRepair, popsanım níe,
			mùe bıt pouit pro sestavení pohybovì adaptivního deinterlaceru (odstraòovaèe prokládání).
			Od verze 0.8 jsme pøidali reimy 15, 16. Mají stejnou citlivost k hranám
			jako reimy 13,14 , ale kvalita je o nìco vyšší a rychlost o nìco niší. </p>
		<p>
			Kterı reim je nejlepší pro odšumìní? Pokud se jedná o kompresi, mé
			dosavadní testy dávají následující poøadí reimù: 4,17,9,8,3,7,6,2,5,1, ale
			reimy 4 a 17 opravdu vynikají.&nbsp;Pokud se jedná o artefakty,
			máme naneštìstí témìø obrácené poøadí reimù: 1,5,2,18,6,7,8,17,3,4,9.
			Reimy 1,5,2 jsou bezpeèné (bez rizika artefaktù), reimy 18,6,7,8,17 ukazují nízké a støední
			riziko artefaktù (obvykle nìjaké zmìkèení) a reimy 3,4,9 mají kruté problémy
			s tenkımi èárami. Reim 9 má ménì artefaktù ne mode 4, ale kdy se objeví
			vypadají mnohem ošklivìji. Reim 17&nbsp;je èistì mùj osobní
			favorit. Co se tıká komprese je blízko vedoucímu reimu
			, mode 4, a já jsem vidìl jen nìjaké
			zmìkèení ale stìí nìjaké viditelné artefakty.&nbsp;&nbsp;Šíøka
			snímku vstupního klipu musí bıt &gt; 36 (SSE verze) nebo &gt; 68 (SSE2
			verze).
		</p>
		<h2>Optimální pouití</h2>
		<p>1. Jak u bylo øeèeno, RemoveGrain neumí mìnit pixely okrajù. Aby jste se toho
			zbavili, mìli by jste provést oøíznutí <i>po</i> RemoveGrain. Na druhou stranu,
			pro RemoveDirt by mìlo bıt oøezání provedeno pøedem tak aby DCT bloky a
			bloky RemoveDirt byly stejné. Tedy, pokud je RemoveGrain kombinován s
			RemoveDirt, oøezání by mìlo bıt provedeno nejlépe mezi RemoveGrain a Removedirt.
		</p>
		<p>2. Pøestoe RemoveGrain,vdy dìlá hodnì nezarovnanıch pøístupù do
			pamìti&nbsp;, zarovnané snímky mají kladnı dopad na vıkon.
			Tedy oøezávejte s <i>align</i>=true, pokud potøebujete oøíznout pøed
			RemoveGrain.
		</p>
		<p>3. Kdy je mode=0 (resp. modeU=0, resp. modeV=0), pak plocha Y (resp. plocha U,
			resp. plocha V) je jednoduše zkopírována ze vstupu do vıstupu. Dokonce kdy je mode
			&lt; 0 (resp. modeU &lt; 0, resp. modeV &lt; 0) tak se na pøíslušnıch plochách
			vùbec nic nedìlá (dokonce ani kopírování).&nbsp;To mùe bıt pouito pro
			rychlejší zpracování èernobílıch klipù. Napøíklad RemoveGrain(mode=8,
			modeU= -1). RemoveDirt(grey= true) je nejrychlejší zpùsob zpracování
			èernobílého klipu pomocí kombinace RemoveGrain/RemoveDirt. Protoe modeV
			dìdí hodnotu -1 z modeU, RemoveGrain nezpracuje plochy barevnosti (chroma)
			a RemoveDirt postupnì nastavuje plochy barevnosti rovnomìrnì na 128. Pokud pouíváte
			modeU=-1, musíte pøidat barevnost pozdìji pøes vestavìné filtry MergeChroma
			nebo GreyScale.
		</p>
		<p>4. RemoveGrain je slušnì rychlı. Má velkı smysl iterovat ho pro lepší
			odšumìní. Napøíklad, RemoveGrain(mode=2). RemoveGrain(mode=2) je stále
			slušnì defenzivní odšumovaè, kterı neznièí tenké èáry.
		</p>
		<p>5. Pokud je zrnìní pøíliš hrubé, RemoveGrain ho mùe odstranit jen èásteènì nebo ho nemùe
			odstranit vùbec. Protoe v takovém pøípadì je zdroj ostatnì dost slabı, je dobrı
			nápad ho zmenšit. Tak se stane také zrnìní menší a RemoveGrain mùe bıt schopen
			ho smazat. Obecnì, zmenšování by mìlo bıt provádìno <i>pøed </i>RemoveGrain
			zatímco zvìtšování by mìlo bıt provádìno <i>po</i> RemoveGrain.</p>
		<p>6. Jak je napsáno vıše, nìkteré reimy, zvláš mode 3,4,9, mají problémy s
			tenkımi èárami. Nyní má YUY2 a zvláštì YV12 problém s tenkymi èárami u
			barevnosti, protoe nìkolik pixelù sdílí jednu hodnotu barevnosti. Tento problém je
			zesílen pokud je RemoveGrain pouit na barevnost (chroma).&nbsp;Mìli by jste mít na pamìti,
			e RemoveGrain má zhruba ètyønásobnou sílu, pokud je aplikován na
			YV12 chroma ne na jas (luma). To je hlavní dùvod zmìkèení hran
			zpùsobeného více konzervativními reimy 18,6,7,8,17. Tedy pro vyhnutí se zesilování
			problému s tenkımi èarami je dobrı nápad pouít reimy bez problému s tenkımi
			èarami pro barevnost dokonce i kdy je reim 3,4,9 pouit na jas. Napøíklad
			RemoveGrain(mode=4, modeU=2) pouívá vysoce kompresní reim 4 pro jas a
			reim s málo artefakty mode 2 pro barevnost. Na druhou stranu je barevnost èasto
			detailnì zašumìlá (zvláštì, kdy klip pochází z videokazety),
			co znovu mluví pro pouití konzervativnìjšího reimu pro barevnost.
		</p>
		<h2>Clense</h2>
		<p>Clense pouívá jednoduchou èistící techniku jako <a href="http://www.removedirt.de.tf/">
				RemoveDirt</a>, ale bez jakékoli ochrany proti artefaktùm.
			Take pokud p[i,j],c[i,j],s[i,j] oznaèuje jas pixelu se souøadnicemi
			i,j v pøedchozím, aktuálním a následném snímku, pak
			c[i,j] je nahrazeno min(max(c[i,j], min(p[i,j],s[i,j])),
			max(p[i,j],s[i,j]))), t.j. èasové (temporal) minmax oøíznutí. Je to velmi brutální
			èistiè a nemùe bıt pouit bez Repair nebo nìkterého jiného odstraòovaèe artefaktù.
			Nicménì pokud se špína nebo zrnìní pøekrıvají s podobnou špínou nebo zrnìním pouze v
			jednom sousedním snímku, toto pøekrytí nemùe bıt vyèištìno. Tato poznámka
			je zvláštì dùleitá pro zrnìní (dokonce neviditelné zrnìní mùe mít velmi
			vıznamnì negativní dopad na kompresi). Tak to docela zlepšuje kompresi
			pro odstranìní tìchto zbytkù. Zbytky z Clense jsou obvykle
			vıraznì menší ne pùvodní zrnìní, take Clense + RemoveGrain je
			podstatnì efektivnìjší a je schopno odstranit hrubší zrnìní ne
			RemoveGrain sám, ale jsou zde samozøejmì problémy s nìkterımi zbytkovımi artefakty.</p>
		<p>Clense pøijímá dva argumenty. Prvním je vstupní klip a druhım je
			logická promìnná <i>grey</i> (<i>grey</i>=false je vıchozí). Pokud je
			grey=true, Pak se neprovádí ádné zpracování barevnosti, t.j. barevnostní plochy
			obsahují náhodné hodnoty a v nìkterém z posledních stádií musí bıt pouit
			èernobílı filtr. Promìnná gray je ignorována pro klipy s barevnım prostøedím jinım ne
			YV12.</p>
		<p>Od verze 0.9 existují také filtry <b>BackwardClense </b>
			a <b>ForwardClense</b>. Ty jsou primárnì pro èištìní ostrıch zmìn scén
			ve skriptové funkci RemoveDirt. ForwardClense je pro první snímek
			nové scény a BackwardClense je pro poslední snímek scény. Pouití
			je stejné jako u Clense.
		</p>
		<h2>Repair</h2>
		<p>
			Od verze 0.6 jsme pøidali plugin Repair. Je generován ze
			stejného zdrojového kódu jako RemoveGrain, ale zajišuje velmi odlišnou èinnost.
			Místo odstraòování zrnìní by mìl Repair odstraòovat artefakty uvedené
			v pøedchozích filtrech. Dìlá to porovnáváním videa pøed tìmito pouitımi fitry
			s videem po aplikováním tìchto filtrù. Tedy Repair vyaduje
			dva klipy jako vstup. První klip je filtrovanı a druhı je
			nefiltrovanı klip. Jinak Repair pouívá stejné promìnné jako RemoveGrain, ale
			reimy 11-17, které nemají smysl pro Repair, jsou vypnuty. Tedy, v souèasnosti existuje
      pro Repair 10 reimù.
		</p>
		<p>Repair pracuje velmi podobnì jako RemoveGrain, ale na rozdíl od RemoveGrain, kde
			støedovı pixel a sousední pixely jsou oba ze stejného snímku klipu,
			v Repair je støedovı pixel (t.j. pixel kterı má bıt zmìnìn) brán z
			prvního klipu (t.j. filtrovanı klip) a sousední pixely jsou brány z
			druhého klipu (t.j. nefiltrovanı pùvodní klip). Napøíklad
			Repair(filtered, original, mode= 1)&nbsp;oøízne jas pixelu klipu
			"filtered", minimálním jasem a maximálním jasem sousedních pixelù
			pixelu v klipu "original". Tak Repair omezí mnoství zmìn z
			klipu "original" na klip "filtered". To je èistì nìjakı druh odstraòování artefaktù.
			Èím vyšší reim (jen od 1 do 4) , tím silnìjší odstraòování artefaktù.
			S <i>mode</i>=4, Repair(filtered, original, mode=4)
			je slušnì blízkı k RemoveGrain(original, mode= 4, limit= 0). Jak je popsáno vıše
			støedovı pixel pùvodního klipu by byl ignorován. To nemá smysl.
			Proto jsme provedli zmìny pro zaèlenìní také støedového
			pixelu pùvodního klipu pro všechny reimy Repair. Napøíklad, Repair(filtered,
			original, mode=1) oøízne støedovı pixel filtrovaného klipu minimem
			ze všech 8 sousedù a støedového pixelu pùvodního klipu na jedné stranì a
			maximem všech 8 sousedù a støedového pixelu pùvodního
			klipu na druhé stranì. Zvláštì Repair(input, input, mode=1) vùbec
			nezmìní klip input. Bez zahrnutí støedového pixelu pùvodního
			klipu, by byl Repair(input, input, mode= 1)&nbsp;identickı s
			RemoveGrain(input, mode= 1) nebo Undot(input). Obecnì máme
			RemoveGrain(input, mode=n) = Repair(input, input, n+1) pro n=0,1,2,3.
		</p>
		<p>Ve verzi 0.9 jsme pøidali nové reimy Repair, které jsou odvozené od reimù
			RemoveGrain jinım zpùsobem. K tomuto úèelu a je "f" jasovou hodnotou
			støedového pixelu filtrovaného klipu (kterı má bıt opraven) a "o" bude
			jasovou hodnotou stejného pixelu v pùvodním klipu. Pak jako v odpovídajícím
			reimu RemoveGrain, dva sousední pixely s jasovımi hodnotami, øeknìme, "n1", "n2" jsou
			zvoleny a&nbsp;"f" je oøíznut na min(n1,n2,o) a max(n1,n2,o). Samozøejmì,
			s barevností se pracuje stejnım zpùsobem. Takovı reim Repair lze  odvodit od jakéhokoli
			reimu RemoveGrain kromì reimù 11-16. Udìlali jsme to jen pro reimy 1-6, 17, 18.
			11-18 jsou odpovídající opravné repair reimy. Tedy reimy Repair 11-16
			odpovídají reimùm RemoveGrain 1-6, zatímco reimy Repair 17,18 odpovídají
			reimùm RemoveGrain 17,18. Pro mode 1 jsou obì metody pro odvození reimù Repair
			shodné, proto Repair(mode=1) a Repair(mode=11) jsou identické. (Repair mode
			16 je zvláštì dùleitı. Obnovuje tenké èáry a je dobrá šance
			(ale negarantovaná) , e budou obnoveny dokonce i koncové body. Je to v souèasnosti
			primární reim Repair pro skript RemoveDirt.
		</p>
		<p>Proberme si teï nìkteré pøíklady pro Repair. Prvním je pøedbìná verze
			 <b>RemoveDust</b>:
		</p>
		<p>
			<pre>function RemoveDust(clip input, int _mode)
{
	repmode = 16
	clensed = Clense(input)
	rep=Repair(clensed, input, mode=repmode)
	return RemoveGrain(rep, mode=_mode)
}</pre>

		</p>
		<p>Nejprve Clense brutálnì odstraní všechnu èasovou špínu, ale také zanechává hodnì
			artefaktù. Repair pak odstraní tyto artefakty, ale také obnoví všechny vìtší
			kusy špíny. Zatímco vìtšina pohybovıch artefaktù z Clense je odstranìna pomocí
			Repair, pohyb se trochu rozmae, ale statické oblasti jsou nedotèené.
			Nakonec RemoveGrain (doporuèuji mode=8, 17&nbsp;nebo mode=4 pro lepší
			kompresi) odstraní zbytky z Clense. Rozmazání pohybu má mnohem
			vıznamnìjší dopad na kompresi, ne rozmazání statickıch detailù.&nbsp;Na druhou
			stranu, lidské oko se ve skuteènosti neumí koncentrovat na pohyblivé detaily a mùe
			bıt dokonce "nervózní" z pohyblivıch detailù. Proto z mého pohledu je RemoveDust
			mnohem lepší ne obvyklı pøístup "rozmazání všeho malého" vìtšiny
			odšumovaèù.&nbsp; Pokud chcete agresivnìjší Removedust, mùete zvolit
			repmode= 1 a/nebo pouít RemoveGrain pøed Repair. Repair(mode= 9) je velmi
			zajímavı. Obnovuje všechny tenké èáry znièené v Clense. Pøesto je
			komprese pozoruhodnì dobrá (vıstupní velikost je obvykle ménì ne o
			5%-20% &nbsp;nad Repair(mode= 2) nebo Repair(mode= 5) . Doporuèuji
			pouít Repair jen s reimy 2, 5-9. Repair mùe bıt také pouit pro mírné zostøení:

			<pre>function ModerateSharpen(clip input, float amount)
{
	repmode = 16
	sharpened = Sharpen(input, amount)
	return Repair(sharpened, input, mode=repmode)
}</pre>

		</p>
		<p>Naneštìstí je u jméno LimitedSharpen pouito. Take budeme muset nazvat
			vıše uvedenou skriptovou funkci ModerateSharpen. Sharpen(1.0) vypadá opravdu ošklivì a je
			noèní mùrou pro jakıkoli kodek. Získali jsme následující kompresní vısledky (5000
			snímkù, vysoce kvalitní zdroj, 696x448, xvid 1.0.1 s kvantizerem 5):
		</p>
		<p>
			<pre>19.260.837 Bajtù	bez jakéhokoli filtrování
85.830.020 Bajtù	Sharpen(1.0)
41.743.528 Bajtù	ModerateSharpen(1.0), repmode=1
34.255.894 Bajtù	ModerateSharpen(1.0), repmode=2	</pre>

		</p>
		<p>Také ModerateSharpen(1.0) zvláštì s repmode=9 vypadá mnohem lépe ne
			Sharpen(1.0). Mode 10 není vhodnı pro mírné zostøovaèe.</p>
		<h2>TemporalRepair</h2>
		<p>Stejnım zpùsobem jakım je Repair odvozen z RemoveGrain, je TemporalRepair
			odvozen od Clense. Zatímco Repair je prostorovı filtr nejvhodnìjší pro
			odstraòování artefaktù èasovıch (temporal) filtrù jako Clense, TemporalRepair je
			èasovı filtr, primárnì uiteènı pro obnovení statickıch (nepohybujících se)
			detailù&nbsp;prostorovıch (spatial) filtrù jako&nbsp;RemoveGrain. Zvláštì
			RemoveGrain(mode= 4) ztrácí svùj "vypranı" vzhled, pokud se kombinuje s
			TemporalRepair:
			<pre>function RemoveTemporalGrain(clip input, int _mode)
{
	rg = RemoveGrain(input, mode=_mode)
	return TemporalRepair(rg, input)
}</pre>

		</p><p></p>
		<p>mode=4 je rozhodnì doporuèen pro RemoveTemporalGrain. Samozøejmì komprese
			RemoveTemporalGrain(4) vısupu je horší ne u RemoveGrain(mode= 4) ale
			je dostateènì nad více defenzivními reimy RemoveGrain a plnì zachovají
			statické detaily. Pro RemoveDust je situace ještì lepší:
			<pre>function RemoveDust(clip input, int _mode)
{
	repmode = 2
	clensed = Clense(input)
	rep=Repair(clensed, input, mode=repmode)
	rg = RemoveGrain(rep, mode=_mode)
	return TemporalRepair(rg, rep)
}</pre>

		</p><p></p>
		<p>Všimnìte si, e místo pùvodního klipu "input", je nyní brán støední klip "rep"
			jako druhı klip. Pøi srovnání pøedchozí verze RemoveDust
			se souèasnou (ještì ne finální) verzí, byl RemoveGrain prostì nahrazen
			RemoveTemporalGrain a zmìkèení je vıznamnì sníeno, pøi
			mode=4. Statické detaily dokonce zùstávají nedotèeny a komprese moc neutrpí.
			Pøesto jsou hrany objektù dokonce zostøeny, pokud nejsou tyto objekty
			pøíliš tenké, RemoveDust vypadá trochu mìkce a tenké pohyblivé objekty mohou bıt whiped
			out, dobrá èást mìkkosti je jen psychologická, protoe virtuálnì všechno
			pøírodní chvìní ve filmu, které neobsahuje jakoukoli informaci, ale
			na které je lidské oko docela zvyklé je odstranìno. Pokud je takové chvìní
			znovu uvedeno pomocí zostøovaèe po dekódování pøehrávaèem (s ffdshow napøíklad),
			pak RemoveDust klipy by mìli vypadat znovu docela ostøe (jiskrnì).
		</p>
		<p>TemporalRepair mùe bıt také pouit pro sestavení rozumnì rychlého odstranìní
    prokládání s vysokou kompresí, bez prahovıch hodnot, bez zmìny pohybu:</p>
		<p>
			<pre>function RGDeinterlace(clip input)
{
	rg = RemoveGrain(input, mode=12)
	return TemporalRepair(rg, input)
}</pre>

		</p>
		<p>&nbsp;Zatímco RemoveGrain(input, mode=12) odstraòuje prokládání z kadého pixelu, TemporalRepair
			obnovuje statické oblasti. Je typické spíše pro TemporalRepair, kdy
			filtr zaneøádí statické èásti videa, které mùe bıt pìknì obnoveno -
			bez jakıchkoli artefaktù - pomocí TemporalRepair. RGDeinterlace&nbsp;je
			blur deinterlacer, kterı se chová podobnì jako AlignFields(mode=2), ale
			bez jakéhokoli chvìní, protoe nemá prahové hodnoty. Pokud v jednom snímku
			"pohybová hodnota" oblasti je mírnì nad prahovou hodnotou a v následujícím je mírnì
			pod, pak je tato oblast deinterlována v jednom snímku a
			nezmìnìna v dalším. To se obvykle zobrazí jako blikání, co je typické pro
			pohybovì adaptivní odstraòovaèe prokládání zaloené na prahovıch hodnotách. To má docela negativní efekty na
			kompresi.&nbsp;Naneštìstí, v této formì RGDeinterlace pracuje docela
			špatnì na mé telegrafní testové pásce, protoe TemporalRepair&nbsp;obnovuje pøíliš mnoho.
			Pøestoe artefakty na mé testovací telegrafní pásce jsou viditelné jen pøi 400%
			zvìtšení ve VirtualDubu, ukazují, e deinterlacer není
			optimální pro kompresi, t.j. komprese je zbyteèná bez zvıšení kvality obrazu.
			Pro vylepšení vıkonu v tomto testu jsem pøidal celoèíselnou promìnnou
			<i>smooth</i> do TemporalRepair ve verzi 0.7. Pokud je <i>smooth</i>=0,
			vıchozí hodnotì, pak TemporalRepair pracuje jako døíve. Pokud je smooth= 1
			(v souèasnosti jsou povoleny jen hodnoty 0 a 1), tak TemporalRepair u není jen
			èistì èasovı (temporal), protoe bere také èasovou fluktuaci
			8 sousedních pixelù.&nbsp;Následnì pak TemporalRepair "opravuje" ménì s <i>
				smooth</i>=1 ne s <i>smooth</i>=0, ale stále vıslednı
			deinterlacer nemùe zpracovat telegrafní testovací pásku uspokojivì (pøestoe je
			lepší).&nbsp; Tak jsme pro tento úèel zavedli smooth=2,3 ve verzi 0.9 .
			Reim 2 obnovuje ménì ne mode 0,1,3 a je proto
			bezpeènìjším reimem pro odstranìní prokládání a dává celkem dobré kompresní vısledky. Reim 3
			je také vhodnı pro odstranìní prokládání a mìl by bıt zvolen, pokud uivatel chce
			zachovat maximální mnoství detailù. Na testovací telegrafní pásce pracuje reim 2 lépe
			ne reim 3 a mnohem lépe ne reim 1, stále není bez artefaktù.
			Nicménì, dobøe soupeøí s vìtšinou pohybovì adaptivních deinterlacerù
			(obvykle zaloenıch na prahovıch hodnotách) v tomto testu. Uivatel musí odstranit zbıvající
			artefakty dalším aplikováním RemoveGrain. Tímto zpùsobem získá
			následující deinterlacer:
		</p>
		<p>
			<pre>function RGDeinterlace(clip input)
{
	rg = RemoveGrain(input, mode=12)
	rg2 = TemporalRepair(rg, input, smooth=2)
	return RemoveGrain(rg2, mode=2)
}</pre>

		</p>
		<p>Nicménì, tento odstraòovaè prokládání se zøejmì nedrí principu ádnı pohyb ádná zmìna.
    Jiná myšlenka pro vylepšení odstranìní prokládání je <i>iterovat </i>TemporalRepair.
			Tímto zpùsobem získáme následující deinterlacer:
		</p>
		<p>
			<pre>function RGDeinterlace(clip input)
{
	rg = RemoveGrain(input, mode=12)
	rg2 = TemporalRepair(rg, input, smooth=2)
	return TemporalRepair(rg, rg2, smooth=2)
}</pre>

		</p>
		<p>Tato verze RGDeinterlace znovu ctí princip ádnı pohyb ádná zmìna a pracuje lépe
			na telegrafní testové pásce. Nicménì, s <i>smooth &gt; 0</i> je TemporalRepair
			vıraznì pomalejší ne se smooth=0 a iterace nemá smysl se
			smooth=0. Také má smysl pouít TemporalRepair(smooth=1) uvnitø skriptu
			RemoveDust.
		</p>
		<p>Odstraòovaèe prokládání uvedené vıše jsou všechny rozmazávací (blur) deinterlacery. Pro získání ostrıch
			deinterlacerù musíte nejdøíve pouít RemoveGrain s novım reimem 14. Napøíklad
			<pre>function RGSDeinterlace(clip input)
{
	rg = RemoveGrain(input, mode=16).RemoveGrain(mode=12)
	return TemporalRepair(rg, input, smooth=2)
}</pre>

			je ostrou verzí nejprimitivnìjší verze RGDeinterlace. Je dùleité
			pouít RemoveGrain s mode=12 po mode=14. Pokud se to neudìlá,
			pak je zachováno horní pole a spodní pole bude interpolováno,
			co vdy vede ke spíše slabé kompresi, protoe dvì pole
			se tolik liší (to lze pìknì zobrazit pomocí zostøovaèe).
			</p><h2>Rychlejší zpracování Èernobílého videa</h2>
		<p>Clense a TemporalRepair mají volitenou promìnnou <i>grey</i> . Pokud je <i>grey</i>=
			true, pak Clense a TemporalRepair nechají barevnost zcela nezpracovanou.
			Není dokonce ani zkopírována. Take se pak musí pouít vestavìnı filtr
			Greyscale v pozdìjší fázi pro vyèištìní náhodnıch hodnot z barevnosti.
			Tato monost je platná jen pro YV12 klipy a je ignorována pro ostatní barevná prostøedí.
			Stejného efektu lze dosáhnout u filtrù RemoveGrain a Repair pokud se
			nastaví modeU= -1. Zde je filtr RemoveDust jak jej teï pouívám:
			<pre>function RemoveDust(clip input, int "repmode", int "_smooth", bool
"_grey")
	{
	default(repmode, 16)
	default(_smooth, true)
	default(_grey, false)
	clmode = 4
	clensed = Clense(input, grey=_grey)
	rep=Repair(clensed, input, mode=repmode, modeU=_grey ? -1 : repmode )
	rg = RemoveGrain(rep, mode=clmode, modeU=_grey ? -1 : clmode)
	return TemporalRepair(rg, rep, grey=_grey, smooth=_smooth)
}</pre>

			Zde je mùj souèasnı odstraòovaè prokládání:
			<pre>function RGDeinterlace(clip input, bool _grey)
{
	rg = RemoveGrain(input, mode=12, modeU=_grey ? -1 : 12)
	rg2 = TemporalRepair(rg, input, smooth=2, grey=_grey)
	return RemoveGrain(rg2, mode=2, modeU=_grey ? -1 : 2)
}</pre>

			Zde je mùj souèasnı bob filtr (jen pro horní pole první):
			<pre>function RGBob(clip input, bool _grey)
{
	top = RemoveGrain(input, mode=16, modeU=_grey ? -1 : 16)
	bottom = RemoveGrain(input, mode=15, modeU=_grey ? -1 : 15)
	return Interleave(top, bottom)
}</pre>

			Pokud máte video se spodním polem prvním, musíte dosadit poslední
			øádek s "return Interleave(bottom, top)".
		</p>
		<h2>Barevná prostøedí</h2>
		<p>Do verze 0.7 filtry uvedené vıše také podporovaly barevná prostøedí YUY2,
			RGB24 a RGB32. Provádìlo se to vnitøním pøevedením tìchto prolínanıch (interleaved) formátù
			na planární formáty, pak tyto planární støední (mezi)formáty byly zpracovány jako YV12
			a nakonec støední planární formáty byly pøevedeny zpìt do
			pùvodních prolínanıch formátù. Pokud se, jako v nìkterıch skriptech vıše, pouívá
			hodnì instancí vıše uvedenıch filtrù, tyto pøevodní rutiny vedly k enormním reiím.
			Pøevodní rutiny nebyly také optimalizovány. Od verze
			0.8 jsme vypustili podporu pro prolínaná barevná prostøedí ve prospìch
			jejich planárních analogù. Pro Avisynth vypadají planární YUY2, RGB24 nebo RGB32 snímky
			právì jako obyèejné prolínané snímky tìchto barevnıch prostøedí. Nicménì,
			organizace dat v tìchto snímcích je velmi odlišná. Ještì nevydanı
			plugin SSETools (pøedbìné verze jsou zahrnuty do balíku RemoveGrain)
			obsahuje základní filtry Interleaved2Planar a Planar2Interleaved.
			Pro YV12 tyto filtry nedìlají absolutnì nic. Pro ostatní barevná prostøedí
			Interleaved2Planar pøevádí prolínané (interleaved) snímky na snímky s organizací
      planárních dat a Planar2Interleaved obrací tento pøevod. Tedy
			Interleaved2Planar().Planar2Interleaved a
			Planar2Interleaved.Interleaved2Planar(). nechají snímky nezmìnìné. Tak také
			Planar2Interleaved a Interleaved2Planar jsou bezeztrátové filtry. Pro YUY2 jsou
			filtry&nbsp;&nbsp;Interleaved2Planar() a Planar2Interleaved vysoce
			optimalizovány a nemìli by stát o moc víc ne jednoduchı bitblt. Nyní, abychom zakázali
			nezkušenım uivatelùm pouití filtrù uvedenıch vıše na prolínaná
			barevná prostøedí, pøidali jsme logickou promìnnou <i>planar</i> do
			RemoveGrain, Repair a TemporalRepair. Pokud <i>planar</i>=false (vıchozí hodnota),
			pak tyto filtry odmítnou YUY2, RGB24 a RGB32 snímky. Jen kdy je <i>planar</i>=true,
			tak tyto filtry akceptují YUY2, RGB24 a RGB32 vstup, ale vdy pøedpokládejte, e
			data jsou organizována planárním zpùsobem. Pokud pouijete <i>planar</i>=true na
			obyèejnı prolínanı vstup, získáte nesmysly. Clense a MCClense jako vìtšina jinıch
			èistì èasovıch filtrù, pracují stejnım zpùsobem s planárním i s prolínanım
			vstupem. Proto tyto filtry nemají promìnnou <i> planar</i> a pracují oba s
			planárním i prolínanım vstupem. TemporalRepair(smooth=0) je také èistì èasovı
			a tak pøijímá YUY2, RGB24 a RGB32 vstup, dokonce i pøi <i>planar</i>=false.
			Na druhou stranu,TemporalRepair(smooth=1) má také prostorové aspekty a
			proto odmítá jakékoli YUY2, RGB24 a RGB32 vstupy pøi <i>planar</i>=false.
			V ne velmi vzdálen budoucnosti by mìla existovat webová stránka <a href="http://www.planaryuy2.de.tf/">
				www.PlanarYUY2.de.tf</a> , která uvádí filtry a jejich kompatibilitu
			s planárními YUY2, RGB24, RGB32.
		</p>
		<p>Jako pøíklad pro pouití &nbsp; Planar2Interleaved a
			Interleaved2Planar uvedeme verzi RemoveDust, která pracuje pro YV12, a
			všechna prolínaná (interleaved) barevná prostøedí (ale ne planární YUY2, RGB24, RGB32):
			<pre> function RemoveDust(clip input, bool grey, int "repmode", int "_smooth")
{
	default(repmode, 16)
	default(_smooth, true)
	clmode = 4
	input = Interleaved2Planar(input)
	clensed = Clense(input, grey=_grey)
	rep=Repair(clensed, input, mode=repmode, modeU=_grey ? -1 : repmode )
	rg = RemoveGrain(rep, mode=clmode, modeU=_grey ? -1 : clmode)
	return TemporalRepair(rg, rep, grey=_grey, smooth=_smooth).Planar2Interleaved()
}</pre>
</p>
<p><kbd>$English Date: 2005/05/01 $</kbd></p>
<p><kbd>Èeskı pøeklad:19.5.2009</kbd></p>
	</body></html>