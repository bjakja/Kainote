<html>
	<head>
		<title>MT - Avisynth</title>
		<meta http-equiv="Content-Type" content="text/html; charset=windows-1250">
		<link rel="stylesheet" type="text/css" href="../../avisynth.css">

</head>
<body>

<h1>MT</h1>
<h2>Pøehled</h2>
<b>autor:</b>    tsp
<br><b>verze:</b>       0.7<br>
<b>stáhnout:</b>   <a href="http://www.avisynth.org/tsp/">http://www.avisynth.org/tsp/</a>,
<a href="http://www.avisynth.org/warpenterprises/">http://www.avisynth.org/warpenterprises/</a>
<br><b>kategorie:</b>   Rùzné pluginy
<br><b>poadavky:</b>&nbsp;
<ul>
</ul>
<p><b>licence:</b> GPL</p>

<hr size=2 width="100%" align=center>
<h2>Obsah</h2>
<ul>
 <li><a href="#MT_0.7">MT 0.7</li>
<ul><li><a href="#Abstract">Úvod</a></li>
 <li><a href="#Technical_info">Technické info</a></li>
 <li><a href="#Syntax">Syntaxe</a></li>
<ul><li><a href="#MT">MT</a></li>
    <li><a href="#MTi">MTi</a></li>
    <li><a href="#MTsource">MTsource</a></li>
</ul><li>	<a href="#Examples">Pøíklady</a></li>
 <li><a href="#Changelog">Seznam zmìn</a></li>
 </ul>
<li><a href="#modified_avisynth_MT_2.5.7.5">Modifikovanı avisynth 2.5.7.5</a></li>
  <ul>
   <li><a href="#Abstract_2">Úvod</a></li>
   <li><a href="#Example:">Pøíklad:</a</li>
   <li><a href="#How_to_development_threadsafe_filters">Jak vyvíjet vláknovì bezpeèné filtry</a></li>
 </ul>
 <li><a href="#Links">Odkazy</li>
</ul>

<a name="MT_0.7"></a>
<h2>MT 0.7</h2>
						<p><code>MT</code>(clip <var>clip</var>,string <var>filter</var>,int <var>threads</var>,int <var>overlap</var>,bool <var>splitvertical</var>)
						<p><code>MTi</code>(clip <var>clip</var>,string <var>filter</var>)</code>
						<p><code>MTsource</code>(string <var>filter</var>,int <var>delta</var>,int <var>threads</var>)</p>

<a name="Abstract"></a>
<h3>Úvod</h3>
						<p>MT je filtr, kterı umoòuje jinım filtrùm bìet na více vláknech. To by mìlo
							urychlit zpracování na hyperthreaded/vícejádrovıch procesorech nebo
							víceprocesorovıch systémech.
						</p>
						<p><b><FONT color="#ff0000">Dùleité: Nikdy nezapomeòte posoudit vısledek pohledem na
									zvıšení rychlosti a ne jen vyuití cpu.</FONT></b>
						</p>
						<p><i><FONT color="#ff0000">Také se podívejte na </FONT><a href="http://avisynth.org/mediawiki/MT_support_page">
									<FONT color="#ff0000"><cite>MT support page</cite></FONT></a><FONT color="#ff0000"> pro více
									informací ne poádáte o pomoc</FONT></i>
						</p>
<a name="Technical_info"></a>
<h3>Technické info</h3>
						<p>MT je filtr, kterı rozdìluje snímek na malé fragmenty, které jsou zpracovány v
							jednotlivıch vláknech a tím umoní plné vyuití víceprocesorovıch nebo hyperøetìzenıch (hyperthread)
							poèítaèù. Testoval jsem ho na mém starém abit bp6 s 2x celeron 400 MHz a
							zvıšil rychlost o 40%. Všimnìte si, e pokud u máte 100% zatíení cpu
							pøi zpracování avs skriptù bez MT (t.j pokud enkódujete do DivX/XviD) nemusíte
							pouít tento filtr.
						</p>
						<p>Tento filtr pracuje jako tato avs funkce:
						</p>
						<pre>function PseudoMT(clip c,string filter)
{
a=eval("c.crop(0,0,src.width/2,src.height)."+filter)
b=eval("c.crop(src.width/2,0,src.width/2,src.height)."+filter)
stackhorizontal(a,b)
}
</pre>
						<p><br>
							Jedinı rozdíl je, e a i b jsou vykonány paralelnì a je moné
							rozdìlit snímek do více ne 2 kusù. Pokud filtr pracuje s vıše uvedenım
							skriptem mìl by pracovat s MT , pokud je filtr vláknovì bezpeènı (thread safe). Dust nepracuje
							se skriptem vıše, take jestlie chcete pouít iip , pouijte jinı odšumovaè nebo donute
							Steadyho opravit chybu.
    <h4>Omezení</h4>
					<p>Aby filtr bìel, musí pøijímat jen jeden vstupní klip a tím je last. Filtr by také nemìl
							poèítat s obsahem celého snímku (jako smart
							deinterlacery) jinak je zde riziko, e bude zpracována jen èást snímku.
							Filtr by mìl bıt také vláknovì bezpeènı. Vìtšina filtrù je vláknovì bezpeèná,
							ale nìkteré budou vytváøet chybné vısledky nebo budou padat.
    <h4>Instalace</h4>
					<p>Zkopírujte mt.dll do sloky avisynth pluginù a zkopírujte zahrnutı soubor
							avisynth.dll do vaší sloky windows\system32 nebo tam, kde je umístìn váš pùvodní avisynth.dll
							a nezapomeòte si tento starı soubor avisynth.dll (pøejmenovat) pokud
							nemáte nainstalovanou verzi 2.6 .
						</p>
						<p>Od verze 0.7 jsou zahrnuty také další dva filtry:
						</p>
						<ul>
							<li>
								MTi() kterı vytváøí dvì vlákna a nechá kadé vlákno zpracovat jedno pole pøed
								jejich spojením jako tato avs funkce
							</li>
						</ul>
						<pre>function PseudoMTi(clip c,string filter)
{
a=eval("c.AssumeFieldBased().SeparateFields.selecteven()."+filter)
b=eval("c.AssumeFieldBased().SeparateFields.selectodd()."+filter)
interleave(a,b).weave()
}
</pre>
						<p>Jako další pseudoskript a i b jsou vykonány paralelnì. Všimnìte si, e jsou
            vytvoøena jen dvì vlákna, take vyuije jen dvì (virtuální) jádra.
						</p>
						<ul>
							<li>
								MTsource() kterı se pouívá pro bìh zdrojovıch filtrù vícevláknovì (multithreaded). Pracuje jako
								toto:
							</li>
						</ul>
						<pre>function PseudoMTsource(string filter)
{
SetMTmode(2)
eval(filter)
SetMtmode(0)
}
</pre>
						<p>Tedy na rozdíl od dvou ostatních filtrù je to èasovı (temporal) filtr kterı pøenáší
							snímky vpøed v èase a ukládá je do vyrovnávací pamìti (cache) pro rychlé znovuzískání.
						</p>
<a name="Syntax"></a>
<h3>Syntaxe</h3>
			<a name="MT"></a>
			<h4>MT</h4>
						<p><code>MT</code>(clip <var>clip</var>,string <var>filter</var>,int <var>threads</var>,int <var>overlap</var>,bool <var>splitvertical</var>)</span>
						</p>
						<p>Všechny parametry jsou jmenné. Parametry jsou:
						</p>
						<p><b>clip</b> <i>clip</i> = last<br>
							Vstupní klip.
						</p>
						<p><b>filter</b> <i>string</i> = nemá vıchozí hodnotu<br>
							Filtr, kterı má bìet na více vláknech. Všimnìte si, e filtr nesmí mìnit jak
							vıšku tak ani šíøku snímku (ale barevné prostøedí je okay) a je povolen jen 1 vstupní klip.
							Mùe to bıt jakıkoli vestavìnı filtr, avs skriptem definovanı filtr nebo externí plugin
							filtr dokud jsou dodrena omezení.
						</p>
						<p><b>threads</b> <i>int</i> = 2<br>
							Poèet pracovních vláken. Nastavte ho na poèet vláken která mohou
              na vašem poèítaèi bìet souèasnì.
						</p>
						<p><b>overlap</b> <i>int</i> = 0<br>
							- poèet pixelù pro pøidání na horní a spodní okraj nebo levı a pravı okraj.
							Zvyšte ho pokud vidíte artefakty v místì kde je snímek rozdìlen.
						</p>
						<p><b>splitvertical</b> <i>bool</i> = false<br>
							- pokud je true , snímky jsou rozøíznuty vertikálnì(a filtru je umonìno zmìnit
							vıšku) jinak je rozøíznut horizontálnì (a filtru je umonìno zmìnit
							šíøku).
						</p>
<a name="MTi"></a>
<h4>MTi</h4>
						<p><code>MTi</code>(clip <var>clip</var>,string <var>filter</var>)
						</p>
						<p>Všechny parametry jsou jmenné. Parametry jsou:
						</p>
						<p><b>clip</b> <i>clip</i> = last<br>
							Vstupní klip. Musí mít vıšku dìlitelnou 2 pro RGB a YUY2 barevná prostøedí a vıšku dìlitelnou 4 pro
							YV12 barevné prostøedí
						</p>
						<p><b>filter</b> <i>string</i> = nemá vıchozí hodnotu<br>
							Filtr, kterı má bìet na více vláknech. Všimnìte si, e filtr mùe mìnit jak
							vıšku tak i šíøku snímku ve stejném èase, ale je povolen jen 1 vstupní klip.
							Mùe to bıt jakıkoli vestavìnı filtr, avs skriptem definovanı filtr nebo externí plugin
							filtr dokud jsou dodrena omezení.
						</p>
						<p><br>
						</p>
<a name="MTsource"></a>
<h4>MTsource</h4>
						<p><code>MTsource</code>(string <var>filter</var>,int <var>delta</var>,int <var>threads</var>,int <var>max_fetch</var>)
						</p>
						<p>Všechny parametry jsou jmenné. Parametry jsou:
						</p>
						<p><b>filter</b> <i>string</i> = nemá vıchozí hodnotu<br>
							Zdrojovı filtr, kterı má bìet na více vláknech. V souèasnosti jsou podporovány pouze vnitøní a externí
              zdrojové filtry (jako DirectShowSource, Avisource, MPEG2Source) . Mùete pouít
							avs skriptem definovanı filtr nebo ne-zdrojovı filtr, ale to mùe spadnout nebo vytváøet
							poškozené snímky.
						</p>
						<p><b>delta</b> <i>int</i> = 1<br>
							Toto je kolik snímkù je mezi kadım poadavkem o snímek, take pokud hodláte
							èíst jen kadı druhı snímek nastavte ho na 2 nebo pokud ètete snímky
							zpìtnì, nastavte ho na -1. Komplexnìjší modely pøístupu ke snímku jako
							SelectEvery(10,3,6,7) nejsou podporovány (ale mohly by ostatnì pracovat, protoe ádané
							snímky jsou ve vyrovnávací pamìti (cache), kde bude prostor v pamìti od nevyadovanıch
							snímkù v cache)
						</p>
						<p><b>threads</b> <i>int</i> = 2<br>
							Poèet pracovních vláken. Nastavte ho na poèet vláken, která mohou
              na vašem poèítaèi bìet souèasnì.
						</p>
						<p><b>max_fetch</b> <i>int</i> = 30<br>
							Toto je maximální poèet snímkù vpøed od aktuálnì ádaného snímku,
							kterı MTsource pøenese. Jeho nízké nastavení nechá vlákna neèinná po
							èasu a pøíliš vysoké nastavení zabere pøíliš mnoho pamìti.
						</p>
<a name="Examples"></a>
<h3>Pøíklady</h3>
						<p>obyèejné rozmazání:
						</p>
						<pre>MT("blur(1)",2,2)
</pre>
						<p>také uivatelem definovaná funkce (pouívá variableblur):
						</p>
						<pre>MT("unsharp(2,0.7)",2,2)

function unsharpen(clip c,float variance,float k)
{
blr=binomialBlur(c,vary=variance,varc=2,Y=3,U=2,V=2)
return yv12lutxy(blr,c,"y x - "+string(k)+" * y +",y=3,u=2,v=2)
}
</pre>
						<p>Toto sice nevytvoøí zamıšlenı vısledek - urychlení, ale ukáe kdy pouít trojité
							uvozovky - kdy u jsou nìjaké pouité v parametru:
						</p>
						<pre>MT(""" subtitle("Doh") """,4,0)
</pre>
						<p>Pøíklad MTi
						</p>
						<pre>MTi("fft3dfilter()")
</pre>
						<p>vytváøí témìø stejnı vısledek jako
						</p>
						<pre>MT("fft3dfilter(interlaced=true)",threads=2)
</pre>
						<p>ale pro filtry, které nativnì nepodporují prokládanı obsah mùe bıt jednodušší
							pouít MTi()
						</p>
						<p>Pøíklad pro MTsource()
						</p>
						<pre>ir=MTSource(""" imagereader("c:\test.png") """,delta=1,threads=2,max_fetch=10)
as=MTSource(""" avisource("c:\test.avi") """,delta=-1) #delta záporné kvùli reverse()
ms=MTSource(""" MPEG2Source("c:\test.d2v") """,delta=9) #delta je 9 kvùli selectevery(9,1)
stackhorizontal(ir.trim(0,100),as.reverse().trim(0,100),ms.selectevery(9,1).trim(0,100))
</pre>
						<p><br>
						</p>
<a name="Changelog"></a>
<h3>Seznam zmìn</h3>
<pre>   * 0.1 first release.
   * 0.2 Should be more thread safe.
   * 0.21 forgot to comment out a Sleep(0)
   * 0.25 Added the splitvertical option
   * 0.3 More stable(and slower)
   * 0.4 Includes a custom version of avisynth 2.56 beta that should speed things up
   * 0.41 Minor speed increase
   * 0.5 Requires the included modified avisynth 2.5.6 or avisynth 2.6
   * 0.6 Bugfix: height can be changed with splitvertical=true without crashing. Also includes modified avisynth MT 2.5.7.3
   * 0.7 two new filters: MTi(), MTsource() and Avisynth MT 2.5.7.5
</pre>
						<p><br>
						</p>
<a name="modified_avisynth_MT_2.5.7.5"></a>
<h2>Modifikovanı avisynth MT 2.5.7.5</h2>
			<a name="Abstract_2"></a>
			<h3>Úvod</h3>
						<p>Obsahuje dvì nové funkce <code>SetMTMode()</code> a <code>GetMTMode()</code> a
							je potøeba MT.dll. Nainstalujte ho nahrazením avisynth.dll ve vaší sloce
							c:\windows\system32 (a pamatujte nejdøíve na zazálohování starého souboru).
          <P><b>Poznámka:</b> Ani oficiální verze Avisynthu 2.5.8 nepodporuje multhreading a tak vznikají poboèné pokusy o jeho vytvoøení.
          Najdete je zde <a href="http://forum.doom9.org/showthread.php?t=144852">http://forum.doom9.org/showthread.php?t=144852</a> a nebo zde
          <a href="http://forum.doom9.org/showthread.php?t=148117">http://forum.doom9.org/showthread.php?t=148117</a></p>
							<h4>Technické info</h4>
						</p>
						<p>Tyto funkce umoòují avisynthu pouít více ne jedno vlákno pøi zpracování
							filtry. To je uiteèné, kdy máte více ne jedno cpu/jádro nebo hyperthreading.
							Tato funkce je stále experimentální.
						</p>
				<a name="Syntax_2"></a>
				<h3>Syntaxe</h3>
						<p><code>GetMTMode</code>(bool <i>threads</i>)
							<p><b>threads</b> <i>bool</i> = false<br>
							Kdy je true <code>GetMTMode</code> vrací poèet vyuitıch vláken, jinak je
							vrácen reim mode (viz níe).
						</p>
						<p><code>SetMTmode</code>(int <var>mode</var>,int <var>threads</var>)
						</p>
						<p>Umístìte toto na první øádek v avs souboru, aby jste zapnuli èasovı - temporal (to je,
							e je zpracováno více ne jeden snímek ve stejném èase) multithreading. Pouijte ho pozdìji ve
							skriptu pro zmìnu reimu mode u filtrù níe.
						</p>
						<p><b>mode</b> <i>int</i> (2, vıchozí 1-6)<br>
							- existuje 6 reimù 1 a 6.
						</p>
						<pre>   * Mode 1 je nejrychlejší, ale pracuje jen s nìkolika filtry
   * Mode 2 by mìl pracovat s vìtšinou filtrù, ale vyuívá více pamìti
   * Mode 3 by mìl pracovat s nìkterımi z filtrù, které nepracují v reimu mode 2 ale je pomalejší
   * Mode 4 je kombinací mode 2 a 3 a mìl by pracovat s ještì více filtry, ale je ještì pomalejší a vyuívá ještì více pamìti
   * Mode 5 je nejpomalejší(<FONT color=#ff0000><STRONG>Pomalejší ne bez pouití SetMTMode</STRONG></FONT>) , ale mìl by pracovat se všemi filtry, které nevyadují lineární frameserving (to je snímky pøichází v poøadí snímek 0,1,2 ... poslední)
   * Mode 6 je upravenı mode 5 , kterı by mohl bıt mírnì rychlejší
</pre>
						<p>Podrobnìjší vysvìtlení rùznıch reimù si mùete pøeèíst zde: <a href="http://avisynth.org/mediawiki/MT_modes_explained" title="MT modes explained">
								MT modes explained</a>
						</p>
						<p><b>threads</b> <i>int</i> = 0<br>
							Poèet pouitıch vláken. Nastavte na 0 pro jeho nastavení na poèet dostupnıch procesorù.
							Není moné mìnit poèet vláken jinak ne v
							prvním SetMTMode.
						</p>
<a name="Example:"></a>
<h3>Pøíklad:</h3>
						<pre>SetMTMode(2,0) #zapne multihreading pouitím thread = na poèet dostupnıch procesorù a mode 2
LoadPlugin("...\LoadPluginEX.dll") #potøebnı pro naètení avisynth 2.0 pluginù
LoadPlugin("...\DustV5.dll") #Naète Pixiedust
import("limitedsharpen.avs")
src=AVIsource("test.avi")
SetMTMode(5) #mìní mode na 5 pro øádky níe
src=src.converttoyuy2().PixieDust()#Pixiedust potøebuje mode 5 aby fungoval.
SetMTMode(2) #mìní mode zpìt na 2
src.LimitedSharpen() #protoe LimitedSharpen pracuje s mode 2 dobøe
subtitle("Pocet pouzitych vlaken: "+string(GetMTMode(true))+" Aktualni MT Mode: "+string(GetMTMode())) #Zobrazí mode a poèet pouitıch vláken
</pre>
<a name="How_to_development_threadsafe_filters"></a>
<h3>Jak vyvíjet vláknovì bezpeèné (threadsafe) filtry</h3>
						<p>Není zaruèeno ádné lineární poøadí snímkù (kromì pøípadu kdy je pouito MT místo setmtmode) a pro
							kadı reim mode existují rùzná omezení:
						</p>
						<ul>
							<li>
								Mode 1: veškeré pøístupy do tøídy promìnnıch, globálních promìnnıch a statickıch promìnnıch
								musí bıt vláknovì bezpeèné pouitím vhodného uzamèení (Enter/LeaveCriticalSection atd,
								uzamèení nepotøebují promìnné jen pro ètení (readonly)), protoe více ne 1 vlákno mùe pøistoupit k
								tøídì instancí v èase.
							</li>
						</ul>
						<ul>
							<li>
								Mode 2: pøístup k tøídì promìnnıch nemusí bıt vláknovì bezpeènı, protoe existuje jen
								1 instance tøídy na vlákno. Všechny pøístupy ke globálním/statickım promìnnım musí
								bıt vláknovì bezpeèné. Protoe kadá tøída instance zpracovává jen kadı další snímek
								internal caches (to je cache uvnitø filtru), nepracovala by dobøe. Vytvoøil jsem
								PClipLocalStorage pro sdílení pointer mezi rùznımi instancemi filtru.
							</li>
						</ul>
						<ul>
							<li>
								Mode 3: Je povoleno jen 1 vlákno pro vykonání kódu z filtru ve stejném èase.
								Kdy je vyzváno child-&gt;GetFrame , jiné vlákno mùe vzít filtr a
								vykonat kód. To znamená, e tøída promìnnıch/globálních promìnnıch/statickıch promìnnıch
								by mìla bıt pøiøazena pro nìjaké hodnoty pøed po tom, kdy bylo voláno lastchild-&gt;GetFrame.
								Místo promìnnıch lokální funkce by mìlo bıt pouito nìco takovéhoto:
							</li>
						</ul>
						<pre>PVideoFrame __stdcall AdjustFocusV::GetFrame(int n, IScriptEnvironment* env) {
PVideoFrame frame = child-&gt;GetFrame(n, env);
//Assigned to a local variable so this will work in mode 3
env-&gt;MakeWritable(&amp;frame); if (!line) line = new uc[frame-&gt;GetRowSize()+32];
uc* linea = (uc*)(((int)line+15) &amp; -16);// Align 16
uc* buf = frame-&gt;GetWritePtr();
int pitch = frame-&gt;GetPitch();
int row_size = vi.RowSize();
int height = vi.height;
memcpy(linea, buf, row_size); // First row - map centre as upper
if ((pitch &gt;= ((row_size+7) &amp; -8)) &amp;&amp; (env-&gt;GetCPUFlags() &amp; CPUF_MMX))
{
 AFV_MMX(linea, buf, height, pitch, row_size, amount); }
else
{
 AFV_C(linea, buf, height, pitch, row_size, amount); }
return frame;
}
</pre>
						<p>Ale ne jako toto:
						</p>
						<pre>PVideoFrame TemporalSoften::GetFrame(int n,IScriptEnvironment* env) {
__int64 i64_thresholds = 0x1000010000100001i64;
int radius = (kernel-1) / 2&nbsp;;
int c= 0;
// Just skip if silly settings
if((!luma_threshold)&amp;&amp; (!chroma_threshold) || (!radius))
  return child-&gt;GetFrame(n,env);
for(int p= 0;p&lt;16;p++) planeDisabled[p]=false;
 for(p= n-radius;p&lt;=n+radius;p++)
  {
   frames[p+radius-n] = child-&gt;GetFrame(min(vi.num_frames-1,max(p,0)), env);
   //GetFrame assigned to class variable frames. This wouldn't work with Mode 3
   //because the next thread that enters this getframe will overwrite the result
   // from the last thread }
  //do stuff
  }
</pre>
						<p>Ale pøi pouití mode 3 není ádná potøeba pro vláknovì bezpeènı pøístup do tøídy promìnnıch.
							A protoe je jen 1 instance tøídy, která zpracuje všechny snímky,
							internal caches bude pracovat mnohem lépe. Horší vìc je, e vykonat filtr v èase mùe jen 1 vlákno,
							take pokud je to jen pomalı filtr ve skriptu,
							urychlení by nebylo tak velké.
						</p>
						<ul>
							<li>
								Mode 4: kombinace mode 2 a 3 take je to okay pro pøiøazení tøídy promìnnıch
								pøed vızvou lastchild-&gt;getframe , protoe je jedna tøída
								instance na vlákno, ale problém s internal cache je stejnı jako u mode 2.
							</li>
						</ul>
						<ul>
							<li>
								Mode 5: Bez omezení.
							</li>
						</ul>
						<ul>
							<li>
								Mode 6: Mírnì upravená verze mode 5 , která mùe bıt trochu rychlejší.
							</li>
						</ul>
						<p>PClipLocalStorage
						</p>
						<p>Zde je pøíklad jak mùe bıt pouit PClipLocalStorage pro sdílení cache
							mezi více instancemi (které jsou vytvoøeny pomocí mode=2,4):
						</p>
						<pre>class Cache
{
public: //These function should be threadsafe. The most simple way is to use
 a //critical section like
 this PVideoFrame GetCachedFrame(int
 framenumber)
 {
  EnterCriticalSection(&amp;cs);
  //Code

  //...
  LeaveCriticalSection(&amp;cs);
  return retval;
 } SetCachedFrame(PVideoFrame
frame);
private:
 CRITICAL_SECTION cs;
}

class Sample&nbsp;: public GenericVideoFilter{
public:
 Sample(PClip _child, IScriptEnvironment* env);
 ~Sample();
 PVideoFrame __stdcall GetFrame(int n, IScriptEnvironment* env);
protected:
 PClipLocalStorage cls;
 Cache* FrameCache;
}

Sample::Sample(PClip _child, IScriptEnvironment* env)
:
GenericVideoFilter(_child),cls(env)
{ //if the cache has not been created yet GetValue will return 0
 if(cls-&gt;GetValue()==0) {
 //create the cache and save the address in the PClipLocalStorage
 FrameCache =  new
 Cache();cls-&gt;SetValue(static_cast(FrameCache));
 }
 // The cache has been created so assign the address to FrameCache
 else  {
 FrameCache=static_cast(cls-&gt;GetValue());
 }
}

Sample::~Sample()
{
//only delete FrameCache if it is not delete yet.
if(cls-&gt;GetValue()!=0)  {
 delete FrameCache;
 cls-&gt;SetValue(0);//Signal that the cache is deleted
 }
}
</pre>
<a name="Links"></a>
<h2>Odkazy</h2>
						<p><a href="http://www.avisynth.org/tsp/" title="http://www.avisynth.org/tsp/">stránky filtrù od tsp</a></p>
						<p><a href="http://forum.doom9.org/showthread.php?t=94996" title="http://forum.doom9.org/showthread.php?t=94996">oficiální vlákno na doom9.org forum</a> Ètìte prosím tuto stránku
							a stránku podpory níe pøed tím ne se budete ptát na pomoc - díky.</p>
						<p><a href="http://avisynth.org/mediawiki/MT_support_page" title="MT support page">MT stránka podpory</a></p>
						<p>Získáno z"<a href="http://avisynth.org/mediawiki/MT">http://avisynth.org/mediawiki/MT</a>"

<p><kbd>Èeskı pøeklad:2.7.2009</kbd>
	</body>
</html>
