<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
<!-- Automatically generated, don't change: $Id: syntax.htm,v 1.3 2005/10/09 16:27:46 macpaille Exp $ -->







  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">











  <title>AviSynth 2 - Basic Syntax</title>
  <link rel="stylesheet" type="text/css" href="../avisynth.css">
</head>


<body>




<h2><a name="Gettingstarted"></a>D&eacute;marrer
avec Avisynth</h2>




<p>A la base, Avisynth travaille de la mani&egrave;re
suivante:&nbsp;premi&egrave;rement, vous cr&eacute;ez un
simple document texte avec des commandes
sp&eacute;ciales,&nbsp;
appel&eacute; script.&nbsp;Ces commandes font
r&eacute;f&eacute;rences &agrave; une ou plusieurs videos
et aux filtres que vous souhaitez utiliser sur elles.&nbsp;Puis,
vous lancez une application video, telle que VirtualDub, et vous ouvrez
le fichier script.&nbsp;C'est alors qu'AviSynth rentre en action.
Il ouvre les videos que vous avez
r&eacute;f&eacute;renc&eacute; dans votre script, applique
les filtres sp&eacute;cifi&eacute;s, et fourni un fichier video
de sortie pour l'application video.&nbsp;L'application , de
quelques mani&egrave;res que ce soit,ne sait pas qu'avisynth
travaille en fond.&nbsp;Au lieu de cela, l'application pense
qu'elle ouvre directement un fichier AVI filtr&eacute;
plac&eacute; sur votre disque dur. </p>




<p>Il y a beaucoup de nouvelles fonctions ou de fonctions
retravaill&eacute;es dans AviSynth2.&nbsp;Pour que cela soit
clairement visible (particuli&egrave;rement quand ces
fonctionnalit&eacute;s n'&eacute;taient pas bien
document&eacute;es dans le pass&eacute;) elles sont
indiqu&eacute;es par <strong>v2</strong> </p>




<p>La version 2.5 est une mise &agrave; jour interne
importante. Lisez <a href="twopointfive.htm" target="main">AviSynth
2.5</a>&nbsp;prudemment avant de l'utiliser. Des changements
importants sont&nbsp;indiqu&eacute;s par <strong>v2.5</strong>
</p>




<h4><b><u>&Eacute;dition Lin&eacute;aire:</u></b></h4>




<p>La chose la plus simple que vous pouvez faire avec Avisynth
est que vous pouvez faire de l'&eacute;dition de la m&ecirc;me
mani&egrave;re que dans VirtualDub.&nbsp;Il est facile
d'&eacute;crire des scripts de ce type parce que si vous voulez,
vous pouvez ne pas vous pr&eacute;occuper des variables et des
expressions compliqu&eacute;es.</p>




<p>Pour tester, cr&eacute;ez un fichier appel&eacute;
test.avs en y incluant la simple ligne suivante :
</p>




<pre>Version</pre>




<p>Maintenant, ouvrez le fichier avec Windows Media Player par
exemple et vous devriez voir une video de 10 secondes afficher le
num&eacute;ro de la version d'Avisynth install&eacute; sur
votre syst&egrave;me et un avis de copyright. </p>




<p><code>Version</code>&nbsp;est ce qui s'appelle
un "filtre de source", signifiant qu'il produit un clip au lieu d'en
modifier un. La premi&egrave;re commande dans un script Avisynth
sera toujours un filtre de source. </p>




<p>Maintenant, ajoutez une seconde ligne &agrave; votre
fichier script, de sorte qu'il soit lu comme ceci: <br>




&nbsp; </p>




<pre>Version<br>ReduceBy2&nbsp;</pre>




<p>R&eacute;-ouvrez le fichier dans Windows Media Player.
Vous devriez voir &agrave; nouveau l'avis de copyright, mais
maintenant &agrave; moiti&eacute; moins grand qu'avant.<br>




<code><a href="corefilters/reduceby2.htm">ReduceBy2</a></code>
est un "filtre de transformation," signifiant qu'il prend le clip
pr&eacute;c&eacute;dent et qu'il le modifie d'une quelconque
mani&egrave;re. Vous pouvez encha&icirc;ner
simultan&eacute;ment un bon nombre de filtres de transformation, de
la m&ecirc;me mani&egrave;re que dans VirtualDub.<br>




Ajoutons une nouvelle fonction pour obtenir un fondu au noir
&agrave; la fin de la video.&nbsp;Ajoutez une ligne
&agrave; votre script, de sorte qu'il soit lu ainsi: </p>




<pre>Version<br>ReduceBy2<br>FadeOut(10)</pre>




<p>Maintenant, r&eacute;-ouvrez le fichier dans votre player.
Le clip devrait &ecirc;tre identique pendant les 9 premi&egrave;res
secondes, et s'effacer doucement vers le noir dans la
derni&egrave;re seconde.<br>




Le filtre <a href="corefilters/fade.htm">FadeOut</a>
prend un argument num&eacute;rique,&nbsp;qui indique le nombre
de frames &agrave; inclure dans le fondu. </p>




<p>Le fondu commence assez tard, nous allons donc couper le
d&eacute;but du clip pour r&eacute;duire l'attente, et faire un
fondu apr&egrave;s.&nbsp;<br>




Coupons les 120 premi&egrave;res images, et gardons les images
allant de 120 &agrave; 150: <br>




&nbsp; </p>




<pre>Version<br>ReduceBy2<br>Trim(120,150) # supprime les 119 premi&egrave;res images, et conserve les images de 120 &agrave; 150 (AviSynth commence la num&eacute;rotation &agrave; 0)<br>FadeOut(10)</pre>




<p>Dans cet exemple, nous utilisons pour la premi&egrave;re
fois un commentaire.<br>




Les commentaire d&eacute;butent avec le caract&egrave;re # et
continuent jusqu'&agrave; la fin de la ligne. Ils sont
compl&egrave;tement ignor&eacute;s par Avisynth. <br>




Le filtre <a href="corefilters/trim.htm">Trim</a>
prend deux arguments,&nbsp;s&eacute;par&eacute;s par une
virgule:&nbsp;la premi&egrave;re et la derni&egrave;re
image du clip que vous souhaitez conserver. Si vous mettez 0 pour la
derni&egrave;re image, c'est comme si vous mettiez " fin de clip".
Ainsi, Si vous voulez supprimer les 119 premi&egrave;re images d'un
clip, vous devriez utiliser la commande Trim(120,0).&nbsp; </p>




<p>S'y retrouver dans la num&eacute;rotation des images de
cette mani&egrave;re est&nbsp;une corv&eacute;e. Il est
beaucoup plus facile d'ouvrir un script partiel dans une application
comme VirtualDub qui vous indiqueras les num&eacute;ros
d'images.&nbsp;Vous
pouvez &eacute;galement utilisez le filtre <a href="corefilters/showframes.htm"> ShowFrameNumber</a>&nbsp;qui
&eacute;crit le num&eacute;ro de l'image sur l'image elle
m&ecirc;me. </p>




<p>Dans la pratique un filtre de source beaucoup plus utile
que&nbsp;<a href="corefilters/version.htm">Version</a>
est
<a href="corefilters/avisource.htm">AVISource</a>,
qui lit le contenu des fichier AVI (ou de plusieurs autres types de
fichiers) &agrave; partir du disque. Si vous disposez d'un fichier
AVI &agrave; porter de main, vous pouvez essayer d'appliquer les
filtres suivants &agrave; votre fichier:<br>




&nbsp; </p>




<pre>AVISource("d:\capture.avi")&nbsp;&nbsp; # <font size="2">o&ugrave; vous indiquez le chemin d'acc&egrave;s actuel de votre fichier</font><br>ReduceBy2<br>FadeOut(15)<br>Trim(120,0)</pre>




<p>M&ecirc;me un script d'une seule ligne contenant la
commande&nbsp; AVISource peut &ecirc;tre utile pour ajouter le
support de fichiers AVI sup&eacute;rieurs &agrave; 2GO pour des
applications qui ne les supportent habituellement pas.<br>




</p>




<hr>
<h4><b><u>&Eacute;dition Non-Lin&eacute;aire :</u></b></h4>




<p>Maintenant nous allons en venir &agrave; la partie
amusante. Faites un fichier AVS avec le script suivant : </p>




<pre>StackVertical(Version, Version)</pre>




<p>Maintenant ouvrez le. R&eacute;sultat: Une sortie video avec deux
lignes identiques de version, l'une au dessus de l'autre.<br>




Au lieu de prendre des nombres ou des cha&icirc;nes de caract&egrave;res
comme arguments,&nbsp;<a href="corefilters/stack.htm">StackVertical</a>&nbsp;prends
le clip vid&eacute;o comme argument.&nbsp;Dans ce script le
filtre Version&nbsp;est appel&eacute; deux fois.&nbsp;A
chaque fois que, il renvoie une copie de de la version du clip . Ces 2
clips sont ensuite transmis &agrave; <a href="corefilters/stack.htm">StackVertical</a>,&nbsp;qui
les assemble (sans savoir d'o&ugrave; ils sont venus). </p>




<p>Un des filtres du m&ecirc;me type les plus utiles
est&nbsp;<a href="corefilters/splice.htm">UnalignedSplice</a>,
qui
joint les clips video bout &agrave; bout.&nbsp;Voici un script
qui charge trois fichiers AVI (tels qu'ils pourraient &ecirc;tre
produits par AVI_IO) et les met bout &agrave; bout. </p>




<pre>UnalignedSplice(AVISource("d:\capture.00.avi"), AVISource("d:\capture.01.avi"), AVISource("d:\capture.02.avi"))</pre>




<p><a href="corefilters/stack.htm">StackVertical</a>
et <a href="corefilters/splice.htm">UnalignedSplice</a>
peuvent prendre aussi bien deux arguments qu'une soixantaine. <br>




Vous pouvez utiliser l'op&eacute;rateur + comme raccourci pour <a href="corefilters/splice.htm">UnalignedSplice</a>. </p>




<p>Par exemple, ce script agit de la m&ecirc;me
mani&egrave;re que le pr&eacute;c&eacute;dent exemple: </p>




<pre>AVISource("d:\capture.00.avi") + AVISource("d:\capture.01.avi") + AVISource("d:\capture.02.avi")</pre>




<p>Maintenant supposons que vous capturiez avec une application
qui sauvegarde &eacute;galement la vid&eacute;o dans de
multiples segments AVI, mais qui mets l'audio dans un fichier wav
ind&eacute;pendant. <br>




Pouvons nous recombinez le tout? Bien s&ucirc;r que oui: </p>




<pre>AudioDub(AVISource("d:\capture.00.avi")+AVISource("d:\capture.01.avi")+AVISource("d:\capture.02.avi"), WAVSource("d:\audio.wav"))</pre>




<hr>
<h2><a name="Syntax"></a>Syntaxe </h2>




<h4>Expressions:</h4>




<p>Un script Avisynth se compose de multiples lignes de
d&eacute;clarations ressemblant &agrave; ceci: </p>




<pre>variable_name = expression</pre>




<p>Dans cet exemple l'expression est &eacute;valu&eacute;
et le r&eacute;sultat est assign&eacute; &agrave; la
variable_name. </p>




<p>La forme commune du raccourci est tr&egrave;s importante :
</p>




<pre>expression</pre>




<p>Dans ce cas l'expression est &eacute;valu&eacute; et
le r&eacute;sultat est assign&eacute; au clip particulier
variable&nbsp;<var>last</var>. <br>




Ce qui est identique &agrave; : </p>




<pre>last = expression</pre>




<p>La fin du script est toujours semblable &agrave; : </p>




<pre>return expression</pre>




<p>Ici l'expression est &eacute;valu&eacute;e, et est
employ&eacute;e comme "la valeur de retour" du script --
c'est-&agrave;-dire, le clip vid&eacute;o qui sera vue par
l'application qui ouvre le fichier AVS.</p>




<p>La forme de base d'une expression qui appelle une fonction
est:
</p>




<pre>Fonction(args)</pre>




<p>Les fonctions de clip produisent toujours un nouveau clip et
ne modifient jamais celui existant,<br>




Args&nbsp;est une liste d'arguments de la fonction qui sont
s&eacute;par&eacute;s par des virgules.&nbsp;La liste peut
&ecirc;tre vide (ce qui signifie que tout les arguments, ou
quelques uns seulement peuvent &ecirc;tre facultatifs). </p>




<p>Si la fonction attend un clip comme son premier argument, et
que cet argument n'est pas fourni, alors le clip dans la variable
particuli&egrave;re&nbsp;<var>last </var>sera
utilis&eacute;.</p>




<p>Les filtres Avisynth peuvent prendre des arguments
nomm&eacute;s. Les arguments nomm&eacute;s peuvent
&ecirc;tre indiqu&eacute;s dans n'importe quel ordre, et le
filtre choisira les valeurs par d&eacute;faut pour ceux que vous ne
pr&eacute;ciserez pas (les arguments nomm&eacute;s sont
toujours facultatifs). Ceci permet une utilisation beaucoup plus facile
de certains filtres.</p>




<pre>Vous pouvez &eacute;crire<br><br>Subtitle("Hello, World!", text_color=$00FF00, x=100, y=200)<br><br>&agrave; la place de<br><br>Subtitle("Hello, World!", 100, 200, 0, 999999, "Arial", 24, $00FF00)</pre>




<p>Une syntaxe alternative (appel&eacute;e "OOP notation")
pour des fonctions de clip est: [OOP = Object Oriented programming--
programmation orient&eacute; objet] </p>




<pre>expression.Fonction(args)<br><br>Par ex.:<br>Version.ReduceBy2.FadeOut(15)</pre>




<p>Ce qui &eacute;quivaut &agrave;: </p>




<pre>Fonction(expression, args)<br><br>Par ex.:<br>FadeOut(15, ReduceBy2(Version))</pre>




<p>et peut &ecirc;tre consid&eacute;r&eacute; comme
la <code>Fonction</code>&nbsp;appliqu&eacute;e
&agrave; l'<code>expression</code>. <br>




L'un des inconv&eacute;nients de la notation OOP est qu'elle peut
seulement &ecirc;tre employ&eacute;e avec les filtres qui
prennent un seul argument&nbsp;clip, et non pas avec les filtres
qui en prennent plusieurs. </p>




<p>Toutes les fonctions d'avisynth produisent un nombre
pr&eacute;cis d'images et une fr&eacute;quences d'images(fps)
en sortie, m&ecirc;me si cette id&eacute;e semble
tr&egrave;s complexe.<br>




Avisynth sait, apr&egrave;s avoir lu le script , de combien de
temps sera le fichier de sortie, quelle est la fr&eacute;quence
d'images et quel est "l'ordre de d&eacute;coupage" de toutes les
sources utilis&eacute;es.<br>




Tout ceci est calcul&eacute; &agrave; l'ouverture du script.
Seul le filtrage est fait en phase d'ex&eacute;cution de la requ&ecirc;te.<br>




</p>




<hr>
<p><b>Commentaires</b>: Avisynth ignore tout ce qui
suit le caract&egrave;re # et ce jusqu'&agrave; la fin de la
ligne.</p>




<p><b>Ignore la casse</b>: aViSouRCe est aussi bon
que AVISource. </p>




<b>Continue</b> &agrave; la ligne suivante ou
pr&eacute;c&eacute;dente: \
<pre>Subtitle ("Test-Text")<br><br>Subtitle ( \<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Test-Text")<br><br>Subtitle (&nbsp;<br> \ "Test-Text")</pre>




<p> </p>




<hr>
<h4>Variables:</h4>




<p>Le nom d'une variable peut contenir jusqu'&agrave; 50
caract&egrave;res et peut &eacute;galement contenir des
lettres, des chiffres, et des soulignages (_), mais aucun autres
caract&egrave;res. Le nom ne peut pas commencer par un chiffre. </p>




<p>Les types de variables suivants peuvent &ecirc;tre
employ&eacute;s: </p>




<p><var>clip</var>: un clip video contenant
vid&eacute;o et/ou audio . Au moins une variable pour un clip doit
&ecirc;tre employ&eacute;e et retourn&eacute;e par le
script.<br>




<var>string</var>: cha&icirc;ne de caract&egrave;re
entour&eacute; soit par des "guillemets" ou par des triples
guillemet comme """cet exemple""". Un texte string peut contenir
n'importe quel caract&egrave;re except&eacute; les guillemets de fin ou double-apostrophe. Si vous devez mettre des guillemets
&agrave; l'int&eacute;rieur d'une variable string, employez la
notation triple guillemets:</p>




<pre>Subtitle ("""Cela affiche "hello world" entre guillemets""")</pre>




<p><var>int:</var> nombre entier entr&eacute;
comme une cha&icirc;ne de chiffres, avec au choix un + ou - au
d&eacute;but.<br>




<var>float:</var> nombre &agrave; virgule
entr&eacute; comme une cha&icirc;ne de chiffres avec un point (.) quelque
part dans la cha&icirc;ne et un facultatif + ou -. Par exemple, +1. est
trait&eacute; comme nombre &agrave; virgule-flottante.<br>




<var>val:</var> type d'un argument de fonction
o&ugrave; cela n'a pas d'importance si c'est entier ou flottant<br>




<var>bool</var>: peut &ecirc;tre TRUE (vrai) ou FALSE
(faux)<br>




<var>hexadecimal numbers</var>: nombre hexad&eacute;cimal.
L'entrer en le pr&eacute;c&eacute;dant d'un $. cette variable
est trait&eacute;e comme un nombre entier. Plusieurs filtres
emploient cette notation pour indiquer des couleurs. Par exemple,
$$FF8800 est une nuance d'orange. </p>




<p><var>global</var>:&nbsp;d&eacute;finit une
variable globale, qui peut &ecirc;tre employ&eacute;e en commun
par toutes les fonctions d&eacute;finies pour l'utilisateur et le
script principal.
</p>




<p>Voici une autre version de l'exemple utilis&eacute; un peu
plus t&ocirc;t sous une forme plus maniable et plus facile
&agrave; comprendre: </p>




<pre>a = AVISource("d:\capture.00.avi")<br>b = AVISource("d:\capture.01.avi")<br>c = AVISource("d:\capture.02.avi")<br>Piste_audio = WAVSource("d:\audio.wav")<br><br>AudioDub(a+b+c, sound_track)</pre>




<p> </p>




<hr>
<h2><a name="Operators"></a>Op&eacute;rateurs
</h2>




<p>Pour tout types d'op&eacute;randes (clip, int, float,
string, bool) vous pouvez utiliser: <br>




<code>==</code> est &eacute;gal<br>




<code>!=</code> n'est pas &eacute;gale<br>




<code>||</code> ou<br>




<code>&amp;&amp;</code> et </p>




<p>Pour des types num&eacute;riques(int, float): <br>




<code>+ </code>additionner<br>




<code>- </code>soustraire<br>




<code>* </code>multiplier<br>




<code>/ </code>diviser<br>




<code>% </code>module<br>




<code>&gt;=</code> sup&eacute;rieur ou
&eacute;gal &agrave;<br>




<code>&lt;=</code> inf&eacute;rieur ou
&eacute;gal &agrave;<br>




<code>&lt; </code>moins grand que<br>




<code>&gt;&nbsp;</code>plus grand que </p>




<pre><font size="2">Dans ses anciennes versions, AviSynth analysait de droite &agrave; gauche les expressions, ce qui a donn&eacute; des r&eacute;sultats inattendus:</font> <br><br> a = 10 - 5 - 5 donnait 10 - (5 - 5) = 10 au lieu de (10 - 5) - 5 = 0 !<br> <br><font size="2">Ce bug a &eacute;t&eacute; corrig&eacute;!</font><br>A partir de v2.53 les multiplications et les divisions sont &eacute;galement analys&eacute;es de la gauche vers al droite (au lieu de la droite vers la gauche).</pre>




<p>Pour des types string: <br>




<code>+ </code>additionner<br>




<code>&gt;=</code> sup&eacute;rieur ou
&eacute;gal &agrave; (non sensible &agrave; la casse)<br>




<code>&lt;=</code>&nbsp;inf&eacute;rieur ou
&eacute;gal &agrave; (non sensible &agrave; la casse) <br>




<code>&lt; </code>moins que (non sensible &agrave;
la casse)<br>




<code>&gt;&nbsp;</code>plus que (non sensible
&agrave; la casse) </p>




<p>Pour des types clip: <br>




<code>+&nbsp;</code>la m&ecirc;me que la fonction <code>UnalignedSplice</code>
<br>




<code>++</code>&nbsp;la m&ecirc;me que la fonction <code>AlignedSplice</code>
</p>




<p>Pour des types bool: <br>




<code>?:</code> ex&eacute;cute le code
conditionnellement <br>




&nbsp; </p>




<pre>b = (a==true) ? 1 : 2<br><br>Cela peut &ecirc;tre traduit par:<br><br>if (a=true) then b=1 else b=2&nbsp;</pre>




<p> </p>




<hr>
<h2><a name="ScriptFunctions"></a>Fonctions </h2>




<p> Les entr&eacute;es et les sorties de ces fonctions ne
sont pas des clips, mais d'autres variables utilis&eacute;es dans
le script. </p>




<p></p>




<h4><b><u>Fonctions num&eacute;riques:</u></b></h4>




<table border="1" width="75%">




  <tbody>




    <tr>




      <td width="62%"><code>MulDiv(<var>int,
int, int</var>)</code>: (m*n+d/2)/d avec
r&eacute;sultat interm&eacute;diaire en 64bit</td>




      <td width="40%"><code>MulDiv</code> (1,
1, 2) = 1<br>




      <code>MulDiv</code> (2, 3, 2) = 3</td>




    </tr>




    <tr>




      <td width="62%"><code>Floor(<var>float</var>)</code>:
arrondit &agrave; l'entier inf&eacute;rieur</td>




      <td width="40%"><code>Floor</code> (1.2)
= 1<br>




      <code>Floor</code> (1.6) = 1<br>




      <code>Floor</code> (-1.2) = -2<br>




      <code>Floor</code> (-1.6) = -2</td>




    </tr>




    <tr>




      <td width="62%"><code>Ceil</code> (<var>float</var>):&nbsp;arrondit
&agrave; l'entier sup&eacute;rieur</td>




      <td width="40%"><code>Ceil</code> (1.2)
= 2.0<br>




      <code>Ceil</code> (1.6) = 2.0<br>




      <code>Ceil</code> (-1.2) = -1<br>




      <code>Ceil</code> (-1.6) = -1</td>




    </tr>




    <tr>




      <td width="62%"><code>Round</code> (<var>float</var>):
arrondit</td>




      <td width="40%"><code>Round</code> (1.2)
= 1<br>




      <code>Round</code> (1.6) = 2<br>




      <code>Round</code> (-1.2) = -1<br>




      <code>Round</code> (-1.6) = -2</td>




    </tr>




    <tr>




      <td width="62%"><code>Int</code> (<var>float</var>):&nbsp;convertit
un float en int (partie enti&egrave;re).</td>




      <td width="40%"><code>Int</code> (1.2) =
1<br>




      <code>Int</code> (1.6) = 1<br>




      <code>Int</code> (-1.2) = -1<br>




      <code>Int</code> (-1.6) = -1</td>




    </tr>




    <tr>




      <td width="62%"><code>Float</code> (<var>int</var>):&nbsp;convertit
un int vers un float.</td>




      <td width="40%">&nbsp;</td>




    </tr>




    <tr>




      <td width="62%"><code>Frac</code> (<var>float</var>):&nbsp;renvoie
la partie d&eacute;cimale du float.</td>




      <td width="40%"><code>Frac</code> (3.7)
= 0.7<br>




      <code>Frac</code> (-1.8) = -0.8</td>




    </tr>




    <tr>




      <td height="4" width="62%"><code>Abs</code>
(<var>integer</var>) / <code>Abs</code> (<var>float</var>):&nbsp;valeur
absolue pour nombre entier et float.</td>




      <td height="4" width="40%"><code>Abs</code>
(-3.8) = 1.8</td>




    </tr>




    <tr>




      <td width="62%"><code>Sign</code> (<var>int</var>)
/ <code>Sign</code> (<var>float</var>):&nbsp;renvoie
le signe du nombre comme-1, 0 ou 1.</td>




      <td width="40%"><code>Sign</code>(-3.5)
= -1<br>




      <code>Sign</code>(3.5) = 1<br>




      <code>Sign</code>(0) = 0</td>




    </tr>




    <tr>




      <td height="24" width="62%"><code>HexValue</code>
(<var>string</var>): renvoie la valeur d'une
cha&icirc;ne hexad&eacute;cimale.</td>




      <td height="24" width="40%"><code>HexValue</code>
("FF00") = 65280</td>




    </tr>




    <tr>




      <td colspan="2"></td>




    </tr>




    <tr>




      <td width="62%"><code>Sin</code> (<var>float</var>):
sinus d'un float</td>




      <td width="40%"></td>




    </tr>




    <tr>




      <td width="62%"><code>Cos</code> (<var>float</var>):
cosinus d'un float</td>




      <td width="40%"></td>




    </tr>




    <tr>




      <td width="62%"><code>Pi</code> (): Pi</td>




      <td width="40%"></td>




    </tr>




    <tr>




      <td width="62%"><code>Log</code> (<var>float</var>):
logarithme d'un float</td>




      <td width="40%"></td>




    </tr>




    <tr>




      <td width="62%"><code>Exp</code> (<var>float</var>):
exponentiel d'un float</td>




      <td width="40%"></td>




    </tr>




    <tr>




      <td height="24" width="62%"><code>Pow</code>
(<var>float base, float puissance</var>): puissance d'un
float par un float</td>




      <td height="24" width="40%"></td>




    </tr>




    <tr>




      <td width="62%"><code>Sqrt</code> (<var>float</var>}:
racine carr&eacute;e d'un float</td>




      <td width="40%"></td>




    </tr>




    <tr>




      <td colspan="2"></td>




    </tr>




    <tr>




      <td width="62%"><code>Rand</code>(<var>[int
max] [, bool scale] [, bool seed]</var>): renvoie un entier
al&eacute;atoire entre 0 et max. Par d&eacute;faut:<br>




&nbsp; max = 32768 <br>




&nbsp; scale = TRUE ( TRUE = mode normal, FALSE = mode module) <br>




&nbsp; seed = FALSE (TRUE = utilise le temps comme point de
d&eacute;part)</td>




      <td width="40%"><code>Rand</code>(100) =
nombre entier entre 0 et 99</td>




    </tr>




    <tr>




      <td width="62%"><code>Spline</code> (<var>float
X,&nbsp; x1,y1, x2,y2, ...., bool "cubic"</var>}<strong>
v2.5</strong> <br>




&nbsp;Interpole la valeur de Y au point X en utilisant les points
de control x1/y1, ...<br>




&nbsp;Il doit y avoir au moins 2 paires x/y<br>




&nbsp;L'interpolation peut &ecirc;tre cubique(le
r&eacute;sultat est une spline) ou lin&eacute;aire (le
r&eacute;sultat est un polygone) </td>




      <td width="40%"><code>Spline</code> (5,
0,0, 10,10, 20,0, false) = 5<br>




      <code>Spline</code> (5, 0,0, 10,10, 20,0, true) = 7</td>




    </tr>







  </tbody>
</table>




<h4>Fonctions de cha&icirc;nes:</h4>




<table border="1" width="80%">




  <tbody>




    <tr>




      <td width="53%"><code>UCase</code> (<var>string</var>):
renvoie la cha&icirc;ne en majuscules</td>




      <td width="60%"><code>UCase</code>
("AviSynth") = "AVISYNTH"</td>




    </tr>




    <tr>




      <td width="53%"><code>LCase</code> (<var>string</var>):
renvoie la cha&icirc;ne en minuscules</td>




      <td width="60%"><code>LCase</code>
("AviSynth") = "avisynth"</td>




    </tr>




    <tr>




      <td width="53%"><code>RevStr</code> (<var>string</var>):
renvoie la cha&icirc;ne &agrave; l'envers</td>




      <td width="60%"><code>RevStr</code>
("AviSynth") = "htnySivA"</td>




    </tr>




    <tr>




      <td width="53%"><code>StrLen</code> (<var>string</var>):
renvoie la longueur de la cha&icirc;ne</td>




      <td width="60%"><code>StrLen</code>
("AviSynth") = 8</td>




    </tr>




    <tr>




      <td width="53%"><code>Findstr</code> (<var>string1,
string2</var>):<br>




renvoie le d&eacute;calage de la cha&icirc;ne string2 par rapport
&agrave; string1. La recherche est sensible &agrave; la casse</td>




      <td width="60%"><code>Findstr</code>
("AviSynth","syn") = 4</td>




    </tr>




    <tr>




      <td width="53%"><code>LeftStr</code> (<var>string,
length</var>) / <code>RightStr</code> (<var>string,
length</var>):<br>




renvoie une certaine longueur (donn&eacute;e par length) de la
partie droite ou gauche d'une cha&icirc;ne</td>




      <td width="60%"><code>LeftStr</code>
("AviSynth",3) = "Avi"</td>




    </tr>




    <tr>




      <td width="53%"><code>MidStr</code> (<var>string,
start [, length]</var>):<br>




renvoie une partie de la cha&icirc;ne en commen&ccedil;ant &agrave;
start (pour le premier caract&egrave;re, start=1) dont la longueur
est donn&eacute;e par length (ou alors jusqu'&agrave; la fin si
length n'est pas sp&eacute;cifi&eacute;)</td>




      <td width="60%"><code>MidStr</code>
("AviSynth",3,2) = "iS"</td>




    </tr>




    <tr>




      <td width="53%"><code>VersionNumber</code>
()</td>




      <td width="60%"><code>VersionNumber</code>
() = 2.07</td>




    </tr>




    <tr>




      <td width="53%"><code>VersionString</code>
()</td>




      <td width="60%"><code>VersionString</code>
() = "AviSynth 2.08 (avisynth.org) 22 nov. 2002"</td>




    </tr>




    <tr>




      <td width="53%"><code>Chr</code> (<var>int</var>):
renvoie le caract&egrave;re ASCII correspondant <strong>v2.5</strong></td>




      <td width="60%"><code>Chr</code> (34)
renvoie le caract&egrave;re guillemet (")</td>




    </tr>




    <tr>




      <td width="53%"><code>Time</code> (<var>string</var>):
renvoie une cha&icirc;ne correspondant au temps donn&eacute; par le
syst&egrave;me format&eacute; sous la forme d&eacute;fini
par le param&egrave;tre string <strong>v2.5</strong></td>




      <td width="60%">Codes pour le formatage du texte de
sortie: <br>




      <br>




%a Jour le la semaine abr&eacute;g&eacute;<br>




%A Jour le la semaine complet<br>




%b Mois abr&eacute;g&eacute; <br>




%B Mois complet<br>




%c Date et heure appropri&eacute; pour votre localisation<br>




%d Jour du mois au format nombre d&eacute;cimal (01 &ndash; 31)
      <br>




%H Heure au format 24 heures (00 &ndash; 23) <br>




%I Heure au format 12 heures (01 &ndash; 12) <br>




%j Jour de l'ann&eacute;e au format nombre d&eacute;cimal (001
&ndash; 366) <br>




%m Mois au format nombre d&eacute;cimal (01 &ndash; 12) <br>




%M Minute au format nombre d&eacute;cimal (00 &ndash; 59) <br>




%p Localisation actuelle&sbquo; indicateurs A.M./P.M. pour les
syst&egrave;mes au format 12 heures.<br>




%S Secondes au format nombre d&eacute;cimal (00 &ndash; 59) <br>




%U Semaine de l'ann&eacute;e au format nombre d&eacute;cimal,
avec dimanche comme premier jour de la semaine (00 &ndash; 53) <br>




%w Jour de la semaine au format nombre d&eacute;cimal(0 &ndash;
6; Dimanche est 0) <br>




%W Semaine de l'ann&eacute;e au format nombre d&eacute;cimal,
avec lundi comme premier jour de la semaine (00 &ndash; 53) <br>




%x Date pour la localisation actuelle<br>




%X Heure pour la localisation actuelle<br>




%y Ann&eacute;e sans le si&egrave;cle,&nbsp;au format
nombre d&eacute;cimal (00 &ndash; 99) <br>




%Y&nbsp;Ann&eacute;e avec le si&egrave;cle,&nbsp;au
format nombre d&eacute;cimal<br>




%z, %Z Nom du fuseau horaire ou abbr&eacute;viation. Pas de
caract&egrave;re si la zone est inconnue.<br>




%% Signe pour cent (%)



      <p>Le signe # peut pr&eacute;c&eacute;d&eacute;
n'importe lequel des codes de formatage. Dans ce cas, leur
signification devient la suivante:</p>







      <p>%#a, %#A, %#b, %#B, %#p, %#X, %#z, %#Z, %#% Le signe #
est ignor&eacute;.&nbsp; <br>




%#c Format long pour l'indication de date et d'heure, correspondant
&agrave; la localisation actuelle. Par exemple: &ldquo;Mardi,
Mars 14, 1995, 12:41:29&bdquo;.&nbsp; <br>




%#x&nbsp;Format long pour l'indication de date, correspondant
&agrave; la localisation actuelle. Par exemple: &ldquo;Mardi,
Mars 14, 1995&bdquo;.&nbsp; <br>




%#d, %#H, %#I, %#j, %#m, %#M, %#S, %#U, %#w, %#W, %#y, %#Y Supprime les
z&eacute;ros en d&eacute;but de nombre (s'il y en a). </p>




      </td>




    </tr>







  </tbody>
</table>




<p>
</p>




<h4>Conversions:</h4>




<table border="1" width="75%">




  <tbody>




    <tr>




      <td width="50%"><code>Value</code> (<var>string</var>):
Renvoie la valeur d'une cha&icirc;ne</td>




      <td width="50%"><code>Value</code> (
"-2.7" ) = -2.7</td>




    </tr>




    <tr>




      <td width="50%"><code>String</code> (<var>float
/ int / string, format_string</var>): convertit un nombre en
cha&icirc;ne:<br>







      <p>Si la variable est un flottant ou un entier, la fonction
la convertit en flottant est utilise l'argument format_string pour la
convertir en cha&icirc;ne.</p>







      <p>La syntaxe pour l'argument format_string est la suivante:</p>







      <p>%[balise][largeur][.precision]f<br>




width: la largeur minimum (la cha&icirc;ne n'est jamais tronqu&eacute;e)<br>




precision: le nombre de chiffre conserv&eacute;s apr&egrave;s
la virgule<br>




balise:<br>




      <tt>&nbsp;-&nbsp;&nbsp;&nbsp;</tt>alignement
&agrave; gauche (sinon alignement &agrave; droite)<br>




      <tt>&nbsp;+&nbsp;&nbsp; </tt>affiche
toujours le signe +/-&nbsp;<br>




      <tt>&nbsp;0&nbsp;&nbsp; </tt>remplir
avec des z&eacute;ros au d&eacute;but<br>




      <tt>&nbsp;'&nbsp;' </tt>ajoute un blanc
&agrave; la place de "+"<br>




      <tt>&nbsp;#&nbsp;&nbsp;&nbsp;</tt>affiche
toujours la virgule de la d&eacute;cimale</p>




      </td>




      <td width="50%">e.g. <code>Subtitle</code>
("La hauteur du clip est: " + <code>String</code> (last.height) )<br>




      <br>




      <code>String</code>(1.23, "%f") = '1.23'<br>




      <code>String</code>(1.23, "%5.1f") = ' 1.2'<br>




      <code>String</code>(1.23, "%1.3f") = '1.230' </td>




    </tr>







  </tbody>
</table>




<p></p>




<h4>Fonctions de test:</h4>




<p><code>IsBool(<var>var</var>) </code><br>




<code>IsInt(<var>var</var>) </code><br>




<code>IsFloat(<var>var</var>) </code><br>




<code>IsString(<var>var</var>) </code><br>




<code>IsClip(<var>var</var>) </code>
</p>




<p></p>




<h4>Autres fonctions:</h4>




<p><code>Select</code> (<var>index, item0 [,
item1...]</var>): Renvoie le composant
s&eacute;lectionn&eacute; par l'index (0=item0). Les composant
peuvent &ecirc;tre n'importe quelle variable ou clip. Ils peuvent
m&ecirc;me &ecirc;tre m&eacute;lang&eacute;s.<br>




<code>Defined</code> (<var>var</var>): pour
d&eacute;finir un param&egrave;tre optionnel dans une fonction
utilisateur.<br>




<code>Default</code> (<var>x, d</var>): renvoie
x si Defined(x), d sinon. <br>




<code>Exist</code> (<var>filename</var>):
renvoie TRUE ou FALSE apr&egrave;s avoir
v&eacute;rifi&eacute; si le fichier existe.<br>




<code>NOP</code> (): renvoie NULL, utilis&eacute;
principalement pour des actions conditionnelles avec des composants qui
n'ont pas de valeur de retour (tel que la fonction import) et sans utilisation
de la condition "else".</p>




<p> <code>Eval</code> (<var>string</var>),<br>




<code>Apply</code> (<var>func-string, arg,...</var>):
<code>Eval</code> ("f(x)") est &eacute;quivalent
&agrave; <code>f(x)</code> est &eacute;quivalent
&agrave; <code>Apply</code> ("f", x)
</p>




<pre>Vous pouvez utiliser Eval pour des chose telles que:<br>settings = "352, 288"<br>Eval( "BicubicResize(" + settings + ")" )</pre>




<p><code>Import</code>(<var>filename</var>):
&eacute;value le contenu d'un autre script avisynth (importe le
texte d'un autre script) </p>




<p>Pour le signalement d'erreurs et pour le transfert de messages
d'erreurs vers une fonction utilisateur, vous pouvez utiliser:<br>




<code>Assert</code>(<var>bool, string error-message</var>)
</p>




<p><code>Try ... Catch</code>: c'est une fonction qui
v&eacute;rifie si une erreur SURVIENDRA:
</p>




<pre>Try {<br>&nbsp; AviSource("file.avi")<br>}<br>Catch(err_msg) {<br>&nbsp;&nbsp; Blackness.Subtitle(err_msg)<br>}</pre>




<hr>
<h2><a name="RuntimeFunctions"></a>Fonctions
d'ex&eacute;cution</h2>




<p>Depuis quelques temps, Avisynth&nbsp;int&egrave;gre <a href="corefilters/conditionalfilter.htm" target="main">Conditional
Filters</a> qui &eacute;value le script pendant qu'une image
est trait&eacute;e. Vous pouvez donc changer des variables sur
l'&eacute;chelle de temps de l'image.<br>




Pour plus d'applications, il y a les <a href="corefilters/conditionalfilter.htm#RuntimeFunctions" target="main">Runtime Functions</a> qui
&eacute;valuent le contenu d'un clip et renvoient une valeur. <strong>v2.5</strong>
<br>




&nbsp; </p>




<pre>Un exemple simple est de calculer la luminosit&eacute; moyenne et de l'afficher sur chaque image.<br><br><br>Version()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # g&eacute;n&egrave;re un clip pour ce test<br>ConvertToYV12&nbsp;&nbsp; # conversion dans l'espace de couleur YV12<br>FadeIn(10)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # fondu qui va cr&eacute;er un changement de luminosit&eacute; sur le clip version<br><br>ScriptClip(" Subtitle(String(AverageLuma())) ")&nbsp; # utilise Subtitle(...) pour chaque image<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # la valeur de sortie de AverageLuma est convertit en cha&icirc;ne<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # et affich&eacute;e sur le clip d'entr&eacute;e<br>ConvertToRgb&nbsp;&nbsp;&nbsp; # conversion dans l'espace de couleur RGB</pre>




<hr>
<h2><a name="ControlFunctions"></a>Fonctions
de contr&ocirc;le </h2>




<p><code>SetMemoryMax</code> (<var>int</var>):
Force le maximum de m&eacute;moire qu'AviSynth utilisera (en Mo)<strong>
v2</strong></p>




<p>Dans certaines version, le param&egrave;tre par
d&eacute;faut est de&nbsp;5Mo, ce qui est relativement faible.
Si vous rencontrez des probl&egrave;mes (par ex. une faible
vitesse) essayez de mettre cette valeur &agrave; 32Mo. Valeur de
retour: Actual MemoryMax value set.</p>




<p><code>SetPlanarLegacyAlignment</code> (<var>clip,
bool</var>): Passe en mode d'alignement pour les images planes. <strong>v2.5.6</strong></p>




<p>Quelques plugins assez anciens font des suppositions sur la structure des
images en m&eacute;moire. Ce filtre force la structure en
m&eacute;moire des images planes &agrave; &ecirc;tre
compatible avec de pr&eacute;c&eacute;dentes versions
d'avisynth. Ce filtre agit sur la pile d'appel GetFrame(), et
il intervient donc sur les filtres <strong>avant</strong>
qu'ils ne soient appliqu&eacute;s.</p>




<pre><strong>Exemple : Utiliser une ancienne version de Mpeg2Source()</strong><br>LoadPlugin("...\Mpeg2Decode.dll")<br>Mpeg2Source("test.d2v") 	# Un plugin qui suppose (de mani&egrave;re incorrecte) la structure de la m&eacute;moire<br>SetPlanarLegacyAlignment(true) 	# D&eacute;fini l'alignement m&eacute;moire pour contourner la supposition du filtre<br>ConvertToYUY2() 		# Cette moficfication sur l'alignement m&eacute;moire est r&eacute;percut&eacute;e <br>... 				# jusqu'&agrave; la fin du script.</pre>




<p><code>SetWorkingDir</code> (<var>string</var>):
D&eacute;finir le repertoire par defaut d'Avisynth. <strong>v2</strong></p>




<p>Ceci est principalement utilis&eacute; pour le chargement
de video sources, etc. N'affecte pas le chargement automatique des
plugins. Valeur de retour: 0 si &ccedil;a marche, -1 sinon.</p>




<hr>
<h2><a name="ClipProperties"></a>Porpri&eacute;t&eacute;s
d'une video</h2>




<p>Ces fonction prennent un clip en entr&eacute;e et renvoie
une propri&eacute;t&eacute; de ce clip. </p>




<p><code>Width</code> (<var>clip</var>),
largeur<br>




<code>Height</code> (<var>clip</var>), hauteur<br>




<code>Framecount</code> (<var>clip</var>),
nombre d'image<br>




<code>Framerate</code> (<var>clip</var>),
fr&eacute;quence de lecture des images ( en images par seconde)<br>




<code>FramerateNumerator</code> (<var>clip</var>),
num&eacute;rateur pour la fr&eacute;quence de lecture des
images (un framerate &agrave;
virgule du type, 23.976 est en fait d&eacute;crit comme une
fraction:
23976/1000, 23976 r&eacute;pr&eacute;sente le
num&eacute;rateur, 10000 le d&eacute;nominateur)
<strong>v2.55</strong><br>




<code>FramerateDenominator</code> (<var>clip</var>),
d&eacute;nominateur pour la fr&eacute;quence de lecture des
images
<strong>v2.55</strong><br>




<code>Audiorate</code> (<var>clip</var>),
fr&eacute;quence d'&eacute;chantillonnage du flux audio<br>




<code>Audiolength</code> (<var>clip</var>)
-&nbsp;longueur du flux audio, limit&eacute;e &agrave; 2^31
&eacute;chantillons<br>




<code>AudiolengthF</code> (<var>clip</var>)
-&nbsp;renvoie le nombre d'&eacute;chantillons sous forme de
flottant <strong>v2.55</strong><br>




<code>Audiochannels</code> (<var>clip</var>),
nombre de canaux du flux audio<br>




<code>Audiobits</code> (<var>clip</var>),
nombre de bits sur lesquelles sont cod&eacute;es les information
audio<br>




<code>IsAudioFloat</code> (<var>clip</var>) <strong>v2.55</strong><br>




<code>IsAudioInt</code> (<var>clip</var>) <strong>v2.55</strong><br>




<code>IsRGB</code> (<var>clip</var>), test si
un clip est au format de couleur RGB<br>




<code>IsRGB24</code> (<var>clip</var>), test si
un clip est au format de couleur RGB24<br>




<code>IsRGB32</code> (<var>clip</var>), test si
un clip est au format de couleur RGB32<br>




<code>IsYUY2</code> (<var>clip</var>), test si
un clip est au format de couleur YUY2<br>




<code>IsYV12</code> (<var>clip</var>), test si
un clip est au format de couleur YV12 <strong>v2.51</strong><br>




<code>IsYUV</code> (<var>clip</var>), test si
un clip est au format de couleur YUV <strong>v2.54</strong>
<br>




<code>IsPlanar</code> (<var>clip</var>), test
si un clip est a format de couleur plan&nbsp; <strong>v2.51</strong>
<br>




<code>IsInterleaved</code> (<var>clip</var>),
test si un clip est contieent de la video et de l'audio
entrelac&eacute;s <strong>v2.51</strong>
<br>




<code>IsFieldBased</code> (<var>clip</var>),
test si un clip est sous forme de champs<br>




<code>IsFrameBased</code> (<var>clip</var>),
test si un clip est sous forme d'images<br>




<code>GetParity</code> (<var>clip</var>) <br>




<code>HasAudio</code> (<var>clip</var>) <strong>v2.56</strong>
<br>




<code>HasVideo</code> (<var>clip</var>) <strong>v2.56</strong>
<br>




</p>




<pre>N'oubliez pas: vous pouvez utiliser les propri&eacute;t&eacute;s des clip avec la notation LAST ou la notation OOP:<br><br>BilinearResize(Width/2, Height/2)<br>&nbsp;&nbsp; est la m&ecirc;me chose que<br>BilinearResize(Width(Last)/2, Height(Last)/2)<br> est la m&ecirc;me chose que<br>BilinearResize(Last.Width / 2, Last.Height / 2)</pre>




<p> </p>




<hr>
<h2><a name="userdefined"></a>Fonctions&nbsp;utilisateur </h2>




<p>Vous pouvez d&eacute;finir vos propres fonctions. Le mieux
est encore de l'expliquer &agrave; l'aide d'un exemple: <br>




&nbsp; </p>




<pre>Function NTSC2PAL( clip c) {<br>&nbsp;&nbsp;&nbsp; Assert(c.height == 480, "NTSC2PAL: le clip d'entr&eacute;e doit avoir 480 lignes")<br>&nbsp;&nbsp;&nbsp; Bob(c, height=576)<br>&nbsp;&nbsp;&nbsp; return Weave()<br>}</pre>




<p>M&ecirc;me des fonctions r&eacute;cursives peuvent
&ecirc;tre d&eacute;finies. <br>




&nbsp; </p>




<pre>function TRANSITION(clip clip, int start,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int expo, int overlap)<br>{<br>&nbsp;&nbsp; return ( start &gt;= clip.framecount-expo ?&nbsp;<br>&nbsp;&nbsp; \&nbsp;&nbsp; Trim(clip,start,0) :&nbsp;<br>&nbsp;&nbsp; \&nbsp;&nbsp; Dissolve(Trim(clip,start,start+expo-1),<br>&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRANSITION(clip,start+expo,expo,overlap),<br>&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; overlap&nbsp;<br>&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )<br>}</pre>




<p> </p>




<hr>
<h2><a name="multiclip"></a>Fonctions avec
plus d'un clip en entr&eacute;e </h2>




<p>Il y a des fonctions qui combinent deux videos ou plus de
diff&eacute;rentes mani&egrave;res. La mani&egrave;re donc
la video de sortie est calcul&eacute;e est d&eacute;crite pour
chaque fonction, mais voici un r&eacute;sum&eacute; des
propri&eacute;t&eacute;es que les videos auront.&nbsp; </p>




<p>Les videos d'entr&eacute;e doivent toujours avoir le
m&ecirc;me format de couleur et les m&ecirc;me dimensions
(&agrave; l'exception de <i>Layer</i>).<br>




&nbsp;
<table border="1">




  <tbody>




    <tr>




      <td></td>




      <td>



      <center> <b>fr&eacute;quence des images</b>
      </center>




      </td>




      <td colspan="2">



      <center> <b>nombre d'images</b> </center>




      </td>




      <td>



      <center> <b>audio</b> </center>




      </td>




      <td>



      <center> <b>fr&eacute;quence d'echantillonnage<br>




du flux audio&nbsp;&nbsp;</b> </center>




      </td>




    </tr>




    <tr>




      <td><b>AlignedSplice, UnalignedSplice</b></td>




      <td rowspan="6">



      <center>premier clip </center>




      </td>




      <td>



      <center> somme de tous les clips </center>




      </td>




      <td></td>




      <td>



      <center>voir la description du filtre </center>




      </td>




      <td rowspan="7">



      <center>premier clip </center>




      </td>




    </tr>




    <tr>




      <td><b>Dissolve</b></td>




      <td>



      <center> somme de tous les clips moins la dur&eacute;e
du fondu </center>




      </td>




      <td></td>




      <td>



      <center>voir la description du filtre </center>




      </td>




    </tr>




    <tr>




      <td><b>Merge, MergeLuma, MergeChroma, Merge(A)RGB</b></td>




      <td rowspan="2">



      <center>premier clip </center>




      </td>




      <td rowspan="5">



      <center>la derni&egrave;re image<br>




&nbsp;du clip<br>




le plus court<br>




est r&eacute;p&eacute;t&eacute;e jusqu'a la fin<br>




du clip </center>




      </td>




      <td rowspan="5">



      <center>premier clip </center>




      </td>




    </tr>




    <tr>




      <td><b>Layer</b></td>




    </tr>




    <tr>




      <td><b>Subtract</b></td>




      <td rowspan="2">



      <center>clip le plus long </center>




      </td>




    </tr>




    <tr>




      <td><b>StackHorizontal, StackVertical</b></td>




    </tr>




    <tr>




      <td><b>Interleave</b></td>




      <td>



      <center> (fps du premier clip) <br>




x <br>




(nombre de clips) </center>




      </td>




      <td>



      <center> N x nombre d'images du clip le plus long </center>




      </td>




    </tr>







  </tbody>
</table>




</p>




<p>Comme vous pouvez le voir, ces fonctions ne sont pas
compl&egrave;tement sym&eacute;triques et prennent certaines
propri&eacute;t&eacute;es au PREMIER clip seulement.<br>




</p>




<hr>
<h2><a name="Plugins"></a>Plugins </h2>




<p>Avec ces fonctions, vous pouvez ajouter des fonctions externes
&agrave; AvisynthWith these functions you can add external
functions to
AviSynth. </p>




<p><code>LoadPlugin</code> (<var>"filename" [,
...]</var>) </p>




<p>Charge un ou plusieurs plugins ext&eacute;rieurs
&agrave; Avisynth (DLLs). <br>




</p>




<hr>
<p><code>LoadVirtualDubPlugin</code> (<var>"filename",
"filtername", preroll</var>) </p>




<p>Cela charge un plugin &eacute;crit pour VirtualDub.
"filename" est le nom du fichier&nbsp;.vdf. Apr&egrave;s avoir
appel&eacute; cette fonction, le filtre est connu dans avisynth
sous le nom "filtername". Les plugin VirtualDub supportent seulement
l'espace de couleur
RGB32. Si la video est dans le format RGB24, vous devez faire un
conversion en utilisant&nbsp;<code>ConvertToRGB32</code>
(<code>ConvertToRGB</code> ne suffira pas). </p>




<p>Certains filtres d&eacute;pendent des
images&nbsp;pr&eacute;c&eacute;dentes; pour ceux ci, le
pr&eacute; chargement doit &ecirc;tre d&eacute;fini pour un
nombre d'image au minimum &eacute;gal au nombre d'images
n&eacute;cessaires au filtre pour remplir son buffer ou pour mettre
&agrave; jour ses variables internes.</p>




<hr>
<p><code>LoadVFAPIPlugin</code> (<var>"filename",
"filtername"</var>)
</p>




<p>Cela vous permet d'utiliser des plugins VFAPI (les plugins
d'importation de TMPGEnc).<br>




</p>




<hr>
<p><code>LoadCPlugin</code> (<var>"filename" [,
...]</var>)</p>




<p>Les plugins C doivent &ecirc;tre charg&eacute;s avec
LoadCPlugin.&nbsp;Conseil: garder ces plugins en dehors du
r&eacute;pertoire de chargement automatique pour &eacute;viter
les crashs. <a href="http://forum.doom9.org/showthread.php?s=&amp;threadid=58840">[discussion]</a>
<a href="http://kevin.atkinson.dhs.org/avisynth_c/">[AVISynth
C API (by
kevina20723)]</a></p>




<hr>
<h2><a name="autoloading"></a>Chargement
automatique des plugins et priorit&eacute;s entre fonctions <strong>v2</strong></h2>




<p>Il est possible de mettre tous les plugins, les scripts avec
des fonctions utilisateurs et les variables (gobales) dans un
repertoire d'o&ugrave; tous les fichiers .AVS et .DLL sont
charg&eacute;s &agrave; l'ouverture du script,
d&eacute;charg&eacute;es et ensuite charg&eacute;es
dynamiquement quand le script en a besoin.</p>




<p>Les scripts dans ce repertoire doivent uniquement contenir des
d&eacute;finitions de fonctions et des variables globales, et pas
de section de traitement (sinon, d'&eacute;tranges erreurs
pourraient se produire). Il n'est pas recommand&eacute; non plus de
mettre d'autres fichiers dans ce repertoire.</p>




<p>Ce repertoire est enregistr&eacute; dans le registre (la
cl&eacute; de registre &agrave; chang&eacute; depuis <strong>v2.5</strong>).
Vous pouvez double cliquer sur un fichier .REG avec les lignes suivante
pour changer ce chemin:
&nbsp; </p>




<pre>REGEDIT4<br><br><br>[HKEY_LOCAL_MACHINE\SOFTWARE\Avisynth]<br>"plugindir2_5"="c:\\program files\\avisynth\\plugins"</pre>




<p>L'odre dans lequel sont appel&eacute;s les noms de
fonction est le suivant:</p>




<pre>Les fonctions utilisateurs (ont toujours la priorit&eacute; la plus haute)<br> Les fonctions des plugins externes (ont une plus haute priorit&eacute; que les filtres internes - ils &eacute;craseront la d&eacute;finition d'une fonction interne)<br>&nbsp;&nbsp;&nbsp;Les fonctions internes (ont la priorit&eacute; la plus basse)</pre>




<p>A l'int&eacute;rieur des ces groupes, la fonction
appel&eacute; en dernier prend la priorit&eacute;, il n'y a
donc pas d'erreur lors d'un conflit de noms de fonction. </p>




<h2><a name="autoloading_confl"></a>Chargement
automatique des plugins et conflits entre fonctions <strong>v2.55</strong>
</h2>




<p>A partir de <strong>v2.55</strong>, la
fonctionnalit&eacute; DLLName_function() &agrave;
&eacute;t&eacute; introduite. Le probl&egrave;me est que
deux plugins diff&eacute;rents peuvent avoir deux fonctions
diff&eacute;rentes mais qui &nbsp;ont le m&ecirc;me nom.
Pour appeler la bonne fonction, DLLName_function() doit &ecirc;tre
ajout&eacute;. Des noms de fonctions sont
g&eacute;n&egrave;r&eacute;s automatiquement &agrave;
la fois pour les plugins qui se chargent automatiquement et pour ceux
charg&eacute;s avec la commande&nbsp;LoadPlugin.</p>




<p><b>Quelques exemples:</b> </p>




<pre># Utiliser fielddeinterlace du plugin decomb510.dll<br>AviSource("D:\captures\jewel.avi")<br>decomb510_fielddeinterlace(blend=false)</pre>




<p>Supposez que vous ayez les plugins mpeg2dec.dll et
mpeg2dec3.dll dans votre repertoire de chargement automatique de
plugins, et que que vous voulez charger un fichier .D2V avec
mpeg2dec.dll (qui renvoie une image dans l'epace de couleur YUY2), vous
proc&eacute;dez de la mani&egrave;re suivante:</p>




<pre># Utiliser mpeg2source du plugin mpeg2dec.dll<br>mpeg2dec_mpeg2source("F:\From_hell\from_hell.d2v")</pre>




<p>ou avec mpeg2dec3.dll (qui renvoie une image dans l'epace de
couleur YV12): </p>




<pre># Utiliser mpeg2source du plugin mpeg2dec3.dll<br>mpeg2dec3_mpeg2source("F:\From_hell\from_hell.d2v")</pre>




<p><kbd>$English date: 2005/07/13 17:53:59 $<br>




First French Translation by jernst. Last update: 2005/10/09 JasonFly <a href="mailto:macpaille@users.sourceforge.net">macpaille@users.sourceforge.net</a></kbd></p>




</body>
</html>
