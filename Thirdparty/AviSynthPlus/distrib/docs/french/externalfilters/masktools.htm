<html><head>

<title>MaskTools</title>
<link rel="stylesheet" type="text/css" href="../../avisynth.css">
<!--
Automatically generated, don't change:
$Id: masktools.htm,v 1.1 2005/10/03 16:31:31 macpaille Exp $
--></head>
<body>
<h1>MaskTools</h1>
<h2>Abstract</h2>
<b>author:</b>  kurosu and Manao
<br><b>version:</b>      1.5.8
<br><b>download:</b>   <a href="http://manao4.free.fr/">http://manao4.free.fr/</a><br>
<b>category:</b>  Misc Plugins<br>
<b>requirements:</b> YV12 Colorspace<br>
<b>license:</b> GPL
<hr>
<h2>Table of contents
</h2>
<ul>
  <li><a href="#masktools">
I) About MaskTools</a>
    <ul>
      <li><a href="#simple">1) Simple version</a></li>
      <li><a href="#description">2) Description</a></li>
    </ul>
  </li>
  <li><a href="#functions">II) Function descriptions</a></li>
  <li><a href="#examples">III) Some practical uses</a>
    <ul>
      <li><a href="#msharpen">1) MSharpen</a></li>
      <li><a href="#msoften">2) MSoften</a></li>
      <li><a href="#rainbow">3) Rainbow reduction</a></li>
      <li><a href="#fxtoon">4) Supersampled fxtoon</a></li>
      <li><a href="#warpsharp">5) Warpsharp for dark luma</a></li>
      <li><a href="#deinterlacer">6) pseudo-deinterlacer (chroma will still be
problematic)</a></li>
      <li><a href="#rect_overlay">7) Non-rectangular overlays</a></li>
      <li><a href="#backgournd">8) Replace backgrounds</a></li>
      <li><a href="#mftoon">9) Kmf-Toon ;-)</a></li>
    </ul>
  </li>
  <li><a href="#todo">IV) TODO</a></li>
  <li><a href="#disclaimer">V) Disclaimer (don't skip that part, but I don't
force you to learn it either)</a></li>
  <li><a href="#revisions">VI) Revisions</a></li>
  <li><a href="#developer">VII) Developer's walkthrough</a></li>
</ul>
<h2><a name="masktools"></a>I) About MaskTools
</h2>
<h3><a name="simple"></a>1) Simple version
</h3>
<p>After a processing, you may need to keep only a part of the output. Say, you
have
a clip named smooth that is the result of a smoothing (blur() for instance) on a
clip named source.<br>
Most of the noise from source have disappeared in smooth, but so have details.
You could therefore want to only keep filtered pixels and discard those where
there are big difference of color or brightness. That's what does MSmooth by D.
Graft for instance. Now consider that you write on an image pixels from smooth
that you want to keep as white pixels, and the other ones from source as black
pixels. You get what is called a mask. MaskTools deals with the creation, the
enhancement and the manipulating of such mask for each component of the YV12
colorspace.</p>
<h3><a name="description"></a>2) Description
</h3>
<p>This Avisynth 2.5 YV12-only plugin offers several functions manipulating
clips
as masks:
</p>
<ul>
  <li><a href="#binarize">Binarize</a> will binarize the input picture
depending on a threshold and a command.</li>
  <li><a href="#combmask">CombMask</a> outputs a mask which gives aeres that
presents combing.</li>
  <li><a href="#dedgemask">DEdgeMask / DEdgeMask2</a> will build a mask of the edges of a
clip, applying thresholdings (proper values will enable or disable them).</li>
  <li><a href="#edgemask">EdgeMask</a> will build a mask of the edges of a
clip, applying thresholdings (proper values will enable or disable them).
    Similar as DEdgeMask with prefined kernels.</li>
  <li><a href="#expand">Expand</a> will 'expand' the high values in a plane, by
putting in the output the maximum value in the 3x3 neighbourhood around the
input pixel. The
    opposite function is called <a href="#expand">Inpand</a>.</li>
  <li><a href="#fitplane">FitY2UV/FitY2U/FitY2V</a> resizes Y plane and replace
UV/U/V plane(s) by the result of the resize (you can specify your resizer
filter, even one that
    isn't built-in AviSynth); the opposite  functions are FitU2Y and
FitV2Y.</li>
  <li><a href="#expand">Inflate</a> will 'inflate' the high values in a plane,
by putting in the output
    plane either the average of the 8 neighbours if it's higher than the
original value, otherwise the original value. The opposite function is
    called <a href="#expand"> Deflate</a> (dedicated to Phil Katz).</li>
  <li><a href="#invert">Invert</a> will invert the pixel (i.e. out = 255 - in);
this can be also used to
    apply a 'solarize' effect to the picture.</li>
  <li><a href="#logic">Logic</a> will perform most typical logical operations
(in fact, the ones provided by MMX mnemonics, though C functions are still
available, mainly
    because of the picture dimensions limits).</li>
  <li><a href="#LUT">RGBLUT/YV12LUT/YV12LUTxy</a> are look-up tables, allowing to apply
fastly a function to each pixels of the picture.</li>
  <li><a href="#maskedmerge">MaskedMerge</a> will take 3 clips and apply a
weighed merge between first and second clips depending on the mask represented
by clip3.</li>
  <li><a href="#motionmask">MotionMask</a> will create a mask of the motion on
the picture.</li>
  <li>OverlayMask will compare 2 clips based on luminance and chrominance
thresholds, and output whether pixels are close or not (close to what
    ColorKeyMask does).</li>
  <li><a href="#convolution">YV12Convolution</a> will allow you to convole the
picture by the matrix of your choice.</li>
  <li>YV12Layer is the equivalent to OverLay.</li>
  <li><a href="#subtract">YV12Substract</a> is the same as Subtract, also works
in YV12, but *should* be
    a bit faster (because MMX optimised).</li>
</ul>
<p>In addition, all functions take 3 parameters: Y, U and V (except the FitPlane
functions, where obviously the name tells what is processed). Depending on
their value, different operations are applied to each plane:</p>
<ul>
  <li>value = 3 will do the actual process of the filter,</li>
  <li>value = 2 will copy the 2nd video plane (if appliable) to the output
corresponding plane</li>
  <li>value = 1 will not process it (i.e., most often, left it with 1st clip
plane
    or garbage - check by yourself)</li>
  <li>value = [-255...0] will fill the output plane with -value (i.e. to have
grey
    levels, use U=128,V=128)</li>
</ul>
<p>A last point is the ability of some functions to process only a part of the
frame:</p>
<ul>
  <li>this behaviour is set by the parameters (offX, offY) (position of the
start
    point) and (w,h) (width and height of the processed area); filters should
modify those parameters so that the processed area is inside the 2 pictures</li>
  <li>in case of a filter (except YV12Layer) using 2 clips, the 2 clips must
have
    the same dimensions</li>
  <li>in all cases, the picture must be at least MOD8 (MOD16 sometimes) in order
    to enable the filter to use MMX functions (ie work at full speed)</li>
</ul>
<p>This was intended for modularity and atomic operations (or as useful as
possible), not really speed. It became both bloated and slow. I let you
decide whether this statement is totally true, or a bit less... The examples in
III) are most probably much faster applied with the original filters.<br>
</p>
<h2><a name="functions"></a>II) Function descriptions
</h2>
<h3><a name="binarize"></a>Binarize
</h3>
<p><code>Binarize</code> (<var>clip, int "threshold", bool
"upper"</var>)<br>
<br>
The <code> Binarize</code> filter allows a basic thresholding of a picture. If
<var>upper</var>=true, a pixel whose value is strictly superior to threshold
will be set to zero, else to 255. On the contrary, if
<var>upper</var>=false, a pixel whose value is strictly superior to <var>
threshold</var> will be set to 255, else to zero.<br>
<br>
Defaults are <var>threshold </var>= 20 and <var>upper </var>= true.
</p>
<h3><a name="combmask"></a>CombMask
</h3>
<p><code>CombMask</code> (<var>clip, int "thY1", int
"thY2"</var>)
</p>
<p>This filter produces a mask showing areas that are combed. The thresholds
work as for the other
filters : after calculating the combing value, if this one is under
<var>thY1</var>, the pixel is set
to 0, over <var>thY2</var>, it is set to 255, and inbetween, it is set to the
combing value divided by 256.
</p>
<p>The combing value is (upper_pixel - pixel)*(lower_pixel - pixel). Thus, it
is not normalized
to the range 0..255, because if it was done, value would be close to 1 or 2, no
more. That means
you can use threshold higher than 255, even if they should not be useful.
</p>
<p>Defaults are <var>thY1</var> = 10 and <var>thY2</var> = 10 ( thus making a
binary mask ).
</p>
<h3><a name="dedgemask"></a>DEdgeMask / DEdgeMask2
</h3>
<p><code>DEdgeMask</code> (<var>clip, int "thY1", int
"thY2", int "thC1", int "thC2", string
"matrix", float "divisor", bool "setdivisor", bool "vmode"</var>)<br>
<code>DEdgeMask2</code> (<var>clip source, clip low_thres, clip high_thres, string
"matrix", float "divisor", bool "setdivisor", bool "vmode"</var>)<br>
<br>
This filter creates an edge mask of the picture. The edge-finding algorithm
uses a convolution kernel, and the result of the convolution is then
thresholded with
<var> thY1</var> and <var> thY2</var> ( luma ) and <var> thC1</var> and <var>
thC2</var> ( chroma ). The thresholding happens like that ( r is the result of
the convolution )
:
</p>
<ul>
  <li>r &lt;= th1 gives 0.</li>
  <li>th1 &lt; r &lt;= th2 gives r.</li>
  <li>th2 &lt; r gives 255.</li>
</ul>
<p>In order to create a binary mask, you just have to set th1=th2.</p>
<p>The choice of the convolution kernel is done with <var>matrix</var>. The
matrix must be a 3 by 3 matrix, whose coefficients are integers, separated by a
single space. Hence, the strings "-1 -1 -1 -1 8 -1 -1 -1 -1" and "0 -1 0 -1 0 1
0 1 0" will respectively give the kernels "laplace" and "sobel" of the filter
<a href="#edgemask">EdgeMask</a>.</p>
<p>As coefficients must be integers, <var> divisor</var> is used to refine the
result of the convolution. This result will simply be divided by
<var>divisor</var>. If <var> divisor</var> isn't defined, it is defaulted to
the sum of the positive coefficient of the matrix, thus allowing a classic
normalization. It can be either a float or an integer, the later being the faster.<br>
<var>setdivisor </var> is present only for backward compatibility. Do not use it.
<br>
Finally <var>vmode</var> allows to output a mask centered to 128 instead of zero.
Defaults are : <var>thY1 </var>= 0, <var>thY2 </var>= 20, <var>thC1 </var>= 0,
<var>thC2
</var>= 20, <var>matrix </var>= "-1 -1 -1 -1 8 -1 -1 -1 -1" and <var>vmode</var>=false.</p>
<p>DEdgemask2 basically works like DEdgeMask, except that instead of 2 low / high thresholds, it takes 2 other clips. Each clips contains local thresholds for each pixels.
Let's say you want adaptive thresholds taking local contrast into account. Well, local min &amp; max can be obtained through inpand() and expand(). Difference can be made with YV12LUTxy or YV12Subtract. And voilà, you've got a threshold clip containing local contrasts.</p>
<h3><a name="edgemask"></a>EdgeMask</h3>
<p><code>EdgeMask</code> (<var>clip, int "thY1", int
"thY2", int
"thC1", int "thC2", string "type"</var>)<br>
<br>
This filter creates an edge mask of the picture. The edge-finding algorithm
uses a convolution kernel, and the result of the convolution is then
thresholded with
<var> thY1</var> and <var> thY2</var> ( luma ) and <var> thC1</var> and <var>
thC2</var> ( chroma ). The thresholding happens like that ( r is the result of
the convolution ) :
</p>
<ul>
  <li> r &lt;= th1 gives 0.</li>
  <li> th1 &lt; r &lt;= th2 gives r.</li>
  <li> th2 &lt; r gives 255.</li>
</ul>
<p>In order to create a binary mask, you just have to set th1=th2.</p>
<p>The choice of the convolution kernel is done by <var> type</var> :</p>
<ul>
  <li><var> type</var> = "roberts" :<br>
    <table border="1" width="15%">
      <tbody><tr>
        <td align="center" height="5%" valign="middle" width="25%">2</td>
        <td align="center" height="5%" valign="middle" width="25%">-1</td>
      </tr>
      <tr>
        <td align="center" height="5%" valign="middle" width="25%">-1</td>
        <td align="center" height="5%" valign="middle" width="25%">0</td>
      </tr>
    </tbody></table>
  </li>
  <li><var> type</var> = "sobel" :<br>
    <table border="1" width="15%">
      <tbody><tr>
        <td align="center" height="5%" valign="middle" width="25%">0</td>
        <td align="center" height="5%" valign="middle" width="25%">-1</td>
        <td align="center" height="5%" valign="middle" width="25%">0</td>
      </tr>
      <tr>
        <td align="center" height="5%" valign="middle" width="25%">-1</td>
        <td align="center" height="5%" valign="middle" width="25%">0</td>
        <td align="center" height="5%" valign="middle" width="25%">1</td>
      </tr>
      <tr>
        <td align="center" height="5%" valign="middle" width="25%">0</td>
        <td align="center" height="5%" valign="middle" width="25%">1</td>
        <td align="center" height="5%" valign="middle" width="25%">0</td>
      </tr>
    </tbody></table>
  </li>
  <li><var> type</var> = "laplace" :<br>
    <table border="1" width="15%">
      <tbody><tr>
        <td align="center" height="5%" valign="middle" width="25%"> -1/8</td>
        <td align="center" height="5%" valign="middle" width="25%"> -1/8</td>
        <td align="center" height="5%" valign="middle" width="25%"> -1/8</td>
      </tr>
      <tr>
        <td align="center" height="5%" valign="middle" width="25%"> -1/8</td>
        <td align="center" height="5%" valign="middle" width="25%">1</td>
        <td align="center" height="5%" valign="middle" width="25%"> -1/8</td>
      </tr>
      <tr>
        <td align="center" height="5%" valign="middle" width="25%"> -1/8</td>
        <td align="center" height="5%" valign="middle" width="25%"> -1/8</td>
        <td align="center" height="5%" valign="middle" width="25%"> -1/8</td>
      </tr>
    </tbody></table>
  </li>
  <li><var> type</var> = "special" :<br>
    <table border="1" width="15%">
      <tbody><tr>
        <td align="center" height="5%" valign="middle" width="25%"> -1/4</td>
        <td align="center" height="5%" valign="middle" width="25%">0</td>
        <td align="center" height="5%" valign="middle" width="25%"> -1/4</td>
      </tr>
      <tr>
        <td align="center" height="5%" valign="middle" width="25%">0</td>
        <td align="center" height="5%" valign="middle" width="25%">1</td>
        <td align="center" height="5%" valign="middle" width="25%">0</td>
      </tr>
      <tr>
        <td align="center" height="5%" valign="middle" width="25%"> -1/4</td>
        <td align="center" height="5%" valign="middle" width="25%">0</td>
        <td align="center" height="5%" valign="middle" width="25%"> -1/4</td>
      </tr>
    </tbody></table>
  </li>
  <li><var> type</var> = "roberts" :<br>
    <table border="1" width="15%">
      <tbody><tr>
        <td align="center" height="5%" valign="middle" width="25%">2</td>
        <td align="center" height="5%" valign="middle" width="25%">-1</td>
      </tr>
      <tr>
        <td align="center" height="5%" valign="middle" width="25%">-1</td>
        <td align="center" height="5%" valign="middle" width="25%">0</td>
      </tr>
    </tbody></table>
  </li>
</ul>
<p>Finally, there are also two other possible values for <var> type</var> (
"cartoon" and "line" ), which have behaviors which are not documented here.</p>
<p>Defaults are : <var>thY1 </var>= 0, <var>thY2 </var>= 20, <var>thC1 </var>=
0, <var>thC2 </var>= 20 and <var>type </var>= "sobel".</p>
<h3><a name="fitplane"></a>FitY2U / FitY2V / FitY2UV  FitU2Y / FitV2Y /
FitU2V / FitV2U</h3>
<p><code>FitPlane</code> (<var>clip, string resizer</var>) </p>
<p><code>FitPlane</code> has the following incarnations:<br>
   - luma to chroma: <code>FitY2U</code>, <code>FitY2V</code>, <code>
FitY2UV</code><br>
   - chroma to luma: <code>FitU2Y</code>, <code> FitV2Y</code><br>
   - chroma to chroma: <code>FitU2V</code>, <code> FitV2U</code></p>
<p>You can by this mean propagate a mask created on a particular plane to
another plane.</p>
<h3><a name="expand"></a>Inpand / Expand / Deflate / Inflate
</h3>
<p><code>Inpand</code> (<var>clip</var>)<br>
<code>Expand</code> (<var>clip</var>)<br>
<code>Deflate</code> (<var>clip</var>)<br>
<code>Inflate</code> (<var>clip</var>)
</p>
<p>This filters allow to enlarge / reduce a mask. <code>Expand</code> will
replace the value of a pixel by the highest surrounding value.
<code>Inpand</code> will on the contrary replace it by the lowest surrounding
value.
<code>Inflate</code> will compute the mean of the surrounding pixels, and will
replace the value of the pixel by it only if this mean is superior to the
original value of the pixel.
<code>Deflate</code> will do the same only if the mean is inferior to the
original value.
</p>
<p>The picture returned by <code>Expand</code> / <code>Inflate</code> will
always be higher than the original picture. On the contrary, the one returned by
<code>Inpand</code> / <code>Deflate</code> will always be lower.
</p>
<p>The enlarging / reducing produced by <code>Deflate</code> /
<code>Inflate</code>
is softer than the one of <code>Expand</code> / <code>Inpand</code>.
</p>
<h3><a name="hysteresymask"></a>HysteresyMask
</h3>
<p><code>HysteresyMask</code> (<var>mask_clip1, mask_clip2</var>)
</p>
<p>This filter creates a mask from two masks. Theorically, the first mask
should be inside the second one, but it can work if it isn't true ( though
results will be less interesting ). The principle of the filter is to enlarge
the parts that belongs to both masks, inside the second mask.
</p>
<p>This algorithm is interesting because it allows for example to obtain an
edge mask with all the interesting edges, but without the noise. You build two
edge masks, one with a lot of edges and noise, the other one with a few edges
and almost no noise. Then, you use this filter, and you should obtain the
edges, without the noise, because the noise wasn't there in the second mask.
</p>
<h3><a name="invert"></a>Invert
</h3>
<p><code>Invert</code> (<var>clip, int offX, int offX, int w, int h</var>)
</p>
<p>This filter seplaces the pixel's value by 255-pixel's value.
</p>
<p>Binarize(upper=false) could be seen (but isn't processed as) as 
</p>
<p>Invert().Binarize(upper=true)
</p>
<h3><a name="logic"></a>Logic
</h3>
<p><code>Logic</code> (<var>mask_clip1, mask_clip2, string
"mode"</var>)
</p>
<p>This filter produces a new mask which is the result of a binary operation
between two masks. The operation is chosen with the parameter
<var>mode</var>.
</p>
<ul>
  <li><var>mode</var>="and" : works only with binary masks ( only
pixels at 0 or 255 ). The output mask is the intersection of the two masks. It
means that if both corresponding pixels are 255, the resulting pixel will be
255, else 0.</li>
  <li><var>mode</var>="or" : works only with binary masks. The output
mask is the union of the two masks. It means that if one of the corresponding
pixels are 255, the resulting pixel will be 255, else 0.</li>
  <li><var>mode</var>="xor" : works only with binary masks. The
output mask is the difference between the two masks. It means that if one (
exclusively ) of the corresponding pixels are 255, the resulting pixel will be
255, else 0.</li>
  <li><var>mode</var>="andn" : works only with binary masks. The
output mask is the subtraction of the second mask from the first one. It means
that if the pixel of the first mask is 255 and the second is 0, it will return
255, else 0.</li>
  <li><var>mode</var>="min" : returns for each pixel the minimum
value between the two pixels of the input masks. It amounts to
    <var>mode</var>="and", but for non binary masks.</li>
  <li><var>mode</var>="max" : returns for each pixel the maximum
value between the two pixels of the input masks. It amounts to
    <var>mode</var>="or", but for non binary masks.</li>
</ul>
<p>If a logical operator is used with a non binary mask, the results are
unpredictable.
</p>
<p>Default : <var>mode </var>= "and".
</p>
<h3><a name="LUT"></a>RGBLUT / YV12LUT / YV12LUTxy / YUY2LUT
</h3>
<p><code>YV12LUT</code> (<var>clip, string "yexpr", string
"uexpr", string "vexpr"</var>)<br>
<code>YUY2LUT</code> (<var>clip, string "yexpr", string
"uexpr", string "vexpr"</var>)<br>
<code>RGBLUT</code> (<var>clip, string "Rexpr", string
"Gexpr", string "Bexpr", string "AMPFile"</var>)<br>
<code>YV12LUTxy</code> (<var>clipx, clipy, string "yexpr", string
"uexpr", string "vexpr"</var>)
</p>
<p>These filters apply a function to each pixel of the picture. In order to
allow a fast computation, every possible value of the function are precomputed
and stored in a Look-Up Table ( hence the name ). That makes the filters fairly
fast.
<code>RGBLUT</code>  works exactly the same way as <code>YV12LUT</code>, except
that it has an additional argument <var>AMPFile</var>. It allows you to load a
photoshop color profile. 
</p>
<p>In order to be able to apply almost every possible function, this one is
given by a string which represents an expression in reverse polish notation.
The principle of this notation is to write firstly the operands / parameters of
an operator / function, and then the operator / function itself. Hence, "3 + 7"
becomes "3 7 +", and "sin(3)" becomes "3 sin". Going further in the
explanations, "3 * 7 + 5" becomes "3 7 * 5 +", and "(3 + 7) * 5" : "3 7 + 5 *".
Now, you understand the main asset of this notation : no need of parenthesis.
</p>
<p>Computations are lead on real numbers. Positive numbers also represent a
true statement, whereas negative numbers represent a false statement. In the
string, the symbol "x" is tha value of the pixel before the use of the
function. For <code>YV12LUTxy</code> you also have the symbol "y", which represents
the value of the collocated pixel in the second clip. The symbols must be
separated by a single space.
</p>
<p>Some operators and functions are implemented :
</p>
<ul>
  <li>+, -, /, *, ^, % are the operators plus, minus, divide, multiply, power
and modulo.</li>
  <li>&amp;, |, °, !&amp; are the logical operators and, or, xor, and not. If
the result is true, they return 1.0, else -1.0.</li>
  <li>&lt;, &lt;=, &gt;, &gt;=, =, != are the relationnal operators less than, less
or equal to, more than, more or equal to, equal to, not equal to. If the result
is true, they return 1.0, else -1.0.</li>
  <li>cos, sin, tan, acos, asin, atan, exp, log, abs are the functions cosine,
sine, tangent, arccosine, arcsine, arctangent, exponential, napierian
logarithm, absolute value.</li>
  <li>? allows to do a condition test. It's a ternary operator, the first
operand being the condition, the second the value if the condition is true, the
third if false.</li>
</ul>
<p>Some examples :
</p>
<p>* Binarization of the picture with a threshold at 128 : "x 128 &lt; 0 255
?". It is translated as : "(x &lt; 128) ? 0 : 255".<br>
    * Levels(il, gamma, ih, ol, oh) ( have a look at the filter <a href="http://jourdan.madism.org/corefilters/levels.htm"> Levels</a> ) : "x il - ih il - / 1 gamma / ^
oh
ol - *".
It is translated as "(((x - il) / (ih - il)) ^ (1 / gamma)) * (oh - ol)".
</p>
<p>Defaults are : <var>Yexpr</var> = <var>Uexpr</var> = <var>Vexpr</var> =
"x" ( hence, the filter does nothing ).
</p>
<h3><a name="maskedmerge"></a>MaskedMerge
</h3>
<p><code>MaskedMerge</code> (<var>base_clip, overlay_clip, mask_clip</var>)
</p>
<p>This filter applies the clip <var>overlay_clip</var> on the clip
<var>base_clip</var>, considering the clip
<var>mask_clip</var>. More precisely, with <i>bc</i>, <i> oc</i> and <i> mc</i>
the
values of three pixels taken respectively on <var>base_clip</var>,
<var>overlay_clip</var>
and <var>mask_clip</var>, the result will be :
</p>
<pre>v = ((256 - <i>mc</i>) * <i>bc</i> + <i>mc</i> * <i>oc</i> + 128) /
256</pre>
<p>128 is here in order to reduce the error due to the rounding of the integer
division.
</p>
<p>So, if the mask is 255, the pixel will be the pixel from the
<var>overlay_clip</var>, if the mask is 0, the pixel will be from the
<var>base_clip</var>, and in between, it will be blended between both clips.
</p>
<h3><a name="motionmask"></a>MotionMask
</h3>
<p><code>MotionMask</code> (<var>clip, int "thY1", int "thY2',
int
"thC1", int "thC2", int "thSD"</var>)
</p>
<p>This filter creates a mask of the motion of the picture. As with the other
filters which create masks, once the motion
is computed, it is thresholded by two thresholds. This filter will also check
for scene changes, and won't output a mask if one is detected.
</p>
<p>Scene change detection is made by computing the sum of absolute differences
of the picture and the previous one. This sum is averaged, and then compared to
<var>thSD</var>. If it is more than <var>thSD</var>, a scene change is detected.
</p>
<p>Motion is computed the same way as <a href="http://jourdan.madism.org/%7Emanao/nomosmooth.htm">NoMoSmooth</a>,
meaning that for each pixel, we'll compute the absolute sum of differences
between the pixel and its surrounding, and the pixel and its surrounding in the
previous picture. The resulting value is then divided by 9, in order to
normalize the result between 0 and 255.
</p>
<p>This algorithm only gives an approximation of the motion. It will work well
on the edges of an object, but not on its inside.
</p>
<p>Defaults are : <var>thY1</var>= 20, <var>thY2</var> = 20, <var>thC1</var> =
10, <var>thC2</var> = 10 and <var>thSD</var> = 10.
</p>
<h3><a name="convolution"></a>YV12Convolution
</h3>
<p><code>YV12Convolution</code> (<var>clip, string "horizontal",
string
"vertical", int "total", bool "automatic", bool
"saturate"</var>)
</p>
<p>This filters computes the convolution product between the picture and the
kernel defined by the multiplication of <var>horizontal</var> by
<var>vertical</var>. These two strings represent vectors. They must have an odd
number of integer or real numbers, separated by single spaces. <var>total</var>
is a normalization factor, by which the result of the product is divided.
If <var> automatic</var> is set to 'true', total is the sum of the coefficients
of the matrix. It means that, that way, overall brightness of the picture isn't
touched.
<var>Saturate</var> allows to choose the behavior of the filter when the result
is a negative number.
</p>
<ul>
  <li><var>saturate</var> = true : negative values are zeroed.</li>
  <li><var>saturate</var> = false : negative values are inverted. </li>
</ul>
<p>If total is not defined, it is set to the sum of the coefficients of the
convolution kernel, thus allowing a good normalization for bluring / sharpening
kernels.
</p>
<p>If one of the coefficients of horizontal or vertical is a real number, all
the computations will be made with floats, so the filter will be slower.
</p>
<p>Defaults are : <var>horizontal</var> = "1 1 1", <var>vertical</var> =
"1 1 1" and
<var>automatic</var> = false, <var>saturate</var> = true.
</p>
<h3><a name="subtract"></a>YV12Subtract
</h3>
<p><code>YV12Subtract</code> (<var>clip1, clip2, int tol, bool
"widerange"</var>)
</p>
<p>This filter computes the difference between the two clips. There are several
ways of computing this difference, depending on the values of widerange and of
<var>tol</var>.
</p>
<ul>
  <li><var>widerange</var> = true : we compute the difference ( n ) between the
two clip, and we return r = 128 + 128 * pow(n / 255,1 /
    <var>tol</var>). If <var>tol</var> &lt; 0, 1 / <var>tol</var> becomes
0.5.</li>
  <li><var>widerange</var> = false :
    <ul>
      <li><var>tol</var> &lt; 0 : we compute the absolute difference ( n )
between the two clip, and we return r = n / 2 + 128.</li>
      <li><var>tol</var> &gt;= 0 : we compute the absolute difference ( n )
between the two clip, and we return 0 if n is lower than tol, n - tol
else. </li>
    </ul>
  </li>
</ul>
<p>Defaults are : <var>tol</var> = -1 and <var>widerange</var> = false.
</p>
<h2><a name="examples"></a>III) Some practical uses (not tested extensively)
</h2>
<p>Those won't produce the exact same results as the original filters they try
to mimic, in addition to be far more slower. Despite the numerous additional
functions, no newer idea.
</p>
<p>Notes: <br>
- I'm too lazy to update the syntax, especially regarding how mode=2 works, and
how EdgeMask was updated (now longer needs of a Binarize for instance)<br>
- Some filters I describe as 'to create' already exist (imagereader, levels for
clamping, ...).
</p>
<h4><a name="msharpen"></a>1) MSharpen
</h4>
<pre># Build EdgeMask of clip1, Binarize it and store the result into clip3
# Apply any sharpening filter to clip1 and store it into clip2
...
return MaskMerge(clip1, clip2, clip3)</pre>
<p>The sharpened edges of clip2 higher than the threshold given to Binarize
will be sharpened and used to replace their original value in clip1.
You could also write a filter with a particular Look-up table (best would look
like a bell), replace Binarize by it, and have a weighed sharpening
depending on the edge value: that's the HiQ part in SmartSmoothHiQ
</p>
<pre>clip2 = clip1.&lt;EdgeEnhancer&gt;(&lt;parameters&gt;)
#U and V planes don't need filtering, Y needs it
#EdgeMask(&lt;...&gt;, &quot;roberts&quot;, Y=3, U=-128, V=-128) for greyscale
map
clip3 = clip1.EdgeMask(15, 60, &quot;roberts&quot;, Y=3, U=1, V=1)
return MaskedMerge(clip1, clip2, clip3)</pre>
<h4><a name="msoften"></a>2) MSoften
</h4>
<p>Replace EdgeEnhancer by a spatial softener (cascaded blurs?
spatialsoftenMMX?) and use upper=true to select near-flat pixels.
</p>
<h4><a name="rainbow"></a>3) Rainbow reduction (as described here in this <a href="http://forum.doom9.org/showthread.php?s=&amp;threadid=48167"><cite>thread&lt;
/cite&gt;</cite></a>
)
</h4>
<p>Warning, this isn't a miracle solution either
</p>
<pre>clip2 = clip1 soften at maximum (using deen(&quot;m2d&quot;) or edeen for
instance)
#Get luma edgemap and increase edges by inflating
# -&gt; wider areas to be processed
clip3 = clip1.EdgeMask(6, &quot;roberts&quot;, Y=3, U=1, V=1).Inflate(Y=3, U=1,
V=1)
#Now, use the luma edgemask as a chroma mask
clip3 = YtoUV(clip3, clip3).ReduceBy2().Binarize(15, upper=false, Y=1, U=3, V=3)
#We have to process pixels' chroma near edges, but keep intact Y plane
return MaskedMerge(clip1, clip2, clip3, Y=1, U=3, V=3)</pre>
<h4><a name="fxtoon"></a>4) Supersampled fxtoon
</h4>
<p>Not tested
</p>
<pre>. Use tweak to darken picture or make a plugin that scales down Y values
-&gt; clip2
. Build edge mask, Supersample this mask, Binarize it with a high threshold
(clamping sounds better), Inflate it -&gt; clip3
. Apply the darker pixels of clip2 depending on the values of clip3</pre>
<h4><a name="warpsharp"></a>5) Warpsharp for dark luma
</h4>
<p>Not tested
</p>
<pre>. Apply warpsharp -&gt; clip2 (replacement pixels)
. Create a clamping filter or a low-luma bypass filter -&gt; clip3 (mask)</pre>
<h4><a name="deinterlacer"></a>6) pseudo-deinterlacer (chroma will still be
problematic)
</h4>
<p>Not tested
</p>
<pre>clip2 = clip1.SeparateFields().SelectEven().&lt;Method&gt;Resize(&lt;parame
ters&gt;)
clip3 = clip1.&lt;CombingDetector&gt;(&lt;parameters&gt;)
return MaskedMerge(clip1, clip2, clip3, Y=3, U=3, V=3)</pre>
<p>(chroma even more problematic)
</p>
<h4><a name="rect_overlay"></a>7) Non-rectangular overlays
</h4>
<p>In fact, this is handled more nicely by layer and mask...
</p>
<pre>#Simple hack because ImageReader needs an integer fps...
#Most sources are natively in YUY2/YV12
clip = AviSsource(&quot;test.avi&quot;).ConvertToYV12().assumefps(fps)
#Load the picture to be overlayed
image = ImageReader(&quot;mask.bmp&quot;, 0, clip.framecount()-1, 24,
use_DevIl=false)
#Simple way: assume black is transparent&nbsp;
#Any other colour would be quite more complicated*
masktemp = imageYV12.Binarize(17, upper=false, Y=3)
#We set the luma mask to fit the chroma planes
mask = Mask.FitY2UV()
#Now that we have the mask that tells us what we want to keep...
#Replace by image the parts of clip masked by mask!
MaskedMerge(clip, image, mask, Y=3, U=3, V=3)
#*solution: mask = OverlayMask(image, image.BlankClip(&quot;$xxxxxx&quot;), 1,
1)</pre>
<h4><a name="backgournd"></a>8) Replace backgrounds
</h4>
<p>This example clearly would look better in RGB. To avoid typical problems due
to noise or compression, you would better use blurred versions of the clip
and picture.
</p>
<pre>source = AviSource(&quot;overlay.avi&quot;).AssumeFPS(24)
#blur the source
clip = source.Blur(1.58).Blur(1.58).Blur(1.58)
#load the background to replace, captured from the blurred sequence
bgnd = ImageReader(&quot;bgnd.ebmp&quot;, 0, clip.framecount()-1, 24,
use_DevIl=false)
#load new background
new = ImageReader(&quot;new.ebmp&quot;, 0, clip.framecount()-1, 24,
use_DevIl=false)
#integrated filter to output the mask = (clip~overlay?)
mask = OverlayMask(clip, overlay.ConvertToYV12(), 10, 10)
MaskedMerge(source, new.ConvertToYV12(), mask, Y=3, U=3, V=3)</pre>
<h4><a name="mftoon"></a>9) K-mfToon
</h4>
<p>I need to include more info (original urls/posts) but for now I think
mfToon's original author, mf (mf@onthanet.net) will not react too
violently to it, while it's still not addressed.<br>
The output of the function inside K-mfToon.avs should be identical to the
output of the original mftoon.avs (also included), with twice the speed.<br>
The requirements are:<br>
- For mfToon:<br>
  . load the plugins called "MaskTools", "warsharp", "awarsharp" 
</p>
<h2><a name="todo"></a>IV) TODO
</h2>
<p>Nothing, it all depends in feeback<br>
</p>
<h2><a name="disclaimer"></a>V) Disclaimer
</h2>
<p>This plugin is released under the GPL license. You must agree to the terms of
'Copying.txt' before using the plugin or its source code.<br>
<br>
You are also advised to use it in a philanthropic state-of-mind, i.e. not "I'll
keep this secret for myself".<br>
<br>
Last but not least, a very little part of all possible uses of each filter was
tested (maybe 5% - still a couple of hours spent to debug ;-). Therefore,
feedback is _very_ welcome (the opposite - lack of feedback - is also true...)
</p>
<h2><a name="revisions"></a>VI) Revisions
</h2>
<p>1.5.8 - 8th August 2005
</p>
<ul>
  <li>Added DEdgeMask2.</li>
</ul>
<p>1.5.7
</p>
<ul>
  <li>Added YUY2LUT.</li>
</ul>
<p>1.5.6</p>
<ul>
  <li>Corrected chroma handling of YV12LUTxy.</li>
</ul>
v1.5.5 - 6 November 2004
<ul>
  <li>Version with binarize working;<br>
    Pentium4 with HT enabled.</li>
</ul>
<p>v1.5.4 - 14 October 2004</p>
<ul>
  <li>A lot of filters which were working in place aren't anymore ( because of an
    AviSynth strangeness which was causing slowdowns ). Before, a filter such as YV12LUT, with U = V = 1, would have had it's chroma left untouched. Now, if you want to preserve the chroma, you have to specify U = V = 2, as it is said in the documentation.</li>
</ul>
<p>1.5.2 - 1.5.3</p>
<ul>
  <li>?</li>
</ul>
<p>1.5.1</p>
<ul>
  <li>Complete rewritting of the documentation ( a huge thanks to Wilbert ).</li>
  <li>DEdgeMask now supports a float divisor. However, if the divisor is integer, it *should* be faster.</li>
  <li>DEdgeMask now has back its parameter "setdivisor", but it's only for backward compatibility with some scripts.</li>
  <li>YV12LUTxy : it's a new filter, implementing the idea presented by Didee on the previous post. The "y" symbol has the value of the collocated pixel in the second clip.</li>
</ul>
<p>1.4.16
</p>
<ul>
  <li>Bugfixes : Logic "min" &amp; "max" modes weren't properly working, it's
corrected.</li>
  <li>Bugfixes : Logic &amp; Subtract weren't using MMX &amp; iSSE
optimizations, due to a very silly bug.
    It's Corrected.</li>
</ul>
<p>1.4.15.3</p>
<ul>
  <li>RGBLUT added : works the same as YV12LUT ( except R, G and B replace Y, U
and V ).</li>
  <li>In addition, you can specify an AMP file ( arbitrary color mapping file
format from photoshop ).</li>
</ul>
<p>1.4.15.2</p>
<ul>
  <li>Bug finally solved on YV12LUT. Silly programming bug, as always...</li>
  <li>In YV12LUT, logical and relationnal operators added ( &lt;, &lt;=, &gt;, &gt;=,
==, !=, &amp;, !&amp;, |, ° ( xor ) )</li>
  <li>In YV12LUT, a ternary operator added : ? ( works as in C )</li>
</ul>
<p>1.4.15.1</p>
<ul>
  <li>In YV12LUT, another bug which was still preventing it from working fine.
Hopefully, it should
    really work now.</li>
</ul>
<p>1.4.15</p>
<ul>
  <li>New Filter : HysteresyMask. It will allow you to build a new edge mask
from two edge masks,
    one only having a few edges ( but we're sure they indeed are edges ), the
other having two
    much edges ( due to a too low thresholding for example ). Look in the
documentation to have
    further explanations.</li>
</ul>
<p>1.4.14.2</p>
<ul>
  <li>Several bugfixes concerning the behavior of negative values for Y, U and
V ( edgemask,
    dedgemask, motionmask, combmask, logic )</li>
  <li>Several bugfixes concerning the use of offX / offY / w and h ( filters
than can use it are :
    maskedmerge, binarize, expand, YV12subtract, yv12lut )</li>
  <li>In YV12LUT, a bug prevented to use it with some filter. It should work
now.</li>
  <li>In YV12Convolution, float coefficients can be used now. If none is used,
all the processing
    will take place with integer, so it will be faster than if you use a float.
Moreover, if<br>
    there is the possibility of overflow ( giving a result over 255 or under 0
) during computation,
    a slower but safe function will be used to saturate computation to 0 and
255.</li>
</ul>
<p>1.4.14.1</p>
<ul>
  <li>Bugfix in YV12LUT to allow the use of negative numbers</li>
</ul>
<p>1.4.14</p>
<ul>
  <li>Bugfix : In YV12Layer, a useless test could prevent the filter to work.
The test has been
    removed</li>
  <li>Bugfix : In DEdgeMask, threshold weren't taken into account. They are
now</li>
  <li>Bugfix : Logic filter is now fully functionnal, in C and MMX</li>
  <li>Added : documentation to Logic filter</li>
  <li>Added : two modes for Logic : "Min" and "Max" ( C, MMX, iSSE )</li>
  <li>Added : In DEdgeMask, the possibility to set the normalization factor</li>
  <li>Corrected : documentation.</li>
</ul>
<p>1.4.13</p>
<ul>
  <li>Bugfix : One more, in the MotionMask ( the last row was not correctly
computed )</li>
  <li>Optimizations : MaskedMerge gives now the same output in MMX and C, so
MMX optimizations
    for it are back by default.</li>
  <li>Added : In EdgeMask, you now can use the laplace kernel. See the
documentation on that
    filter</li>
  <li>Added : 'New' filter, DEdgeMask, which allows you to choose your kernel (
at a cost : 
    speed )</li>
</ul>
<p>1.4.12</p>
<ul>
  <li>Behavior modifications : MotionMask and EdgeMask now also computes pixels
on the borders
    mainly by extending the mask to these pixels.</li>
  <li>Bugfix : Inflate / Inpand / Expand / Deflate, when using negative
parameters for y,u and v, 
    some weird problems could occur.</li>
  <li>Added functionnality : In YV12LUT, the function abs is now defined.</li>
</ul>
<p>1.4.11</p>
<ul>
  <li>Bugfix : EdgeMask, MMX optimizations give different results. They are
disabled by default.
    To activate them, use usemmx = true. They'll be used only with mod 16
resolution</li>
  <li>Bugfix : EdgeMask : first and last lines weren't always
computed. </li>
  <li>Bugfix : MaskedMerge : MMX optimizations darken slightly the picture.
They are disabled by
    default. To activate them, use usemmx = true. They'll be used only with mod
16 resolution.</li>
</ul>
<p>1.4.10</p>
<ul>
  <li>Bugfix : first and last lines were not correctly computed with inflate /
deflate</li>
  <li>Invert is no longer a filter of the Masktools, it has been moved inside
AviSynth.</li>
</ul>
<p>1.4.9</p>
<ul>
  <li>New filter : CombMask. As usual, read further for more documentation</li>
</ul>
<p>1.4.8</p>
<ul>
  <li>YV12Convolution now supports negative coefficients in the matrix. It
allows to use the
    filter has an edge detecter.</li>
  <li>YV12Convolution has now a new parameter : bool saturate, which, if set to
true, 
    or if there is a possibility of getting out of the range [0..255] during
calculation,
    clips each pixel into that range ( which means it's slightly slower )</li>
  <li>A new filter : LUT. Read further for more information on how to use
it.</li>
</ul>
<p>1.4.7</p>
<ul>
  <li>Rename MotionDetection to MotionMask. I know it's kind of silly, but it's
a lot
    more logical that way.</li>
  <li>Add the check of the width for the use MMX in MotionMask</li>
  <li>Slightly modify MMX optimizations in Binarize.</li>
  <li>Add a new filter : YV12Convolution. It allows you to convole the picture
by
    a matrix of (almost) any size. Look further in the readme to learn how to
use it</li>
</ul>
<p>1.4.6</p>
<ul>
  <li>Made the scenechange detection in MotionDetection iSSE optimized (
meaning you
    need an Athlon XP / Pentium IV ). It works with an Athlon XP, it is not
tested with<br>
    an Pentium IV, it is possible to disable it by using usemmx = false in the
paremeters
    of the filter.</li>
  <li>Optimized the calculation of the motion, without using MMX ( just by
avoiding to do 
    3 times the same calculations... ). So the filter should be more or less
three times
    faster.</li>
</ul>
<p>1.4.5</p>
<ul>
  <li>Added MotionDetection filter, no MMX / assembler optimizations for it
yet. Look
    further in the Readme to learn how to use it. It takes the idea of
Sansgrip's filter
    (NoMoSmooth) and outputs the motion mask directly in the correct colorspace
for the
    MaskTools.</li>
</ul>
<p>1.4.4</p>
<ul>
  <li>Reactivated MMX optimizations for MaskedMerge</li>
  <li>Came back to Kurosu's optimizations for Invert</li>
</ul>
<p>1.4.3</p>
<ul>
  <li>Made some MMX optimizations ( binarize, invert )</li>
  <li>Corrected some MMX optimizations ( which means mostly 'disabled some MMX
optimizations' ). It should now work with P4.</li>
</ul>
<p>1.4.2</p>
<ul>
  <li>Fixed bugs concerning the inpand / expand / inflate / deflate
functions</li>
</ul>
<p>1.4.1
</p>
<ul>
  <li>Fixed the dreadly bug "multiple instances of a filter with different
functions needed"</li>
</ul>
<p>1.4.0
</p>
<ul>
  <li>Added an experimental LUT filter. Not tested, debug later.</li>
</ul>
<p>1.3.0 (private version)
</p>
<ul>
  <li>Made usable the FitPlane function (still an overload of work when only
one plane has to be resized) which was previously undocumented;
therefore, added FastFitPlane functions (corresponding FitPlane ones should be
useless now, except for the resizers settings)</li>
  <li>Allowed the specification of a processing area for many filters; however,
this should not produce any noticable speed increase.</li>
  <li>Cleaned YV12Layer (in particular the unusable "Darken"/"Lighten"
modes)</li>
  <li>Added OverlayMask, a function that compares 2 clips, and outputs a mask
of the parts that are identical (slow and far from perfect).</li>
</ul>
<p>1.2.0 (private version)
</p>
<ul>
  <li>YV12Layer: no more useless RGB32 conversion! Approximately the same as
Arithmetic (except a third clip is not used), so that one is gone...</li>
  <li>YV12Substract: hey, why only a C version? Masks are really an underused
feature of AviSynth |-[</li>
</ul>
<p>1.1.0 (private version)
</p>
<ul>
  <li>Older inflate/deflate are renamed expand/inpand while newer functions
replace them</li>
  <li>Logic and Arithmetic functions added (shouldn't produce the expected
results because of no debugging)</li>
  <li>Edgemask now takes 4 thresholds (2 for luma and 2 for chroma). They are
used for:
    setting to 0 or leaving as is a value depending on first threshold, 
setting to 255 or leaving as is a value depending on the second one.</li>
</ul>
<p>1.0.2 (last version - public project dropped):
</p>
<ul>
  <li>Fix the shift for edgemask using sobel and roberts (misplaced MMX
instruction)</li>
  <li>MaskMerge now works (mask cleared before being used... check with
MaskMerge(clip3,clip3) for instance)</li>
</ul>
<p>1.0.1: Initial release
</p>
<h2><a name="developer"></a>VII) Developer's walkthrough
</h2>
<p>Skip to V) if you're not interested in developing the tools available.<br>
<br>
The project is a VC++ 6 basic project. Each filter has its own folder which
stores the header used by the interface, the source for the function
members, the source for processing functions and its header. Let's look at
EdgeMask:<br>
- EdgeMask.h is included by the interface to know what the filter 'looks like'
(but interface.cpp still holds the definition of the
calling conventions and exported functions)<br>
- EM_func.h describes the different processing functions (they should all have
the same prototype/parameters):<br>
  . Line_MMX and Line_C<br>
  . Roberts_MMX and Roberts_C<br>
  . Sobel_MMX and Sobel_C<br>
- EM_func.cpp, as all &lt;filter's initials&gt;_func.cpp, stores the
implementation of the processing functions, and sometimes their MMX
equivalents.<br>
- EdgeMask.cpp implements the class; the constructor select the appropriate
processing function (MMX? C? Roberts? Line? Sobel?) and uses
it to fill the generic protected function pointer used in GetFrame<br>
<br>
Interface.cpp stores the export function and all of the calling functions
(AVSValue ... Create_&lt;filter&gt;).<br>
<br>
ChannelMode.cpp defines the Channel operating modes. There could be added the
equivalent of a debugprintf.<br>
<br>
This quick walkthrough won't probably help most developers, as the examples of
V) for users, but that's the best I've come with so far. It will improve
of course over time depending on the success of the idea, which main drawback,
speed, will probably make it scarcely used, if ever. &lt;g&gt;
</p>
<p><kbd>$Date: 2005/10/03 16:31:31 $</kbd>
</p>
</body></html>
