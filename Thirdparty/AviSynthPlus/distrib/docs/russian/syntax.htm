<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html lang="ru"><head>
<!--
Automatically generated, don't change:
$Id: syntax.htm,v 1.27 2008/12/24 20:31:11 fizick Exp $
-->

<meta http-equiv="Content-Language" content="ru">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">

<title>AviSynth 2 - Базовый синтаксис (Basic Syntax)</title><link rel="stylesheet" type="text/css" href="../avisynth.css">
</head>

<body>
<h2><a name="Gettingstarted"></a>Начало работы</h2>
<p>Обычно работа с AviSynth строится таким образом: Сначала Вы
создаете простой текстовый документ со специальными командами,
называемый скриптом (т.е. сценарием, программой на языке Avisynth), и сохраняете файл. Эти команды соотносят
один или несколько видео-клипов с фильтрами, которыми Вы хотите их
обработать. Затем Вы запускаете видео-приложение, например VirtualDub,
и открываете в нем этот&nbsp;файл скрипта (скрипт-файл). Тогда и начинает работать AviSynth. Он
открывает видео-клипы, на которые ссылаются фильтры в скрипте,
выполняет фильтрование и передает результат видео-приложению.
Приложение при этом и не подозревает, что имеет дело с
AviSynth-ом, работающем в фоновом режиме. Наоборот, приложение
считает, что оно работает напрямую с уже ранее отфильтрованными
видео-клипами, находящимися у Вас на жестком диске. </p>
<p>В версиях AviSynth 2.х введена новая функциональность, а
часть функций преобразованы (по сравнению с AviSynth 1.0). Чтобы четче выделить пункты,
касающиеся новой функциональности (особенно недостаточно хорошо
документированные ранее), они помечены <strong>v2</strong>
</p>
<p>Версия 2.5 претерпела большие внутренние изменения. Перед ее
использованием прочтите внимательно <a href="twopointfive.htm">AviSynth
2.5</a>. Соответствующие изменения помечены <strong>v2.5</strong>
</p>
<h4>Линейное редактирование:</h4>
<p>Простейшее, что Вы можете выполнить с помощью AviSynth - того же
сорта, что вы можете выполнить в VirtualDub. Скрипты при этом просты
для написания: вам нет нужды волноваться о переменных и сложных
выражениях если вы этого не хотите. </p>
<p>Для начала создайте файл с именем version.avs (или любым другим,
лишь бы расширение было AVS) и вставьте туда следующую единственную
строку текста:
</p>
<pre>Version</pre>
<p>Теперь запустите, например, Windows Media Player, откройте в нем Ваш
файл и Вы должны увидеть 10-секундный видео-клип, показывающий номер
версии
AviSynth и copyright-информацию. </p>
<p><code>Version</code>
- то, что можно назвать "фильтром-источником", подразумевая, что он
формирует новый клип вместо модификации существующего. Первой командой
в скрипте AviSynth должен быть фильтр-источник. </p>
<p>Теперь добавьте вторую строчку в файл скрипта, так что он должен
читаться так: <br>
</p>
<pre>Version
ReduceBy2</pre>
<p>Снова откройте этот файл в Media
Player. Вы снова должны увидеть информацию о версии, но в половину
прежнего размера. <br>
<code><a href="corefilters/reduceby2.htm">ReduceBy2</a></code> -
"трансформирующий фильтр", это значит, что он берет предшествующий клип
и каким-то образом модифицирует его. Вы можете собрать последовательно
множество трансформирующих фильтров, как в VirtualDub. <br>
Например добавим еще один, чтобы сделать наше видео затухающим в
темноту в конце. Добавим еще строчку в файл скрипта: </p>
<pre>Version
ReduceBy2
FadeOut(10)</pre>
<p>Опять откроем файл. Клип должен быть таким же первые 9 секунд и
затем, на последней секунде должен плавно перейти в черный.
Фильтр <a href="corefilters/fade.htm">FadeOut</a>
берет целочисленный аргумент, который показывает число кадров, в
течении которых идет затухание. </p>
<p>Проходит много времени до начала затухания, так что давайте отрежем
начало клипа для уменьшения ожидания. <br>
Давайте отбросим первые 120 кадров и сохраним кадры 120-150: <br>
&nbsp; </p>
<pre>Version
ReduceBy2
# отрезать первые 119 кадров и сохранить кадры 120-150
# (AviSynth начинает отсчет с кадра 0)
Trim(120,150)
FadeOut(10)</pre>
<p>В этом примере впервые использован комментарий.<br>
Комментарий начинается с символа #, продолжается до конца строки и
полностью игнорируется AviSynth. <br>
Фильтр <a href="corefilters/trim.htm">Trim</a>
требует два аргумента разделенных запятой: первый и последний кадр
части клипа, которую следует сохранить. Если передать 0 как номер
последнего кадра, то это будет аналогично концу клипа, так что если Вы
просто желаете удалить первые 119 кадров, можно использовать команду
Trim(120,0). </p>
<p>Помнить число кадров таким образом муторно. Гораздо легче открыть
частично-готовый клип в приложении типа VirtualDub, которое покажет вам
номера кадров. Вы также можете использовать фильтр <a href="corefilters/showframes.htm">ShowFrameNumber</a>, который
впечатает номер кадра в клип. </p>
<p>На практике гораздо более используемым фильтром нежели <a href="corefilters/version.htm">Version</a> будет
<a href="corefilters/avisource.htm">AVISource</a>, считывающий AVI-файл
(или один из нескольких других типов файлов) с диска. Если у Вас под
рукой есть <em></em>AVI-файл, Вы можете попробовать использовать те же
фильтры на нем: <br>
&nbsp; </p>
<pre>AVISource("d:\capture.avi")&nbsp; # проставляется нужный путь к файлу
ReduceBy2
FadeOut(15)
Trim(120,0)</pre>
<p>Даже однострочный скрипт, содержащий только команду <code>AVISource</code>,
может быть весьма полезен для добавления поддержки AVI-<em></em>файлов
&gt;2GB к приложениям, поддерживающим только файлы &lt;2GB. <br>
</p>
<hr>
<h4>Нелинейное редактирование:</h4>
<p>Теперь перейдем к более веселой части. Сделаем AVI-файл со следующим
скриптом внутри: </p>
<pre>StackVertical(Version, Version)</pre>
<p>Теперь откроем его. Результат: Выходное видео имеет две идентичных строчки информации о версии, одна над другой. <br>
Вместо взятия чисел или строк как аргументов, <a href="corefilters/stack.htm">StackVertical</a> берет в качестве аргументов видео-клипы. В
этом скрипте фильтр Version вызывается дважды. Каждый раз, метод
возвращает копию клипа о версии. Эти два клипа затем передаются в <a href="corefilters/stack.htm">StackVertical</a>, который объединяет их
вместе (не интересуясь их происхождением). </p>
<p>Один из наиболее используемых фильтров такого типа это <a href="corefilters/splice.htm">UnalignedSplice</a>,
который соединяет видео-клипы друг-за-другом. Вот скрипт, который
грузит три AVI-файла (которые могут быть созданы AVI_IO) и объединяет
их вместе. </p>
<pre>UnalignedSplice(AVISource("d:\capture.00.avi"), \
  AVISource("d:\capture.01.avi"), \
  AVISource("d:\capture.02.avi"))</pre>
<p>Обе команды, <a href="corefilters/stack.htm">StackVertical</a> и <a href="corefilters/splice.htm">UnalignedSplice</a> могут принимать как
минимум два и как максимум шестьдесят аргументов. <br>
Вы можете использовать оператор "+" как короткий псевдоним для <a href="corefilters/splice.htm">UnalignedSplice</a>.
</p>
<p>К примеру, такой скрипт делает тоже, что и предыдущий: </p>
<pre>AVISource("d:\capture.00.avi") + \
  AVISource("d:\capture.01.avi") +  \
  AVISource("d:\capture.02.avi")</pre>
<p>Давайте теперь предположим, что Вы захватываете видео, используя
приложение, которое сохраняет видео в различных AVI сегментах, а звук
помещает в отдельном WAV файле. Можем ли мы воссоединить все? Ваш
выбор: </p>
<pre>AudioDub(AVISource("d:\capture.00.avi")+ \
  AVISource("d:\capture.01.avi")+ \
  AVISource("d:\capture.02.avi"),  \
  WAVSource("d:\audio.wav"))</pre>
<hr>
<h2><a name="Syntax"></a>Синтаксис (Syntax)</h2>
<h4>Выражения (Expressions):</h4>
<p>Скрипт AviSynth содержит множество строк утверждений такого вида:
&nbsp; </p>
<pre>variable_name = expression</pre>
<p>В этом примере результат вычислений выражения expression
присваивается переменной variable_name. </p>
<p>Очень важна общепринятая сокращенная форма: </p>
<pre>expression</pre>
<p>В данном случае происходит вычисление expression и результат
присваивается специальной переменной (клипу) <var>last</var> (что означает "последний").
<br>
Это аналогично<br>
</p>
<pre>last = expression</pre>
<p>Конец скрипта часто выглядит так: </p>
<pre>return expression</pre>
<p>Здесь происходит вычисление expression и его результат используется
в качестве "возвращаемого значения" скрипта - это и будет видео-клип
который покажет приложение, в котором открыли AVS-файл. <br>
Если команда return не указана в явном виде, то скрипт
возвращает в конце своей работы клип last ("последний"). </p>
<p>Основная форма выражения, которое выполняет функцию: </p>
<pre>Function(args)</pre>
<p>Функции работы с клипами всегда производит новый видео-клип, никогда
не модифицируя существующий, <br>
Args представляет список аргументов функции, разделяемых запятой. Этот
список может быть пустым (подразумевается, что все или часть из
аргументов являются необязательными) </p>
<p>Если функция-фильтр ожидает клип в качестве своего первого аргумента,
а этот аргумент не указан,
то этот клип берется из переменной <var>last</var></p>
<p>Фильтры AviSynth могут принимать также именованные аргументы. Они
могут указываться в любом порядке, <br>
и фильтр будет подставлять значения по умолчанию для всех пропущенных
аргументов
(именованные аргументы всегда необязательны). <br>
Это делает определенные фильтры намного более удобными в применении. </p>
<pre>Можно написать<br>
Subtitle("Hello, World!", text_color=$00FF00, x=100, y=200)<br>
вместо<br>
Subtitle("Hello, World!", 100, 200, 0, 999999, "Arial", 24, $00FF00)</pre>
<p>Альтернативный синтаксис (называемый
"ООП-записью" - в стиле объектно-ориентированного программирования) для
клиповых функций:<br>
</p>
<pre>expression.Function(args)<br>
например:
Version.ReduceBy2.FadeOut(15)</pre>
<p>что эквивалентно </p>
<pre>Function(expression, args)<br>
например:
FadeOut(15, ReduceBy2(Version))</pre>
<p>и подразумевает приложение функции <code>Function</code> к выражению <code>expression</code>.
<br>
Одно из неудобств ООП-записи - это возможность ее использования только
для фильтров с единственным аргументом типа клип, но никак не для
фильтров с несколькими такими аргументами. </p>
<p>Все AviSynth-функции производят определенное количество кадров с
определенной частотой кадров (framerate), даже если выражение выглядит
очень сложным. <br>
AviSynth, прочитав скрипт, знает какой длины будет выходной клип, какую
он будет иметь частоту кадров и соответственно
последовательность нарезки кадров из всех используемых источников. <br>Все
это вычисляется при открытии скрипта.&nbsp; Только фактическая
фильтрация производится во время выполнения по запросу (кадров). <br>
</p>
<hr>
<p><b>Комментарий (Comments)</b>:
AviSynth игнорирует все, начиная от символа # и до конца строки. </p>
<pre># комментарий</pre>
<p>В версии <em>v2.58</em> добавлена возможность размещать блок комментариев и вложенный комментарий
следующим образом:
<pre># блок комментариев:
/*
comment 1
comment 2
*/</pre>
<pre># вложенный комментарий:
[* [* a meaningful example with follow later :) *] *]</pre>

<p>AviSynth игнорирует все от ключевого слова <code>__END__</code> (с двойными подчеркиваниями) и до конца файла скрипта.
Это можно использовать для запрета выполнения некоторых команд скрипта.
</p>
<pre>Version()
__END__
ReduceBy2()
Результат будет без уменьшения (без действия команды ReduceBy2) и мы можем здесь писать любой текст
</pre>

<p><b>Игнорирование больших-малых букв (Ignore
Case)</b>: aViSouRCe ничуть не хуже AVISource. </p>
<p><b>Продолжение (Continue)</b> на следующей строке: \ </p>
<pre>Subtitle ("Test-Text")<br>
Subtitle ( \<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Test-Text")<br>
Subtitle (&nbsp;
 \ "Test-Text")</pre>
<p> </p>
<hr>
<h4>Переменные (Variables):</h4>
<p>Имя переменной может быть длиной до 50 символов (реально - более чем 4000 символов в Avisynth
<em>v2.56</em>) и содержать буквы (только латинские), цифры и подчеркивание (_), но никакие другие
символы. Имя не может начинаться с цифры. </p>
<p>Вы можете использовать символы из вашей языковой системной кодовой страницы (локали)
в строках и именах файлов (только ANSI 8 бит, не Unicode).</p>
<p>Возможно использование таких типов переменных: </p>
<p><var>clip</var>:
видео-клип, содержащий видео и/или звук. Как минимум одна переменная
типа клип должна использоваться и возвращаться скриптом. <br>
<var>string</var>:
строка - окружается либо "кавычками" (маркерами цитирования) либо
тройными кавычками как в """этом примере""". Текстовая строка может
содержать любые символы кроме прерывающих кавычек или двойного
апострофа. Если необходимо включить внутрь строки кавычки, следует
использовать тройные кавычки:
</p>
<pre>Subtitle ("""Это покажет "hello world" в кавычках""")</pre>
<p><var>int:</var>
целое - вводится как строка цифр, возможно дополненная + или - в
начале. <br>
<var>float:</var>
вводится как строка цифр с десятичной точкой (.) там где нужно, и
дополненная + или - в начале при необходимости. Например, +1.
трактуется как число с плавающей десятичной точкой (floating-point
number). <br>
<var>val:</var>
тип аргумента функции, для которого не имеет значения, целочисленный он
или с десятичной точкой <br>
<var>bool</var>:
логическое - может иметь значения только TRUE (истина) или FALSE (ложь)
<br>
<var>hexadecimal numbers</var>:
шестнадцатеричное число - вводится с предшествующим знаком $. Такая
переменная подразумевается целочисленной. Некоторые фильтры используют
такое представление для задания цвета. Например, $FF8800 задает
темно-оранжевый. </p>
<p><var>global</var>:
определяет глобальную переменную, которая может быть использована всеми
определенными пользователем (user-defined) функциями так же как и
основным скриптом.
</p>
<p>Вот другая версия ранее приведенного примера, который более
управляем
и легок для понимания: </p>
<pre>a = AVISource("d:\capture.00.avi")
b = AVISource("d:\capture.01.avi")
c = AVISource("d:\capture.02.avi")
sound_track = WAVSource("d:\audio.wav")
AudioDub(a+b+c, sound_track)</pre>
<p> </p>
<hr>
<h2> <a name="Colors"></a>Цвета (Colors)</h2>
<p>В некоторых фильтрах (BlankClip, Letterbox, AddBorders и FadeXXX)
можно задать аргумент цвета. В любом случае цвет должен задаваться в
RGB-формате, даже если цветовой формат входного клипа YUV. Параметр
можно задать как в шестнадцатиричном, так и в десятичном представлении.
Шестнадцатиричное представление цвета таково: первые две цифры определяют
канал красного цвета R, следующие две цифры - канал зеленого цвета G и
последние две цифры - канал синего цвета B. Шестнадцатиричное число
должно предваряться знаком $.
Десятичное представление цвета менее наглядно, так как представляет сумму
значения красного канала, умноженного на 65536 (2 в 16-й степени), плюс
значение зеленого канала, умноженного на 256 (2 в 8-й степени), плюс
значение синего канала.</p>
<p>Приведем пример. Коричневый цвет задается R=$A5 (165), G=$2A (42), B=$2A (42).
Таким образом <code>BlankClip(color=$A52A2A)</code> выдает коричневый кадр.
Конвертирование каждого канала в десятичное цифровое представление (помните,
что для него A=10, B=11, C=12, D=14, E=14, F=15) даст
</p>
<pre>R = $A5 = 10*16^1 +  5*16^0 = 165
G = $2A =  2*16^1 + 10*16^0 =  42
B = $2A =  2*16^1 + 10*16^0 =  42

165*65536 + 42*256 + 42 = 10824234</pre>
<p>Таким образом, для получения коричневого кадра с использованием
десятичного представления используется <code>BlankClip(color=10824234)</code>.
</p>
<p>Заданные определения (пресеты) общеупотребительных цветов моут быть найдены в файле <var>colors_rgb.avsi</var>,
который должен присутствовать в вашей папке автозагрузки плагинов (список определений посмотрите в файле).
Таким образом <code>BlankClip(color=color_brown)</code> даст те же коричневые кадры.</p>
<p>Обратите внимание, что черный RGB=$000000 будет преобразововаться в
Y=16, U=V=128, если цветовой формат входного клипа YUV, так как
используется цветовая конверсия по умолчанию RGB
[0,255] -&gt;YUV [16,235]. </p>
<hr>
<h2><a name="Operators"></a>Операторы (Operators)
</h2>
<p>Для всех типов
(clip, int, float, string, bool) переменных, над которыми выполняются
операции (операндов) можно выполнить операции: <br>
<code>==</code> проверить на равенство (equal)<br>
<code>!=</code>
проверить на неравенство (not equal)
<p>Для числовых (numeric) типов (int, float):
<br>
<code>+ </code>суммировать (add)<br>
<code>- </code>вычесть (subtract)
<br>
<code>* </code>умножить (multiply)
<br>
<code>/ </code>разделить (divide)
<br>
<code>% </code>остаток от деления (mod)
<br>
<code>&gt;=</code>
больше или равно (greater or equal than) <br>
<code>&lt;=</code>
меньше или равно (less or equal than) <br>
<code>&lt; </code>меньше (less
than) <br>
<code>&gt; </code>больше (greater
than) </p>
<pre>В предшествующих версиях AviSynth выражения обрабатывались справа налево, что приводило к неожиданным результатам: <br>
 a = 10 - 5 - 5 давало в результате 10 - (5 - 5) = 10 вместо (10 - 5) - 5 = 0 !<br>
 Этот недостаток был исправлен!
 Начиная с версии 2.53 также и умножение и деление обрабатывается слева направо (а не справа налево как ранее). </pre>
<p>Для строк (string type): <br>
<code>+ </code><code></code>суммировать (add)
<br>
<code>&gt;=</code>
больше или равно (не учитывая различия больших-малых букв) <br>
<code>&lt;=</code>
меньше или равно (не учитывая различия больших-малых букв) <br>
<code>&lt; </code>меньше (не учитывая различия больших-малых букв) <br>
<code>&gt; </code>больше (не учитывая различия больших-малых букв) </p>
Для клипов (clip type): <br>
<p><code>+ </code>аналогично функции <code>UnalignedSplice</code>
<br>
<code>++</code> аналогично функции <code>AlignedSplice</code>
</p>
<p>Для логических (bool) (true/false): <br>
<code>||</code> логическое ИЛИ (or) <br>
<code>&amp;&amp;</code> логическое И (and) <br>
<code>?:</code> условное исполнение кода (тернарный оператор языка C)
</p>
<pre>b = (a==true) ? 1 : 2

Это означает (как бы псевдо-BASIC):

if (a=true) then b=1 else b=2&nbsp;</pre>

<hr>
<h2><a name="ScriptFunctions"></a>Скрипт-функции (Script
Functions) </h2>
<p>Входные и выходные значения этих функций - не клипы, а некоторые
иные переменные, используемые в скрипте. </p>
<p></p>
<h4>Числовые функции:</h4>
<table border="1" width="95%">
  <tbody>
  <tr>
    <td WIDTH="62%"><code>Max(<var>int, int[, ...]</var>)</code> / <code>Max(<var>float, float[, ...]</var>)</code>:
	   Максимальная величина из набора чисел.</td>
    <td WIDTH="40%"><code>Max</code> (1, 2) = 2<br>
      <code>Max</code> (5, 3.0, 2) = 5.0</td>
  </tr>
  <tr>
    <td WIDTH="62%"><code>Min(<var>int, int[, ...]</var>)</code> / <code>Min(<var>float, float[, ...]</var>)</code>:
	   Минимальная величина из набора чисел.</td>
    <td WIDTH="40%"><code>Min</code> (1, 2) = 1<br>
      <code>Min</code> (5, 3.0, 2) = 2.0</td>
  </tr>
    <tr>
      <td width="62%"><code>MulDiv(<var>int m, int n, int d</var>)</code>:
(m*n+d/2)/d с 64-битным промежуточным результатом</td>
      <td width="40%"><code>MulDiv</code> (1, 1, 2) = 1<br>
      <code>MulDiv</code> (2, 3, 2) = 3</td>
    </tr>
    <tr>
      <td width="62%"><code>Floor(<var>float</var>)</code>: преобразует
float в int (округление вниз)<br>
      </td>
      <td width="40%"><code>Floor</code>
(1.2) = 1<br>
      <code>Floor</code>
(1.6) = 1<br>
      <code>Floor</code>
(-1.2) = -2<br>
      <code>Floor</code>
(-1.6) = -2</td>
    </tr>
    <tr>
      <td width="62%"><code>Ceil</code>
(<var>float</var>): преобразует float в int (округление вверх)<br>
      </td>
      <td width="40%"><code>Ceil</code>
(1.2) = 2<br>
      <code>Ceil</code>
(1.6) = 2<br>
      <code>Ceil</code>
(-1.2) = -1<code></code><br>
      <code>Ceil</code>
(-1.6) = -1</td>
    </tr>
    <tr>
      <td width="62%"><code>Round</code>
(<var>float</var>): преобразует float в int (по правилам округления)<br>
      </td>
      <td width="40%"><code>Round</code>
(1.2) = 1<br>
      <code>Round</code>
(1.6) = 2<br>
      <code>Round</code>
(-1.2) = -1<br>
      <code>Round</code>
(-1.6) = -2</td>
    </tr>
    <tr>
      <td width="62%"><code>Int</code>
(<var>float</var>): преобразует float в int (округление усечением
абсолютного значения - "rounds toward zero").</td>
      <td width="40%"><code>Int</code>
(1.2) = 1<br>
      <code>Int</code>
(1.6) = 1<br>
      <code>Int</code>
(-1.2) = -1<br>
      <code>Int</code>
(-1.6) = -1</td>
    </tr>
    <tr>
      <td width="62%"><code>Float</code>
(<var>int</var>): преобразует int в float.</td>
      <td width="40%"><code>Float</code> (1) = 1.0</td>
    </tr>
    <tr>
      <td width="62%"><code>Frac</code>
(<var>float</var>):
возвращает дробную часть переменной типа float.</td>
      <td width="40%"><code>Frac</code>
(3.7) = 0.7<br>
      <code>Frac</code>
(-1.8) = -0.8</td>
    </tr>
    <tr>
      <td height="4" width="62%"><code>Abs</code>
(<var>integer</var>)
/ <code>Abs</code>
(<var>float</var>): абсолютное значение integer или float
(возвращает целое для целого, вещественное для вещественного).</td>
      <td height="4" width="40%"><code>Abs</code>(6) = 6<br>
                                 <code>Abs</code>(-1.8) = 1.8</td>
    </tr>
    <tr>
      <td width="62%"><code>Sign</code>
(<var>int</var>)
/ <code>Sign</code>
(<var>float</var>): возвращает знак числа (положительное или
отрицательное) в виде -1, 0 or 1.</td>
      <td width="40%"><code>Sign</code>(-3.5)
= -1<br>
      <code>Sign</code>(3.5)
= 1<br>
      <code>Sign</code>(0)
= 0</td>
    </tr>
    <tr>
      <td height="24" width="62%"><code>HexValue</code>
(<var>string</var>) возвращает числовое значение шестнадцатеричной
строки<br>
      </td>
      <td height="24" width="40%"><code>HexValue</code>
("FF00") = 65280</td>
    </tr>
    <tr>
      <td colspan="2"></td>
    </tr>
    <tr>
      <td width="62%"><code>Sin</code>
(<var>float</var>) Возвращает значение синуса (аргумент задается в
радианах)<br>
      </td>
      <td width="40%"> Sin(Pi()/4) = 0.707&nbsp;<br>
Sin(Pi()/2) = 1.0</td>
    </tr>
    <tr>
      <td width="62%"><code>Cos</code>
(<var>float</var>) Возвращает значение косинуса (аргумент задается в
радианах)</td>
      <td width="40%"> Cos(Pi()/4) = 0.707&nbsp;<br>
Cos(Pi()/2) = 0.0</td>
    </tr>
    <tr>
      <td width="62%"><code>Pi</code>
() Возвращает число "пи" (константу, получаемую делением длины
окружности на его диаметр<br>
      </td>
      <td width="40%">d = Pi() # d == 3.141593</td>
    </tr>
    <tr>
      <td width="62%"><code>Log</code>
(<var>float</var>) Возвращает натуральный логарифм от аргумента<br>
      </td>
      <td width="40%"> Log(1) = 0.0&nbsp;<br>
Log(10) = 2.30259</td>
    </tr>
    <tr>
      <td width="62%"><code>Exp</code>
(<var>float</var>)&nbsp; Возвращает натуральную экспоненту от аргумента<br>
      </td>
      <td width="40%"> Exp(1) = 2.718282&nbsp;<br>
Exp(0) = 1.0</td>
    </tr>
    <tr>
      <td height="24" width="62%"><code>Pow</code>
(<var>float base, float power</var>)&nbsp; Возвращает "base",
возведенное в степень "power"<br>
      </td>
      <td height="24" width="40%"> Pow(2, 3) = 8&nbsp;<br>
Pow(3, 2) = 9&nbsp;<br>
Pow(3.45, 1.75) = 8.7334</td>
    </tr>
    <tr>
      <td width="62%"><code>Sqrt</code>
(<var>float</var>)&nbsp; Возвращает квадратный корень от аргумента </td>
      <td width="40%"> Sqrt(1) = 1.0<br>
Sqrt(2) = 1.4142</td>
    </tr>
    <tr>
      <td colspan="2"></td>
    </tr>
    <tr>
      <td width="62%"><code>Rand</code>(<var>[int
max] [, bool scale] [, bool seed]</var>): возвращает случайное целое
число между 0 и max.<br>
&nbsp; по умолчанию: max = 32768 <br>
&nbsp; scale = TRUE ( TRUE = normal mode, FALSE = modulus mode) <br>
&nbsp; seed = FALSE (TRUE = использовать время для задания начального
значения случайного генератора)</td>
      <td width="40%"><code>Rand</code>(100) = целое число между 0 и 99,
                    все числа равновероятны.<br>
                    <code>Rand</code>(32767, False) = целое число между 0 и 32766,
                    с 0 в двое более вероятным, чем другие числа.</td>
    </tr>
    <tr>
      <td width="62%"><code>Spline</code>
(<var>float X,&nbsp; x1,y1,
x2,y2, ...., bool "cubic"</var>}<strong>
v2.5</strong> <br>
&nbsp;
Интерполирует значение Y для точки X используя контрольные точки
x1/y1,... <br>
&nbsp;Необходимы как минимум 2 x/y-пары. <br>
&nbsp;
Интерполяция может быть кубической (результат - сплайн) или
линейной
(результат - ломаная)</td>
      <td width="40%"><code>Spline</code>
(5, 0,0, 10,10, 20,0, false) = 5<br>
      <code>Spline</code>
(5, 0,0, 10,10, 20,0, true) = 7</td>
    </tr>
  </tbody>
</table>
<h4>Строковые функции:</h4>
<table border="1" width="95%">
  <tbody>
    <tr>
      <td width="53%"><code>UCase</code>
(<var>string</var>): возвращает строку в верхнем регистре (большими
буквами)<br>
      </td>
      <td width="60%"><code>UCase</code>
("AviSynth") = "AVISYNTH"</td>
    </tr>
    <tr>
      <td width="53%"><code>LCase</code>
(<var>string</var>): возвращает строку в нижнем регистре</td>
      <td width="60%"><code>LCase</code>
("AviSynth") = "avisynth"</td>
    </tr>
    <tr>
      <td width="53%"><code>RevStr</code>
(<var>string</var>): возвращает строку в обратном порядке<br>
      </td>
      <td width="60%"><code>RevStr</code>
("AviSynth") = "htnySivA"</td>
    </tr>
    <tr>
      <td width="53%"><code>StrLen</code>
(<var>string</var>): возвращает длину строки</td>
      <td width="60%"><code>StrLen</code>
("AviSynth") = 8</td>
    </tr>
    <tr>
      <td width="53%"><code>Findstr</code>
(<var>string1, string2</var>):<br>
возвращает позицию строки string2 в составе string1. При поиске
учитывается размер букв.</td>
      <td width="60%"><code>Findstr</code>
("AviSynth","syn") = 4</td>
    </tr>
    <tr>
      <td width="53%"><code>LeftStr</code>
(<var>string, length</var>)
/ <code>RightStr</code>
(<var>string, length</var>):<br>
возвращает левую/правую часть строки указанной длины</td>
      <td width="60%"><code>LeftStr</code>
("AviSynth",3) = "Avi"</td>
    </tr>
    <tr>
      <td width="53%"><code>MidStr</code>
(<var>string, start [, length]</var>):<br>
возвращает часть строки от позиции start (для первого символа start=1)
длиной, указанной параметром length или до конца строки (если length не
задано).</td>
      <td width="60%"><code>MidStr</code>
("AviSynth",3,2) = "iS"</td>
    </tr>
    <tr>
      <td width="53%"><code>VersionNumber</code>
()</td>
      <td width="60%"><code>VersionNumber</code>
() = 2.07</td>
    </tr>
    <tr>
      <td width="53%"><code>VersionString</code>
()</td>
      <td width="60%"><code>VersionString</code>
() = "AviSynth 2.08 (avisynth.org) 22 nov. 2002"</td>
    </tr>
    <tr>
      <td width="53%"><code>Chr</code>
(<var>int</var>): возвращает символ с номером int согласно таблицы
символов ASCII <strong>v2.5</strong></td>
      <td width="60%"><code>Chr</code>
(34) возвращает символ кавычек<br>
      </td>
    </tr>
    <tr>
      <td width="53%"><code>Time</code>
(<var>string</var>):
возвращает системное время в виде строки указанного формата <strong>v2.5</strong></td>
      <td width="60%">Коды выходного формата: <br>
%a&nbsp; День недели в сокращенном виде <br>
%A День недели - полное имя <br>
%b&nbsp; Месяц в сокращенном виде <br>
%B полное название Месяца <br>
%c&nbsp; Дата и время в местном представлении <br>
%d&nbsp; День месяца как десятичное число (01 &ndash; 31) <br>
%H Час в 24-часовом формате (00 &ndash; 23) <br>
%I&nbsp;&nbsp; Час в 12-часовом формате (01 &ndash; 12) <br>
%j&nbsp;&nbsp; Номер дня в году, десятичный (001 &ndash; 366) <br>
%m&nbsp; Месяц как десятичное число (01 &ndash; 12) <br>
%M Минуты как десятичное число (00 &ndash; 59) <br>
%p&nbsp; Индикатор времени суток для 12-часового формата в местном
представлении (типа A.M./P.M.) <br>
%S&nbsp; Секунды как десятичное число (00 &ndash; 59) <br>
%U&nbsp; Номер недели в году как десятичное число, из расчета, что
начало недели - воскресенье (00
&ndash; 53) <br>
%w&nbsp; Номер дня недели как десятичное число (0 &ndash; 6;
воскресенье - это 0) <br>
%W Номер недели в году как десятичное число, из расчета, что начало
недели - понедельник (00
&ndash; 53) <br>
%x&nbsp; Дата в местном представлении <br>
%X Время в местном представлении <br>
%y&nbsp; Год - только последние 2 цифры, как десятичное число (00
&ndash; 99) <br>
%Y&nbsp; Год полностью, как десятичное число <br>
%z, %Z&nbsp; Имя временной зоны, полное или сокращенное; символы
отсутствуют, если зона неизвестна <br>
%% Знак процента&nbsp;
      <p>Флаг # может предварять кодовый символ для любого формата. В
данном это означает следующее: </p>
      <p>%#a, %#A, %#b, %#B, %#p,
%#X, %#z, %#Z, %#% флаг # игнорируется.&nbsp; <br>
%#c Используется длинное местное представление&nbsp; даты и времени.
Например: &ldquo;Вторник, 14 марта, 1995,
12:41:29&bdquo;.&nbsp; <br>
%#x Используется длинное местное представление&nbsp; даты. Например:
&ldquo;Tuesday, March 14, 1995&bdquo;.&nbsp; <br>
%#d, %#H, %#I, %#j, %#m, %#M, %#S, %#U, %#w, %#W, %#y, %#Y Удаляется
лидирующий ноль (если он присутствует). </p>
      </td>
    </tr>
  </tbody>
</table>
<p>
</p>
<h4>Преобразования:</h4>
<table border="1" width="95%">
  <tbody>
    <tr>
      <td width="50%"><code>Value</code>
(<var>string</var>): возвращает значение строки.</td>
      <td width="50%"><code>Value</code>
( "-2.7" ) = -2.7</td>
    </tr>
    <tr>
      <td width="50%"><code>String</code>
(<var>float / int / string,
format_string</var>): преобразует цифру в строку.<br>
      <p>Если переменная типа float или int, она приводится к виду
float и в соответствии с форматной строкой преобразовывается в строку.</p>
      <p>Синтаксис форматной строки:</p>
      <p>%[flags][width][.precision]f<br>
width: длина выходной строки (минимальная, строка в любом случае не
обрезается)<br>
precision: число печатаемых цифр<br>
flags:<br>
      <tt>&nbsp;-&nbsp;&nbsp; </tt>выравнивание по левому краю (обычно
выравнивается по правому краю)<br>
      <tt>&nbsp;+&nbsp;&nbsp; </tt><tt>отображать</tt><tt> знаковый
символ </tt>+/-<br>
      <tt>&nbsp;0&nbsp;&nbsp; проставлять лидирующие ноли</tt><br>
      <tt>&nbsp;'&nbsp;'&nbsp;</tt><tt>отображать</tt><tt> пробел
вместо символа</tt> "+"<br>
      <tt>&nbsp;#&nbsp;&nbsp; всегда отображать </tt>десятичную точку<br>
      </p>
      </td>
      <td width="50%">Например <br>
      <code>Subtitle</code>
("Высота кадра: " + <code>String</code>
(last.height) )<br>
      <br>
      <code>String</code>(1.23,
"%f") = '1.23'<br>
      <code>String</code>(1.23,
"%5.1f") = ' 1.2'<br>
      <code>String</code>(1.23,
"%1.3f") = '1.230' </td>
    </tr>
  </tbody>
</table>
<h4>Функции проверки версии:</h4>
<table BORDER WIDTH="95%" >
  <tr>
    <td WIDTH="50%"><code>VersionNumber</code> () <br>
    Возвращает номер версии AviSynth как float число</td>
    <td WIDTH="50%"><code>VersionNumber</code> () = 2.56</td>
  </tr>
  <tr>
    <td WIDTH="50%"><code>VersionString</code> () <br>
    Возвращает информацию о версии  AviSynth как строку (первая строка используется в комманде <code>Version</code>).</td>
    <td WIDTH="50%"><code>VersionString</code> () = "AviSynth 2.56, build:Oct 28 2005 [18:43:54]"
      </td>
  </tr>
</table>
<h4>Функции проверки (Test functions):</h4>
<p><code>IsBool(<var>var</var>)
</code> - является логическим<br>
<code>IsInt(<var>var</var>)
</code> - является целым числом<br>
<code>IsFloat(<var>var</var>)
</code> - является вещественным числом<br>
<code>IsString(<var>var</var>)
</code> - является строкой<br>
<code>IsClip(<var>var</var>)
</code>- является клипом</p>
<p></p>
<h4>Другие функции:</h4>
<p><code>Select</code>
(<var>index, item0 [, item1...]</var>) - выбрать:
Возвращает значение из множества item, выбираемое по его индексу index
(0=item0). Item могут быть любыми переменными или клипами, допустимы
даже смешанные ряды.<br>
<code>Defined</code>
(<var>var</var>) - определено ли:
для задания необязательных параметров в функциях, определяемых
пользователем. <br>
<code>Default</code>
(<var>x, d</var>) - по умолчаниию: возвращает значение x, если оно определено (справедливо
Defined(x)), иначе - возвращает d. <br>
<code>Exist</code>
(<var>filename</var>) - существует: возвращает TRUE или FALSE по результату проверки
на наличие файла.<br>
<code>NOP</code>
(): возвращает NULL (ничего). Предназначено главным образом для операций
условного выполнения для пунктов, не возвращающих никаких
значений, таких как <code>import</code>, когда нет желательного (клипа) по условию "else"(:).<br>
<code>Eval</code>
(<var>string</var>) - вычислить,<br>
<code>Apply</code>
(<var>func-string, arg,...</var>) - применить:
<code>Eval</code>
("f(x)") эквивалентно выполнению <code>f(x)</code>, что также эквивалентно
<code>Apply</code>
("f", x)
</p>
<pre>Eval можно использовать, например, так:
settings = "352, 288"<br>Eval( "BicubicResize(" + settings + ")" )</pre>
<p><code>Import</code>(<var>filename</var>): выполняет содержимое
другого файла с avisynth-скриптом (импортирует в место, где вызывается,
текст другого скрипта) </p>
<p>Для сообщений об ошибках и перехвата некорректных входных значений в
функции, определяемые пользователем, можно использовать: <br>
<code>Assert</code>(<var>bool,
string error-message</var>) </p>
<p><code>Try
... Catch</code>: это функция, проверяющая, не возникнет ли конкретная
ошибка в строках кода после <code>Try</code> и передающая управление (при ее
возникновении) в блок после <code>Catch</code>:
</p>
<pre>Try {
&nbsp; AviSource("file.avi")
}
Catch(err_msg) {
&nbsp;&nbsp; Blackness.Subtitle(err_msg)
}</pre>
<hr>
<h2><a name="RuntimeFunctions"></a>Функции времени исполнения (Runtime
Functions)</h2>
<p>Имеются <a href="corefilters/conditionalfilter.htm">Conditional
Filters</a> (условные фильтры), которые работают в процессе исполнения
скрипта, что позволяет Вам изменять переменные с учетом особенностей
конкретного кадра. <br>
Для решения большинства задач необходимо использовать <a href="corefilters/conditionalfilter.htm#RuntimeFunctions">Runtime
Functions</a>
(функции времени исполнения), которые обрабатывают содержимое клипа и
возвращают значение. <strong>v2.5</strong>
<br>
&nbsp; </p>
Вот простой пример, вычисляющий среднее значение яркостной составляющей (luma) для каждого кадра
&nbsp;и показывающий результат.<br>
<pre>Version()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # генерирует тестовый клип
ConvertToYV12&nbsp;&nbsp; # преобразовываем в цветовой формат YV12
FadeIn(10)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # обеспечиваем изменение яркости (luma) чтобы увидеть изменения<br>
ScriptClip(" Subtitle(String(AverageLuma())) ")&nbsp; # выводим субтитры Subtitle(...) для каждого кадра,
         # формируемые с учетом значений, выдаваемых AverageLuma
         # и преобразованных в строку
ConvertToRgb&nbsp;&nbsp;&nbsp; # показываем полученный результат в RGB-формате</pre>
<hr>
<h2><a name="ControlFunctions"></a>Управляющие функции (Control
Functions) </h2>
<p><code>SetMemoryMax</code>
(<var>int</var>):
Устанавливает максимальный объем используемой памяти в МегаБайтах&nbsp;(MB).
При значении 0 просто возвращает текущее значение Memory Max.<strong> v2, (=0) v2.5.8</strong><br></p>
<p>В серии версий 2.5 по умолчанию значение Memory Max составляет 25% от свободной физической
памяти, с минимумом в 16MB. С версии 2.5.8 RC4, значение Memory Max по умолчанию также ограничено 512MB.</p>
<table>
  <tr>
    <th>Свободная память:</th>
    <td>&lt;64</td>
    <td>128</td>
    <td>256</td>
    <td>512</td>
    <td>1024</td>
    <td>2048</td>
    <td>3072</td>
  </tr>
  <tr>
    <th>Max по умолчанию в 2.5.7 и ранее:</th>
    <td>16</td>
    <td>32</td>
    <td>64</td>
    <td>128</td>
    <td>256</td>
    <td>512</td>
    <td>768</td>
  </tr>
  <tr>
    <th>Max по умолчанию с 2.5.8 RC4:</th>
    <td>16</td>
    <td>32</td>
    <td>64</td>
    <td>128</td>
    <td>256</td>
    <td>512</td>
    <td>512</td>
  </tr>
</table>
В некоторых старых версиях значение по умолчанию 5 MB, что весьма мало.
Если наблюдаются проблемы (например, низкая скорость), попробуйте
установить это значение не менее 32MB (лучше 128).
Слишком большие величины могут привести к аварии из-за предела адресного пространства 2 Гбайт.<br>
Возвращаемое значение:
действующая установленная величина максимальной памяти.<br>
</p>
<p><code>SetPlanarLegacyAlignment</code> (<var>clip, bool</var>):
Устанавливает режим выравнивания планарных кадров<strong>
v2.5.6</strong><br>
Некоторые старые плагины некорректно размещают видеокадры в памяти.
Этот специальный фильтр принудительно задает размещение видеокадров в
памяти совместимым с более ранними версиями AviSynth образом. Фильтр
работает со стеком функции GetFrame(), потому его действие
распространяется на фильтры, размещенные в скрипте <strong>до</strong>
него.</p>
<pre><strong>Пример: использование старой версии Mpeg2Source()</strong><br>
LoadPlugin("...\Mpeg2Decode.dll")
Mpeg2Source("test.d2v")         # плагин некорректно задает размещение в памяти
SetPlanarLegacyAlignment(true)  # устанавливаем правильное выравнивание под предыдущие выражения
ConvertToYUY2()                 # выражения вплоть до конца скрипта имеют современный тип ...
                                # выравнивания (следовательно для них ничего принудительно менять не надо)</pre>

<p><code>SetWorkingDir</code>
(<var>string</var>):
Устанавливает рабочий каталог Avisynth. <strong>v2</strong>
<br>
Используется для облегчения загрузки исходных клипов и т.п. Не влияет
на автозагрузку плагинов. Возвращает 0 при успехе, -1 при неудаче.
<br>
</p>
<p><code>global OPT_AllowFloatAudio=True</code>: <strong>v2.57</strong><br>
  Эта опция разрешает аудио выход формата WAVE_FORMAT_IEEE_FLOAT (с плавающей точкой).
  По умолчанию - автоматически преобразовывать такое Float аудио в 16-бит (целые числа).</p>

<p><code>global OPT_UseWaveExtensible=True</code>: <strong>v2.58</strong><br>
  Эта опция разрешает WAVE_FORMAT_EXTENSIBLE вывод звука.
  По умолчанию устанавливается WAVE_FORMAT_EX.</p>

<p>Замечание: DirectShow компонент по умолчанию для .AVS файлов, "AVI/WAV File Source",
  некорректно реализует обработку WAVE_FORMAT_EXTENSIBLE, и таким образом многие
  приложения могут быть не способны получить аудио дорожку. Существуют
  DirectShow считыватели других производителей, которые работают корректно. Промежуточные рабочие файлы,
  написанные используя AVIFile интерфейс для последующей обработки DirectShow, будут
  работать корректно, если они используют DirectShow "File Source (async)" компонент
  или эквивалентный.

<hr>
<h2><a name="ClipProperties"></a>Свойства клипа (Clip
Properties)</h2>
<p>Следующие функции принимают на вход клип и возвращают его свойства.
</p>
<table border="1" width="100%">
  <tr>
    <td width="20%"><code>Width</code> (<var>clip</var>)</td>
    <td width="50%">Возвращает ширину кадра клипа в пикселах (тип: int).</td>
  </tr>
  <tr>
    <td width="20%"><code>Height</code> (<var>clip</var>)</td>
    <td width="50%">Возвращает высоту кадра клипа в пикселах (тип: int).</td>
  </tr>
  <tr>
    <td width="20%"><code>Framecount</code> (<var>clip</var>)</td>
    <td width="50%">Возвращает количество кадров в клипе (тип: int).</td>
  </tr>
  <tr>
    <td width="20%"><code>Framerate</code> (<var>clip</var>)</td>
    <td width="50%">Возвращает скорость клипа - количество кадров в секунду (тип:
      float).</td>
  </tr>
  <tr>
    <td width="20%"><code>FramerateNumerator</code> (<var>clip</var>) <strong>v2.55</strong></td>
    <td width="50%">Числитель частоты кадров (тип: int).</td>
  </tr>
  <tr>
    <td width="20%"><code>FramerateDenominator</code> (<var>clip</var>) <strong>v2.55</strong></td>
    <td width="50%">Знаменатель частоты кадров (тип: int).</td>
  </tr>
  <tr>
    <td width="20%"><code>Audiorate</code> (<var>clip</var>)</td>
    <td width="50%">Возвращает частоту выборки звука в клипе.</td>
  </tr>
  <tr>
    <td width="20%"><code>Audiolength</code> (<var>clip</var>)</td>
    <td width="50%">Возвращает количество выборок звука в клипе (тип: int).
      Учтите, на слишком длинных клипах возможно переполнение (кол. выборок ограничено 2^31).</td>
  </tr>
  <tr>
    <td width="20%"><code>AudiolengthF</code> (<var>clip</var>) <strong>v2.55</strong></td>
    <td width="50%">Возвращает количество выборок звука в клипе (тип: float).</td>
  </tr>
  <tr>
    <td width="20%"><code>Audiochannels</code> (<var>clip</var>)</td>
    <td width="50%">Возвращает количество звуковых каналов в клипе.</td>
  </tr>
  <tr>
    <td width="20%"><code>Audiobits</code> (<var>clip</var>)</td>
    <td width="50%">Возвращает "битовую глубину" - количество бит квантования звука в клипе.</td>
  </tr>
  <tr>
    <td width="20%"><code>IsAudioFloat</code> (<var>clip</var>) <strong>v2.55</strong></td>
    <td width="50%">Возвращает true, если "битовая глубина" звука в клипе представлена во float.</td>
  </tr>
  <tr>
    <td width="20%"><code>IsAudioInt</code> (<var>clip</var>) <strong>v2.55</strong></td>
    <td width="50%">Возвращает true, если "битовая глубина" звука в клипе представлена в integer.</td>
  </tr>
  <tr>
    <td width="20%"><code>IsRGB</code> (<var>clip</var>)</td>
    <td width="50%">Возвращает true, если клип RGB, иначе false (type: bool).</td>
  </tr>
  <tr>
    <td width="20%"><code>IsRGB24</code> (<var>clip</var>)</td>
    <td width="50%">Возвращает true, если клип RGB24, иначе false (type:
      bool).</td>
  </tr>
  <tr>
    <td width="20%"><code>IsRGB32</code> (<var>clip</var>)</td>
    <td width="50%">Возвращает true, если клип RGB32, иначе false (type:
      bool).</td>
  </tr>
  <tr>
    <td width="20%"><code>IsYUY2</code> (<var>clip</var>)</td>
    <td width="50%">Возвращает true, если клип YUY2, иначе false (type:
      bool).</td>
  </tr>
  <tr>
    <td width="20%"><code>IsYV12</code> (<var>clip</var>) <strong>v2.51</strong></td>
    <td width="50%">Возвращает true, если клип YV12, иначе false (type:
      bool).</td>
  </tr>
  <tr>
    <td width="20%"><code>IsYUV</code> (<var>clip</var>) <strong>v2.54</strong> </td>
    <td width="50%">Возвращает true, если клип YUV, иначе false (type:
      bool).</td>
  </tr>
  <tr>
    <td width="20%"><code>IsPlanar</code> (<var>clip</var>) <strong>v2.51</strong> </td>
    <td width="50%">Возвращает true, если клип имеет планарный цветовой формат
    (каждая цветовая плоскость в отдельном массиве), иначе false (type: bool).</td>
  </tr>
  <tr>
    <td width="20%"><code>IsInterleaved</code> (<var>clip</var>) <strong>v2.51</strong> </td>
    <td width="50%">Возвращает true, если клип имеет цветовой формат с чередованием
    цветовых данных для каждого пиксела, иначе false (type: bool).</td>
  </tr>
  <tr>
    <td width="20%"><code>IsFieldBased</code> (<var>clip</var>)</td>
    <td width="50%">Возвращает true, если клип основан на полях (разделен на поля) (type: bool).</td>
  </tr>
  <tr>
    <td width="20%"><code>IsFrameBased</code> (<var>clip</var>)</td>
    <td width="50%">Возвращает true, если клип основан на полных кадрах (type: bool).</td>
  </tr>
  <tr>
    <td width="20%"><code>GetParity</code> (<var>clip, int "n"</var>)</td>
    <td width="50%">Возвращает true, если кадр n (по умолчанию 0) является верхним полем
    (Top Field) клипа, разделенного на поля, или полным кадром с верхним полем первым (TFF)
    неразделенного на поля клипа (type: bool).</td>
  </tr>
  <tr>
    <td width="20%"><code>HasAudio</code> (<var>clip</var>) <strong>v2.56</strong> </td>
    <td width="50%">Возвращает true, если клип содержит звук, иначе false (type:
      bool).</td>
  </tr>
  <tr>
    <td width="20%"><code>HasVideo</code> (<var>clip</var>) <strong>v2.56</strong> </td>
    <td width="50%">Возвращает true, если клип содержит видео, иначе false (type:
      bool).</td>
  </tr>
</table>
<pre>Не забывайте: свойства можно использовать также относительно встроенной переменной LAST
или в варианте ООП-записи:<br>BilinearResize(Width/2, Height/2)
&nbsp;&nbsp; то же, что и
BilinearResize(Width(Last)/2, Height(Last)/2)
&nbsp;&nbsp; и то же, что и
BilinearResize(Last.Width / 2, Last.Height / 2)</pre>
<p> </p>
<hr>
<h2><a name="userdefined"></a>Функции, определяемые пользователем
(User-Defined
Functions) </h2>
<p>Вы можете определить (создать) свою собственную функцию. Лучше
объяснить на примере: <br>
&nbsp; </p>
<pre>Function NTSC2PAL( clip c) {
&nbsp;&nbsp;&nbsp; Assert(c.height == 480, "NTSC2PAL: входной клип должен иметь разрешение в 480 строк")
&nbsp;&nbsp;&nbsp; Bob(c, height=576)
&nbsp;&nbsp;&nbsp; return Weave()
}</pre>
<p>Возможно даже создать рекурсивную (включающую собственный вызов)
функцию. <br>
&nbsp; </p>
<pre>function TRANSITION(clip clip, int start, int expo, int overlap)
{
   return ( start &gt;= clip.framecount-expo ?
\      Trim(clip,start,0) :
\      Dissolve(Trim(clip,start,start+expo-1),
\         TRANSITION(clip,start+expo,expo,overlap),
\         overlap
\              )
\         )
}</pre>
<p> </p>
<hr>
<h2><a name="multiclip"></a>Функции с более чем одним входным клипом </h2>
<p>Некоторые функции комбинируют различным образом работу с двумя и
более клипами. <br>
Как именно обрабатывается видео содержание зависит от конкретной
функции, здесь же приведем коротко, какие свойства обретает
результирующий клип. </p>
<p>Входные клипы обязательно должны иметь одинаковый цветовой формат и,
за исключением <i>Layer</i>
- одинаковое разрешение. <br>
&nbsp;
<table border="1">
  <tbody>
    <tr>
      <td></td>
      <td>
      <center> <b>скорость видео</b> </center>
      </td>
      <td colspan="2">
      <center> <b>количество кадров</b> </center>
      </td>
      <td>
      <center> <b>содержимое звука</b> </center>
      </td>
      <td>
      <center> <b>параметры звука</b> </center>
      </td>
    </tr>
    <tr>
      <td><b>AlignedSplice,
UnalignedSplice</b></td>
      <td rowspan="6">
      <center> первый клип </center>
      </td>
      <td>
      <center>сумма всех клипов </center>
      </td>
      <td></td>
      <td>
      <center>смотри описание фильтра<br>
      </center>
      </td>
      <td rowspan="7">
      <center>из первого клипа<br>
      </center>
      </td>
    </tr>
    <tr>
      <td><b>Dissolve</b></td>
      <td>
      <center>сумма всех клипов за вычетом перекрытий </center>
      </td>
      <td></td>
      <td>
      <center> смотри описание фильтра </center>
      </td>
    </tr>
    <tr>
      <td><b>Merge, MergeLuma, MergeChroma, Merge(A)RGB</b></td>
      <td rowspan="2">
      <center>как у первого клипа </center>
      </td>
      <td rowspan="5">
      <center>последний кадр кратчайшего клипа повторяется до конца
суммарного клипа </center>
      </td>
      <td rowspan="5">
      <center> первый клип<br>
      </center>
      </td>
    </tr>
    <tr>
      <td><b>Layer</b></td>
    </tr>
    <tr>
      <td><b>Subtract</b></td>
      <td rowspan="2">
      <center>как у наиболее длинного клипа </center>
      </td>
    </tr>
    <tr>
      <td><b>StackHorizontal,
StackVertical</b></td>
    </tr>
    <tr>
      <td><b>Interleave</b></td>
      <td>
      <center> (к/с из 1-го клипа) <br>
x <br>
(количество клипов) </center>
      </td>
      <td>
      <center>N-кратное количество кадров от наиболее длинного клипа </center>
      </td>
    </tr>
  </tbody>
</table>

<p>Как Вы видите - функции не полностью симметричны, но принимают часть
атрибутов первого клипа. <br>
</p>
<hr>
<h2><a name="Plugins"></a>Плагины (Plugins)
</h2>
<p>С помощью следующих функций-загрузчиков Вы можете добавить внешние
функции
для использования AviSynth-ом. </p>
<p><code>LoadPlugin</code>
(<var>"filename" [, ...]</var>)
</p>
<p>Загружает один (или более) плагинов (в виде DLL-модулей). <br>
</p>
<hr>
<p><code>LoadVirtualDubPlugin</code>
(<var>"filename",
"filtername", preroll</var>) </p>
<p>Эта функция загружает плагины, написанные для VirtualDub. Здесь
"filename" - это имя .vdf-файла. После вызова этой
функции VirtualDub-фильтры становятся доступными avisynth с именами,
заданными параметром "filtername".
VirtualDub-фильтры работают только с форматом RGB32. Даже с видео в
формате
RGB24, необходимо использовать <code>ConvertToRGB32</code>
(<code>ConvertToRGB</code> недостаточно). </p>
<p>Выходные данные некоторых фильтров зависят от содержимого предыдущих
кадров; для них необходимо установить опережающую обработку данных как
минимум на количество кадров <var>preroll</var>, необходимых для пре-процессинга, чтобы
заполнить их буферы и/или отследить актуальные значения их внутренних
переменных. <br>
</p>
<hr>
<p><code>LoadVFAPIPlugin</code>
(<var>"filename",
"filtername"</var>)
</p>
<p>Функция позволяет использовать плагины VFAPI (импортируемые
TMPGEnc плагины).<br>
</p>
<hr>
<p>
<code>LoadCPlugin</code> (<var>&quot;filename&quot; [, ...]</var>)<br>
<p><code>Load_Stdcall_Plugin</code> (<var>&quot;filename&quot; [, ...]</var>)
<p>
Функции загружает так называемые AviSynth C-плагины (в виде DLL-модулей).</p>
<p>
Load_Stdcall_Plugin() - синоним LoadCPlugin().
C-plugins (читать - "Си-плагины") это плагины, созданные на языке C  с использованием "Avisynth C API"
(в отличие от обычных плагинов созданных на MS VC++).
Они должны загружаться с помощью функций
LoadCPlugin() или Load_Stdcall_Plugin().<br>
Kevin создал LoadCPlugin.dll для переназначения функции LoadCPlugin()
с целью поддержки C-плагинов, скомпилированных с использованием
обычного соглашения вызова подпрограмм на Си (cdecl), используйте Load_Stdcall_Plugin() для загрузки
C-плагинов со стандартным соглашением вызова (stdcall) в случае использования версии Kevin-а.
Советуем избегать размещения таких C-плагинов в директории
авто-загрузки плагинов во избежание серьезных
проблем. <a href="http://forum.doom9.org/showthread.php?s=&amp;threadid=58840">[англоязычное
обсуждение]</a>
<a href="http://kevin.atkinson.dhs.org/avisynth_c/">[AVISynth
C API (by
kevina20723)]</a></p>
<hr>
<h2><a name="autoloading"></a>Авто-загрузка плагинов и приоритет имен
(name precedence) <strong>v2</strong></h2>
<p>Можно размещать все файлы плагинов и скрипт-файлы с функциями,
определяемыми пользователем или (глобальными) переменными в директории,
откуда все файлы с расширениями .AVSI (<strong>v2.08, v2.5</strong>,
был тип .AVS в версиях <strong>v2.05-2.07</strong>) и .DLL будут загружаться при
старте, динамично выгружаться и вновь загружаться по мере необходимости
при работе скрипта. </p>
<p>Включаемые скрипт-файлы .AVSI в этой директории должны содержать только определения
функций и глобальные переменные, и не иметь исполняемых фрагментов
(иначе возможно появление непонятных ошибок), также не рекомендуется
размещать другие файлы в этой директории. </p>
<p>Путь к этой директории сохраняется в системном регистре (место
хранения в регистре изменено для <strong>v2.5</strong>).
Двойной клик на .REG-файле следующего содержания позволит задать
необходимый путь к нужной директории (конечно, если указан корректный
путь): <br>
&nbsp; </p>
<pre>REGEDIT4<br>
[HKEY_LOCAL_MACHINE\SOFTWARE\Avisynth]
"plugindir2_5"="c:\\program files\\avisynth 2.5\\plugins"</pre>
<p>(Указанная папка автоматически создается и регистрируется при установке AviSynth 2.5)</p>
<p>Порядок выполнения функций&nbsp; определяется следующими правилами: </p>
<pre>функции, определяемые пользователем (всегда имеют высший приоритет)
   плагин-функции (имеют более высокий приоритет
   по отношению к встроенным функциям и будут подменять их)
       встроенные функции</pre>
<p>В пределах этих групп загрузка функций выполняется в порядке
следования (последняя получает преимущество), не генерируются ошибки конфликта имен. </p>
<h2><a name="autoloading_confl"></a>Автозагрузка плагинов и конфликты
имен функций <strong>v2.55</strong>
</h2>
<p>Начиная с версии 2.55 поддерживается
DLLName_function(). Проблема заключается в возможной загрузке двух
плагинов, содержащих функции с одинаковыми названиями. Для загрузки
нужной функции из них и предназначена DLLName_function().
Она генерирует автоматически дополнительные имена
как для автозагруженных плагинов, так и для плагинов, загруженных функцией
LoadPlugin. </p>
<p><b>Некоторые примеры:</b> </p>
<pre># использование функции fielddeinterlace из decomb510.dll
AviSource("D:\captures\jewel.avi")
decomb510_fielddeinterlace(blend=false)</pre>
<p>Предполагается что в каталоге автозагрузки имеются плагины
mpeg2dec.dll и mpeg2dec3.dll, и Вы хотите загрузить d2v-файл с помощью
mpeg2dec.dll
(в выходном формате YUY2): </p>
<pre># использовать mpeg2source из mpeg2dec.dll
mpeg2dec_mpeg2source("F:\From_hell\from_hell.d2v")</pre>
<p>или с помощью mpeg2dec3.dll (выходной формат которой YV12): </p>
<pre># использовать mpeg2source из mpeg2dec3.dll
mpeg2dec3_mpeg2source("F:\From_hell\from_hell.d2v")</pre>

<kbd>$English Date: 2008/12/06 16:37:26 $<br>
Русский перевод 16.05.2005-23.09.2007 Turyst04 <a href="mailto:Turyst04@nm.ru">Turyst04@nm.ru</a><br>
Обновления 20.09.2007-24.12.2008 Fizick</kbd>
</body></html>