<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML lang="ru">
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
   <TITLE>hybrid video</TITLE>
   <link rel="stylesheet" type="text/css" href="../../avisynth.css">
<!--
Automatically generated, don't change:
$Id: hybrid_video.htm,v 1.6 2008/07/18 17:28:04 fizick Exp $
-->
</HEAD>
<BODY>

<style>
.note { margin-top: 10px; margin-bottom: 10px;
       background-color: #B0D0B0;
       padding-left: 12px; padding-top: 12px; padding-right: 12px; padding-bottom: 12px;
       border: 1px #709030 dotted;
       border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px}

</style>



<h1>AviSynth, видео с переменной частотой кадров (vfr) и гибридное видео</h1>

<P>По такому параметру как частота кадров видеоматериалы делятся на два типа:
с постоянной частотой кадров (CFR = constant frame rate) и с переменной (VFR = variable frame rate).
У CFR-видео все кадры имеют одинаковую длительность, у VFR длительность
кадров непостоянна.

Большинство программ для работы с видео (включая VirtualDub и AviSynth) предполагают,
что видео имеет постоянную частоту кадров. Одна из причин - это то, что контейнер
AVI не поддерживает VFR-видео. И такое положение дел не изменится в ближайшем
будущем <a href="http://forum.doom9.org/showthread.php?s=&amp;threadid=69132">по различным причинам.</a>
И, хотя контейнер AVI не поддерживает VFR, существуют контейнеры, которые его
поддерживают (например: MKV, MP4 и WMV/ASF).</p>


<h2>Содержание</h2>
<ul>
  <li><a href="#hybrid">Видео с переменной частотой кадров и гибридное видео</a></li>
  <li><a href="#recognize-vfr">Как распознать VFR-материал (mkv/mp4)</a></li>
  <li><a href="#enc-hybrid-mpeg2">Загрузка гибридного видео (MPEG-2) в AviSynth и его кодирование</a>
    <ul>
      <li><a href="#enc-cfr">кодирование как 23.976 fps или 29.97 fps</a></li>
      <li><a href="#enc-120">кодирование как 120 fps, используя AVI с "выброшенными" кадрами</a></li>
      <li><a href="#create-vfr-mkv">создание VFR-видео в контейнере MKV (matroska/матрёшка)</a></li>
      <li><a href="#create-vfr-mp4">создание VFR-видео в контейнере MP4</a></li>
      <li><a href="#summary-methods">подведем итоги по методам</a></li>
    </ul>
  </li>
  <li><a href="#reenc-vfr">Загрузка гибридного видео (не MPEG-2) в AviSynth и его кодирование</a>
    <ul>
      <li> <a href="#open-vfr-non_mpeg2">загрузка не AVI VFR-материала в AviSynth</a></li>
      <li><a href="#reenc-vfr-dss-non_mpeg2">перекодирование 120 fps VFR-видео</a></li>
      <li><a href="#open-vfr-avi">Пребразование vfr в cfr avi для AviSynth</a></li>
      <li><a href="#reenc-mkv2vfr">кодирование VFR-видео в MPEG-2</a></li>
    </ul>
  </li>
  <li><a href="#audio-sync">Синхронизация со звуком</a></li>
  <li><a href="#references">Ссылки</a></li>
</ul>


<h2><a name="hybrid"></a>Видео с переменной частотой кадров и гибридное видео</h2>

<P>Важно понимать, что видео по сути своей является в основном CFR (по крайней
мере при видео-захвате и DVD-рипе). Но есть один случай, когда использование
VFR весьма полезно - это гибридное видео. Гибридное видео состоит из фрагментов,
часть из которых является чересстрочным или прогрессивным NTSC (29.97 кадров в секунду),
а остальные - FILM (23.976 кадров в секунду), приведенные к 29.97 с помощью
телесина (преобразования телекино). При проигрывании NTSC-фрагменты воспроизводятся с 29.97 кадров/сек, а
FILM-фрагменты с 23.976 кадров/сек. (Примечание Tom-а: Я полагаю, вам известно,
что FILM-фрагменты также проигрываются с 29.97 кадров/сек, но достигается это
дублированием некоторых полей с помощью телесина, переводящего 23.976 в 29.97).
Такое гибридное видео можно встретить во многих современных аниме и
телевизионных научно-фантастических сериалах, на дополнительных материалах
DVD-дисков, где интервью с создателями фильма (29.97) перемешаны с его
фрагментами (23.976).</p>

<div class=note>
От переводчика: что-то тут автор смутно выражается и примечание Tom-а совершенно
справедливо. Было бы уместнее писать не о "воспроизведении", а о том, как такое
гибридное видео хранится в MPEG-2 потоке. Ситуация более сложная и в таких
NTSC+FILM гибридах могут присутствовать фрагменты не двух, а трех типов:
<ul>
  <li>настоящие NTSC-фрагменты с 29.97 кадров/сек. Тут все просто, оригинал кодируется один-в-один.</li>
  <li>FILM-фрагменты, подвергнутые телесину <b>ДО</b> сжатия. Т.е. над материалом
проведена операция 2:3 pulldown, частота кадров изменена с 23.976 до 29.97, а потом уже видео сжато.
Это наиболее неприятный вариант, т.к. требуется применение "интеллектуальных"
фильтров типа связки Telecide+Decimate, чтобы выявить такие фрагменты и привести
их обратно к FILM-формату. Зачем существуют такие безобразия - не ясно. Единственное
объяснение - это попытка затруднить работу рипперам со стороны производителей
видео-продукции.</li>
  <li>FILM-фрагменты, сжатые со своими изначальными 23.976 без каких-либо манипуляций
с кадрами и полями, но имеющие в заголовках определенных кадров специальные флажки,
указывающие плееру, что те или иные поля нужно продублировать при воспроизведении.
Т.е. тот же самый 2:3 pulldown, но только выполняемый плеером "на лету" во время воспроизведения.</li>
</ul>

Разумеется, все три варианта проигрываются со скоростью 29.97 в том смысле, что
плеер именно с такой скоростью выдает кадры на выходе.
</div>


<h2><a name="recognize-vfr"></a>Как распознать VFR-материал (mkv/mp4)</h2>
<p>Существует несколько способов определить, что видео в контейнерах mkv/mp4 является VFR:</p>
<u>для mkv:</u> изучить файл с таймкодами кадров, полученный с помощью <a href="http://haali.cs.msu.ru/mkv/mkv2vfr.exe"> mkv2vfr</a>.
<p><u>для mp4:</u> используя mp4dump
(брать здесь: <a href="http://www.rarewares.org/mp4.html">MPEG4 tools by MPEG4ip
package</a>). В командной строке наберите
<pre>mp4dump -verbose=2 holly_xvid.mp4 &gt; log.txt</pre>
<p>Полученный лог-файл выглядит так (найдите атом stts, содержащий продолжительности кадров):</p>
<pre>type stts
       version = 0 (0x00)
       flags = 0 (0x000000)
       entryCount = 41 (0x00000029)
        sampleCount = 3 (0x00000003)
        sampleDelta = 1000 (0x000003e8)
        sampleCount[1] = 1 (0x00000001)
        sampleDelta[1] = 2000 (0x000007d0)
        sampleCount[2] = 3 (0x00000003)
        sampleDelta[2] = 1000 (0x000003e8)
        sampleCount[3] = 1 (0x00000001)
        sampleDelta[3] = 2000 (0x000007d0)
        sampleCount[4] = 3 (0x00000003)
        sampleDelta[4] = 1000 (0x000003e8)
        sampleCount[5] = 1 (0x00000001)
        sampleDelta[5] = 2000 (0x000007d0)
        etc ...</pre>
<p><i>sampleDelta</i> определяет как долго отображается кадр,
а <i>sampleCount</i> - сколько таких кадров.
Для приведенного примера получается так:<br>
воспроизводятся 3 кадра с продолжительностью 1000 каждый<br>
потом 1 кадр продолжительностью 2000<br>
потом 3 кадра продолжительностью 1000<br>
потом 1 кадр продолжительностью 2000<br>
и т.д. ...</p>
<p>Значения эти, разумеется, не в секундах, это некие "тики" (или отсчеты),
которые можно перевести в секунды, используя значение "timescale",
хранящееся в атоме timescale видеодорожки (убедитесь, что вы выбрали нужный
timescale, так как у каждой дорожки он свой собственный).

В лог-файле это выглядит так:</p>
<pre>type mdia
    type mdhd
     version = 0 (0x00)
     flags = 0 (0x000000)
     creationTime = 3197912378 (0xbe9c453a)
     modificationTime = 3197912378 (0xbe9c453a)
     timeScale = 24976 (0x00006190)
     duration = 208000 (0x00032c80)
     language = 21956 (0x55c4)
     reserved = &lt;2 bytes&gt; 00 00 </pre>

<p>В этом примере timeScale = 24976. Большинство кадров имеет продолжительность 1000.
1000/24976 = 0.04. Это означает, что каждый из первых трех кадров воспроизводится
в течение 0.04 секунды, что эквивалентно 23.976 кадров в секунду (1/23.976 = 0.04).
Следующий кадр продолжительностью 2000. 2000/24976 = 0.08 сек, т.е. 12.5 кадров в секунду (1/12.5 = 0.08). и т.д. ...</p>
<p>Приведенные логи взяты из реального гибридного видео-файла.</p>

<div class=note>
От переводчика: пример несколько неудачный. Во-первых, сразу видно, что
все вычисления изрядно округлены и, например, 1000/24976 вовсе не равно 1/23.976.
Было бы интереснее увидеть пример со стандартными частотами кадров 23.976 и 29.97, раз уж о
них идет речь в этой статье.

Для демонстрации подошли бы такие значения продолжительностей и timeScale:
<ul>
  <li>для 23.976: 5005/120000</li>
  <li>для 29.97: 4004/120000</li>
</ul>
(исходя из того, что 23.976=24000/1001, 29.97=30000/1001, но нужно иметь один
общий timeScale)
</div>



<h2><a name="enc-hybrid-mpeg2"></a>Загрузка гибридного видео (MPEG-2) в AviSynth и его кодирование</h2>

<P>Есть несколько способов закодировать гибридное видео.
Первый: сконвертировать все в видео с постоянной частотой кадров (CFR)
- либо 23.976, либо 29.97. Второй способ: кодировать с частотой кадров 120,
используя контейнер AVI с выпадением части кадров (dropped frames) во время
воспроизведения. И последний способ: создать полноценное VFR-видео в контейнере MKV (Матрёшка) или MP4.

<h3><a name="enc-cfr"></a>Кодировать как 23.976 или 29.97 ?</h3>

<p>Если выбрать частоту кадров 29.97, то NTSC-фрагменты будут играться отлично,
но FILM-фрагменты будут подергиваться при воспроизведении из-за дублирования
части кадров. И аналогично, при выборе FILM (23.976), получим корректное
воспроизведение FILM-фрагментов и подергивание NTSC-фрагментов (уже из-за
"выброшенных" в результате прореживания кадров). Помимо этого, при выборе
29.97 мы получим худшее качество картинки при том же финальном размере файла,
т.к. количество кадров увеличится на 25%.</p>

<p>В общем, сложный выбор. Можно посоветовать такой подход: если бОльшая часть
материала идет в FILM-формате (23.976) - выбирайте 23.976, и наоборот, если
преимущественно NTSC, то 29.97. Характер исходного материала также имеет значение. Например, если у вас
в кадре статичное видео с "говорящими головами", то его можно безболезненно
"проредить" с 29.97 до 23.976, не опасаясь визуально заметного подергивания
при воспроизведении. Когда вы создаете D2V-проект, вы видите в информационной
панели DGIndex, какой материал преобладает - FILM или NTSC. Однако, многие
гибридные материалы на самом деле закодированы целиком как NTSC,
с FILM-фрагментами, подвергнутыми предварительному телесину (т.е. добавленные
поля закодированы так же как и все остальные). В общем, тщательно изучите
свой материал, чтобы решить, что же с ним делать.</p>

<p>Плагин Decomb для AviSynth предоставляет два специальных режима прореживания
для наилучшей обработки гибридного материала.
Чтобы понять, как использовать Decomb, процитируем его документацию:</p>

<p><i>Преимущественно FILM-материал (mode=3)</i></p>

<p>Для начала рассмотрим случай, когда исходный материал преимущественно
FILM-формата. В этом случае мы хотим проредить FILM-фрагменты обычным образом,
сохранив плавность воспроизведения. Для NTSC-фрагментов частоту кадров будем
уменьшать "смешивающим" (blending) прореживанием, получая из каждых 5 кадров 4.
Полученные последовательности кадров будут воспроизводиться плавнее, чем
если бы мы просто прореживали их как FILM-фрагменты.</p>

<p>Типовой скрипт для такой операции:</p>

<pre>Telecide(order=0, guide=1)
Decimate(mode=3, threshold=1.0)</pre>

<p>Decimate обрабатывает FILM- и не-FILM фрагменты соответствующим образом
благодаря двум факторам. Первый: когда мы используем параметр guide=1 в
вызове Telecide, мы тем самым разрешаем ему передавать информацию в Decimate
о том, какие кадры получены из FILM-фрагментов, а какие нет. Чтобы этот
механизм работал, вызов Decimate должен следовать непосредственно после
Telecide. Очевидно, что чем лучше (путем подстройки параметров) Telecide
сможет распознать шаблоны, с помощью которых поля составлены в кадры, тем
лучше справится со своей задачей Decimate.</p>

<p>Второй фактор - это порог срабатывания (threshold). Если в последовательности
кадров, анализируемой фильтром, нет дублирующихся, то вся последовательность
считается NTSC-фрагментом. Порог определяет процент различия между кадрами,
допустимый для того, чтобы считать кадры дублирующимися. Примечание: порог=0
означает, что поиск дубликатов не выполняется совсем.</p>

<div class=note>От переводчика: здесь порог - это вовсе не проценты в общепринятом
смысле, а некая своя метрика. Чтобы подобрать для конкретного материала хороший
порог срабатывания, удобно на время добавить в вызов Decimate параметр show=true и
посмотреть визуально, как работает Decimate при разных порогах.</div>

<p>Не забывайте устанавливать правильный порядок полей для Telecide - для DVD
обычно order=1 (верхнее поле первое, TFF), а для захваченного видео обычно
order=0. В комплекте с Decomb идет DecombTutorial.html - там описано, как
определить порядок полей.</p>

<p>Есть еще один плагин для "обратного телесина" (IVTC, Inverse Telecine),
специально предназначенный для обработки гибридного материала, но без
смешивания кадров, как у Decomb в режиме mode=3. Это SmartDecimate.
Полученные в результате кадры будут "чистые", но при воспроизведении не
будет такой плавности, как при использовании Decomb. Типичный скрипт таков:
</p>

<pre>B = TDeint(mode=1) # или KernelBob(order=1)
SmartDecimate(24, 60, B)</pre>

<p>Чтобы по возможности сохранить плавность, перед SmartDecimate выполняется
деинтерлейс каким-либо "умным" BOB-алгоритмом.</p>




<p><i>Преимущественно NTSC-видео материал (mode=1)</i></p>

<p>Теперь рассмотрим случай, когда материал преимущественно в NTSC-формате.
Тут надо избежать прореживания кадров для NTSC-фрагментов, чтобы сохранить
плавность воспроизведения. Для FILM-фрагментов же надо сохранить частоту кадров
= 29.97, но заменить дублирующиеся кадры на кадры, в которых поля смешаны,
чтобы дубликаты были не столь заметны.</p>


<p>Типовой скрипт для такой операции:</p>

<pre>Telecide(order=0, guide=1)
Decimate(mode=1, threshold=1.0)</pre>

<p>Рекомендации абсолютно те же, что и для режима mode=3 (см. выше)</p>




<h3><a name="enc-120"></a>кодирование как 120 fps, используя AVI с "выброшенными" кадрами</h3>

<p>Это наиболее широко совместимый способ. Для этого вам необходимы <a href="http://bengal.missouri.edu/~kes25c/">TIVTC
and avi_tc</a>. Начните с создания a <a href="#create-vfr-mkv">прореженного
avi и timecodes.txt</a>, но пропустите мультиплексирование. Затем откройте закладку
tc2cfr программы tc-gui и добавьте ваши файлы или используйте следующую командную строку:</p>
<pre>tc2cfr 120000/1001 c:\video\video.avi c:\video\timecodes.txt c:\video\video-120.avi</pre>
<p>Затем муьтиплексируйте с вашим аудио. Это работает так как tc2cfr создает avi с выброшенными (drop) кадрами,
заполняя избыточное пространство выброшенными кадрами для создания плавного avi с частотой 120 кадров в секунду.</p>

<h4>Есть также старый способ кодирования в 120 fps</h4>
<p>Потребуются следующие утилиты</p>
<ul>
  <li>Avi60 and GUI</li>
  <li>Dec60.dll (для AviSynth 2.0x)</li>
  <li>FPSCheck</li>
  <li>AviSynth версии 2.0x (НЕ 2.5!)</li>
  <li>DecombLegacy.dll (для AviSynth 2.0x)</li>
  <li>DVD2AVI версии 1.76</li>
  <li>MPEG2DEC.dll (для AviSynth v2.0x; нужен для FPSChk.exe)</li>
</ul>

<p>Вся процедура отлично <a href="http://www.masteryoshidino.com/hentai/anime-encoding.htm">описана здесь</a>.
Там же можно скачать и все необходимые утилиты. Но так как процесс можно
несколько упростить, мы опишем его тут:</p>

<p>1) Создать индексный файл (idx):</p>
<p>Кладем DVD2AVI 1.76, MPEG2DEC.dll и FPSChk.exe в одну директорию,
иначе работать не будет. Запускаем FPSChk.exe. К сожалению, эта утилита на
японском языке, но последовательность действий такая: жмем ALT+F, потом O, чтобы
открыть файл. Открываем наш D2V-файл. Далее жмем ALT+A, потом S, чтобы
просканировать файл и найти в нем FILM- и NTSC-фрагменты. В статусной строке
побегут счетчики, так что наберемся терпения и подождем. По окончании сканирования
жмем ALT+F и затем W, чтобы сохранить индексный файл.</p>

<p>2) Кодируем как 30 кадров/сек с помощью dec60.dll:</p>

<p>Здесь можно использовать AviSynth v2.5 (но вам потребуется mpeg2dec.dll и
dvd2avi 1.76, стало быть потребуется LoadPluginEx.dll, чтобы загрузить плагины
от AviSynth версии v2.0x). Создайте следующий скрипт:</p>

<pre>LoadPlugin(&quot;LoadPluginEx.dll&quot;)
LoadPlugin(&quot;Dec60.dll&quot;)
LoadPlugin(&quot;mpeg2dec.dll&quot;)

Mpeg2Source(&quot;TNGsample.d2v&quot;)
Dec60(idxfile=&quot;TNGsample.idx&quot;, deint=false)</pre>

<p>Загрузите скрипт в VirtualDub и закодируйте в DivX/XviD как обычно.</p>

<p>3) Конвертируем полученный AVI с 29.97 кадров/сек в 119.88 кадров/сек:</p>

<p>Запустите AVI60GUI.exe. В нем три поля для ввода.
В верхнее вводим имя файла, полученного на предыдущем этапе.
Второе поле вводим имя файла, в котором будем сохранять модифицированный AVI-файл.
В нижнее поле вводим имя IDX-файла. После заполнения всех трех полей жмем Enter
и ждем. По окончании работы получаем плавно воспроизводящийя файл со 120 кадрами в секунду.
Теперь самое время смикшировать его со звуковой дорожкой.</p>

<p>Этот метод работает, т.к. хотя на самом деле видео воспроизводится с частотой
кадров = 119.88, но для разных фрагментов вставлено разное кол-во "выброшенных"
кадров и визуально все выглядит как 23.976 и 29.97 для соответствующих фрагментов.
Для 23.976 на каждый реальный кадр вставляется 4 "выброшенных", для 29.97 - 3.
При воспроизведении "выброшенные" кадры никак не влияют на картинку, они только
 "затягивают" время. В цифрах это выглядит так:
на 119.88 кадрах в сек один кадр отображается в течение 1/119.88 = 8.34 мс.
для фрагмента, который нужно воспроизводить с 23.976 имеем 1+4 кадров, т.е.
общее время вывода первого, реального кадра и четырех "выброшенных" =
8.34*5 = 41.7 мс, что и требуется. Аналогично и для 29.97.</p>

<p>Если вы откроете ваш AVI-файл в VirtualDub-е, то увидите, какие кадры
являются "выброшенными" (drop). Под изображением кадра будет, например, такая
информация: Frame 23 (0:00:00.192) [D] [43.91 kB]. Вот это [D] и означает,
что кадр "выброшен". Навигация только по выброшенным кадрам - клавишами { и }.
Физически "выброшенные" кадры на самом деле вовсе не выброшены, они есть
в AVI-контейнере, есть и в его индексе, но только имеют нулевой размер.




<h3><a name="create-vfr-mkv"></a>создание VFR-видео в контейнере MKV (matroska/матрёшка)</h3>

<p>Возьмите модифицированный плагин Decomb под названием
<a href="http://webpages.charter.net/falconx/decombvfrmod.html"> Decomb521VFR</a>,
который умеет сохранять файлы с таймкодами и статистикой, по которым можно
определить, какие кадры с какой частотой вопросизводятся.
Сделайте следующий скрипт:</p>

<pre>Mpeg2Source(&quot;TNGsample.d2v&quot;)
Decomb521VFR_Decimate(mode=4, threshold=1.0, progress=true, timecodes=&quot;timecodes.txt&quot;, vfrstats=&quot;video.vfrstats&quot;)
# за подробностями обратитесь к документации Decomb521VFR</pre>

<p>(Для создания файла с таймкодами можно также воспользоваться TDecimate
из <a href="http://bengal.missouri.edu/~kes25c/">пакета TIVTC от tritical</a>).</p>

<p>Откройте скрипт в VirtualDub-е и запустите на проигрывание. Будут созданы
файлы с таймкодами и статистикой. Теперь удалите вызов Decomb521 из скрипта,
останется только:</p>

<pre>Mpeg2Source(&quot;TNGsample.d2v&quot;)</pre>

<p>этот скрипт закодируйте в DivX/XviD (как 29.97 кадров в сек).</p>

<p>Запустите <a href="http://www.bunkus.org/videotools/mkvtoolnix/downloads.html"> mmg.exe,
который является графической оболочкой для mkvmerge</a>:
откройте в нем свои видео и аудио файлы (если необходимо, укажите задержку
для звука), файл с таймкодами timecodes.txt и запустите микширование.</p>
<p>Для воспроизведения полученного файла вам потребуется Matroska-сплиттер -
на выбор <a href="http://sourceforge.net/projects/guliverkli/"> этот (от Gabest)</a> или
<a href="http://haali.cs.msu.ru/mkv/"> этот (от Haali)</a>.</p>

<h3><a name="create-vfr-mp4"></a>создание VFR-видео в контейнере MP4</h3>

<p>Автоматически это сделать невозможно (используя файл с таймкодами).
Выход есть: закодировать множество файлов с фиксированной (но разной) частотой
 кадров и объеденить их в один MP4 с помощью mp4box с опцией -cat.</p>

<h3><a name="summary-methods"></a>подведем итоги по методам</h3>

<p>Суммируя все недостатки и достоинства вышеперечисленных методов, можно
сказать следующее: создание видео с фиксированной частотой кадров
23.976 или 29.97 удобно, если требуется дальнейшее редактирование в
AviSynth, VirtualDub и др., т.к. многие редакторы работают только с
CFR-материалом. Но такое видео может воспроизводиться с подергиваниями из-за
дублирующихся или выброшенных кадров. Кодирование со 120 кадрами/сек
опять же дает нам CFR, но зато отсутствие подергиваний при просмотре.
Однако, его создание требует некоторых усилий, да и некоторые из применяемых
программ имеют закрытые исходные тексты. Кодирование в MKV с переменной
частотой кадров (используя таймкоды) не имеет недостатков (за исключением того,
что файлы MKV не воспроизводятся бытовыми плеерами).</p>


<h3><a name="create-vfr-mp4-nvop"></a>Создание VFR-видео в контейнере MP4 с N-VOP-ами</h3>

<p><a href="http://forum.doom9.org/showthread.php?s=&amp;threadid=93263&amp;perpage=20&amp;pagenumber=2">Здесь</a>
вы узнаете, как сделать AVI-файл с N-VOP-ами,
а <a href="http://forum.doom9.org/showthread.php?s=&amp;threadid=73633">здесь</a> - как конвертировать AVI в MP4,
используя MP4box или 3ivx mp4 muxer чтобы получить настоящий VFR MP4
поток (N-VOP кадры выбрасываются). Чтобы проверить, что в вашем AVI есть N-VOP-ы, можно использовать GSpot
(кстати, видео с N-VOP-ами по-прежнему остается CFR).
Однако, данная процедура вовсе не гарантирует, что все дублирующиеся кадры
будут закодированы как N-VOP кадры (возможно потому, что необходимое для
этого сравнение кадров выполняется после кодирования, а не до ???).</p>




<h2><a name="reenc-vfr"></a>Загрузка гибридного видео (не MPEG-2) в AviSynth и его кодирование</h2>

<p>Есть способ открыть VFR-видео AviSynth-ом без потери синхронизации видео
и звука (используя DirectShowSource). Если ваше VFR-видео в контейнере MKV,
то еще один способ - сконвертировать его утилитой mkv2vfr в AVI с постоянной
частотой кадров и файл с таймкодами, потом обработать AVI и перевести обратно
в MKV, используя полученные таймкоды.</p>


<h3><a name="open-vfr-non_mpeg2"></a>загрузка не-AVI VFR-материала в AviSynth</h3>

<p>Открыть VFR-видео AviSynth-ом и сохранить синхронизацию со звуком возможно.
Один из способов - подсчитать среднюю частоту кадров (разделив общее количество
кадров на длительность в секундах) и задать полученное значение в вызове
DirectShowSource. Вот так:</p>
<pre>av_rate = ...
DirectShowSource(&quot;vfr.mp4&quot;, fps=av_rate, convertfps=true)</pre>

<p>В зависимости от продолжительности исходных кадров будет производиться
добавление или выкидывание кадров чтобы сохранить синхронизацию.</p>

<p>Перекодирование с частотой кадров 23.976 или 29.97:</p>
<pre>DirectShowSource(&quot;vfr_startrek.mkv&quot;, fps=29.97, convertfps=true) # или fps=23.976</pre>
<p>или</p>
<pre>DirectShowSource(&quot;vfr_startrek.mkv&quot;, fps=119.88, convertfps=true)
FDecimate(29.97) # или FDecimate(23.976)</pre>
<p>(Я не знаю, что в теории даст лучший результат). Для MP4 это тоже работает.</p>







<h3><a name="reenc-vfr-dss-non_mpeg2"></a>перекодирование 120 fps VFR-видео</h3>

<p>Самай простой способ преобразовать vfr источники обратно в vfr в AviSynth - это использование
<a href="http://akuvian.org/src/avisynth/dedup">DeDup</a>:</p>
<p>1-й проход:</p>
<pre>DupMC(log=&quot;stats.txt&quot;)</pre>
<p>2-й проход:</p>
<pre>DeDup(threshold=.1,maxcopies=4,maxdrops=4,dec=true,log=&quot;stats.txt&quot;,times=&quot;timecodes.txt&quot;)</pre>
<p>TIVTC также может дедать это:</p>
<p>1-й проход:</p>
<pre>TFM(mode=0,pp=0)
TDecimate(mode=4,output=&quot;stats.txt&quot;)</pre>
<p>2-й проход:</p>
<pre>TFM(mode=0,pp=0)
TDecimate(mode=6,hybrid=2,input=&quot;stats.txt&quot;,mkvout=&quot;timecodes.txt&quot;)</pre>
<p>Как только вы закодировали ваш файл, мультиплексируйте обратно в mkv или 120 fps avi.</p>
<p>Это будет убирать все дублированные кадры вставленнные directshowsource,
в то же время удерживая количество кадров и времена почти идентичными. Но не используйте
файл временных кодов от входного видео, используйте новый. Они могут быть не идентичными.
(Конечно вы пожете поиграться с параметрами если хотите использовать большую функциональность dedup.)</p>

<h4>Есть также другие более старые способы</h4>
<p>Нижеприведенная методика основана на описании, данном HeadlessCow в
<a href="http://forum.doom9.org/showthread.php?s=&amp;threadid=68562">этой ветке форума</a>.</p>

<p>0) Берем <a href="http://www.matroska.org/downloads/windows.html">vfrtools</a>,
инсталлируем <a href="http://www.java.com/en/download/help/5000010300.xml">Java VM</a>.</p>
<p>1) Берем фильтр <a href="http://neuron2.net/multidecimate/multidecimate.html">MultiDecimate</a>
и создаем AVS-скрипт для файла, который будем кодировать. Убедитесь, что все
ненужные кадры обрезаны <b>ДО</b> вызова MultiDecimate в скрипте.
В итоге должен получиться скрипт, похожий на этот (никакие фильтры обработки видео здесь пока не нужны):</p>
<pre>DirectShowSource(&quot;vfr_startrek.mkv&quot;, fps=119.88, convertfps=true) # или AviSource для AVI со 120 кадр/сек
ConvertToYUY2() # для MultiDecimate нужен YUY2
MultiDecimate(pass=1)</pre>
<p>2) Теперь загружаем скрипт в VirtualDub и запускаем его проигрывание
(один раз, при этом никакие перемещения по тайм-лайну делать НЕЛЬЗЯ!
Открыли скрипт и сразу запустили), затем закрываем VirtualDub.
Теперь у нас есть файл mfile.txt в той же директории, где и AVS-скрипт.
Выглядит он так:</p>
<pre>0 0.000000
1 0.000000
2 0.000000
3 0.000000
4 0.004137
5 0.000000
...</pre>
<p>Каждая строка содержит номер кадра и степень его отличия от предыдущего кадра.</p>
<p>3) Сейчас потребуется vfrtools.jar. Но сначала убедитесь, что у вас
установлена Java VM. Из командной строки запускаем vfrtools.jar с двумя
аргументами: файлом mfile.txt и исходной частотой кадров, вероятно = 119.88
(поместите vfrtools.jar в ту же директорию, что и ваш AviSynth-скрипт и
mfile.txt).</p>
<pre>java -jar vfrtools.jar mfile.txt 119.88</pre>
<p>В вашей директории будут сгенерированы два файла. Первый - dlist.txt,
необходимый для MultiDecimate во время второго прохода:</p>
<pre>3 2 1 4550 970
0 0
1 4
2 8
3 12
4 16
5 20
...</pre>
<p>В первой строке значения смысла не имеют, за исключением числа кадров.
Первые три значения просто выбраны так, чтобы быть "безопасными"
(в смысле, что с ними ничего не рушится, не виснет и не глючит).</p>

<p>Второй файл - timecodes.txt в формате, необходимом для mkvmerge:</p>
<pre># timecode format v1
Assume 119.88
0,297,29.97
298,968,23.976
969,969,39.96</pre>
<p>Предполагаемая частота кадров выставлена равной исходной, это ничего.
Все кадры разделены на интервалы, для каждого из которых установлена
своя частота кадров.<br>
<br>
4) Измените режим работы MultiDecimate на &quot;второй проход&quot; (pass=2)
и закодируйте видео. Ваш AVS-скрипт должен выглядеть примерно так
(теперь в конец скрипта можно добавить любые другие фильтры,
которые потребуются).</p>
<pre>DirectShowSource(&quot;vfr_startrek.mkv&quot;, fps=119.88, convertfps=true) # or use AviSource for 120 fps avi
ConvertToYUY2()
MultiDecimate(pass=2)</pre>
<p>Результат будет иметь несуразную чатсоту кадров, но это не важно,
мы это исправим во время соединения видео и звука.<br>
<br>
5) Соедините видео и звук с помощью mkvmerge. Только убедитесь,
что для видео используется файл timecodes.txt и версия mkvmerge достаточно
свежая и поддерживает эту функцию (см. параметр командной строки
--timecodes для mkvmerge).</p>

<p>Запустите <a href="http://www.bunkus.org/videotools/mkvtoolnix/downloads.html"> mmg.exe,
являющийся оболочкой mkvmerge</a>: загрузите видео и звуковый файлы (при необходимости
установите задержку для звука), загрузите файл timecodes.txt. После этого
запускайте микширование.</p>

<p>Для воспроизведения полученного файла потребуется Matroska splitter,
который можно скачать <a href="http://sourceforge.net/projects/guliverkli/"> здесь (от Gabest-а)</a> или
<a href="http://haali.cs.msu.ru/mkv/"> здесь (от Haali)</a>.</p>

<p>(Можно вместо MultiDecimate попробовать <a href="http://students.washington.edu/lorenm/src/avisynth/dedup/dedup.txt">DeDup</a>.
Вроде бы он и для YV12 подходит).</p>




<h3><a name="open-vfr-avi"></a>Пребразование vfr в cfr avi для AviSynth</h3>
<p>Вы можете избежать анализирования и прореживания с использванием специальных средств, чтобы получить минимальное
cfr avi для подачи в avisynth. После обработки и пере-кодировки, примените tc2cfr
или mmg к выходу с оригинальными временными кодами чтобы восстановить  vfr и полную синхронизацию.
(До тех пор, пока вы не удаляете/добавляете кадры,
вы можете использовать все тот же файл с таймкодами. Если кол-во кадров
изменилось, то прийдется править файл с таймкодами ручками,
хотя dedup имеет параметр timesin.)</p>
<p><i>avi</i></p>
<p><a href="http://bengal.missouri.edu/~kes25c/">avi_tc</a> будет создавать временной код
и нормальное видео, если avi использует выброшенные кадры и не n-vops или полностью закодированные кадры.
Она также требует, чабы не присутствовало аудио или вторая дорожка. Чтобы использовать, откройте tc-gui
и добавьте ваш файл, или используйте следующую командную строку:</p>
<pre>cfr2tc c:\video\video-120.avi c:\video\video.avi c:\video\timecodes.txt 1</pre>
<p><i>mkv</i></p>
<p><a href="http://haali.cs.msu.ru/mkv/mkv2vfr.exe">mkv2vfr</a>
извлекает из Матрёшки все кадры в AVI-файл с постоянной частотой кадров
и создает дополнительно файл с таймкодами. Это работает только если
mkv - в режиме vfw.
mkv2vfr работает из командной строки. Вот так:</p>
<pre>mkv2vfr.exe input.mkv output.avi timecodes.txt</pre>



<h3><a name="reenc-mkv2vfr"></a>кодирование VFR-видео в MPEG-2</h3>
<p>См. <a href="http://forum.doom9.org/showthread.php?t=93691">эту ветку форума</a> на Doom9.</p>
<p>Пока нет никаких комментариев по этому поводу.</p>




<h2><a name="audio-sync"></a>Синхронизация со звуком</h2>

<p>После рассмотрения всех методов кодирования гибридного видео (как 23.976,
29.97 или VFR) возникает вопрос: почему независимо от выбранного метода звук
все равно остается синхронизированным с видео? До кодирования видео и звук
имеют равную продолжительность и синхронизированы. Во время кодирования
возможны два варианта:</p>

<ul>
  <li>Вы изменяете частоту кадров вашего видео-потока, ускоряя или замедляя его
      (как это обычно происходит при конвертации PAL-FILM). Это предполагает
      изменение продоложительности видео-потока и, стало быть, должна возникать
      рассинхронизация видео и звука.</li>

  <li>Вы изменяете частоту кадров видео-потока, добавляя или удаляя отдельные кадры.
  Продолжительность видео не изменяется, следовательно, и синхронизация не нарушается.</li>
</ul>

<p>Если вы кодируете видео-поток с частотой кадров 23.976 или 29.97 (в обоих случаях - CFR),
используя Decimate(mode=3, threshold=1.0) или Decimate(mode=1, threshold=1.0),
происходит дублирование/выбрасывание отдельных кадров и, в итоге, синхронизация
видео и звука сохраняется.</p>

<p>И, наконец, предположим, что вы открываете свое VFR-видео в AVISynth с помощью
DirectShowSource. Сравним:</p>

<pre>DirectShowSource(&quot;F:\Guides\Hybrid\vfr_startrek.mkv&quot;, fps=29.97) # or fps=23.976</pre>
<p>и</p>
<pre>DirectShowSource(&quot;F:\Guides\Hybrid\vfr_startrek.mkv&quot;, fps=29.97, convertfps=true) # or fps=23.976</pre>

<p>В первом случае синхронизация будет нарушена, т.к. видео ускорено (или замедлено).
Во втором - все синхронно, т.к. для конвертации в CFR некоторые кадры будут продублированы
или выброшены</p>



<h2><a name="references"></a>Ссылки</h2>
<P>Для обязательного прочтения: <a href="http://www.doom9.org/ivtc-tut.htm"> Force Film, IVTC, and Deinterlacing and more</a>.<br>
Создание <a href="http://www.masteryoshidino.com/hentai/anime-encoding.htm"> видео со 120 кадрами/сек</a>.<br>
Документация к <a href="http://webpages.charter.net/falconx/decombvfrmod.html">Decomb521VFR</a>.<br>
Про модификацию <a href="http://forum.doom9.org/showthread.php?s=&amp;threadid=80673"> Decomb521VFR1.0</a> для автоматизации создания Matroska VFR.<br>
<a href="http://forum.doom9.org/showthread.php?t=73819">Mkvextract GUI</a> от DarkDudae.

<p><b><u>To Do:</u></b></p>
<ul>
  <li><a href="http://forums.animesuki.com/showthread.php?t=34738">http://forums.animesuki.com/showthread.php?t=34738</a>
 <a href="http://forum.doom9.org/showthread.php?t=112199">http://forum.doom9.org/showthread.php?t=112199</a>
    tc2mp4, subs/Aegisub and ffmpegsource for timecode file.</li>
  <li>download <a href="http://fcchandler.home.comcast.net/WMVTIMES.exe" target="_blank">WMVTIMES.exe</a>.</li>
  <li>subs also: <a href="http://forum.doom9.org/showthread.php?t=135889&amp;page=2"> http://forum.doom9.org/showthread.php?t=135889&amp;page=2</a>.</li>
  <li>how to determine whether a video (MP4) is vfr or not?: <a href="http://forum.doom9.org/showthread.php?t=137899"> http://forum.doom9.org/showthread.php?t=137899</a>.</li>
  <li><font color="#FF0000">Wilbert: I don't understand the comment about DeDup in
&quot;encoding
to vfr (mkv)&quot;: need to investigate.</font>
  </li>
</ul>

<P><i>Помимо всех тех людей, которые участвовали в создании инструментов,
упомянутых в этом руководстве, автор (Wilbert) хотел бы поблагодарить
bond, manono, tritical and foxyshadis за ценные замечания и предложения.</i>


<p><kbd>$English Date: 2008/07/11 18:23:00 $<br>
Русский перевод 20.07.2005 Рыба-кит<br>
Обновления (не совсем закончены) 01.07.2007 Fizick</kbd></p>


<FORM><INPUT TYPE="Button" VALUE="Back"
onClick="history.go(-1)"></FORM>

</BODY>
</HTML>
