<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html lang="ru">
<head>
  <meta http-equiv="Content-Language" content="ru">
  <meta content="text/html;charset=windows-1251" http-equiv="Content-Type">
  <title>Resize Avisynth Filters</title>
  <link rel="stylesheet" type="text/css" href="../../avisynth.css">
<!-- Automatically generated, don't change:
$Id: resize.htm,v 1.10 2008/12/14 15:29:07 fizick Exp $
-->
</head>

<body>
<h2>BicubicResize / BilinearResize / BlackmanResize / GaussResize / LanczosResize /
Lanczos4Resize / PointResize / Spline16Resize / Spline36Resize / Spline64Resize</h2>

<p>Фильтры группы Resize (изменение размеров кадра, масштабирование, ресайз)</p>

<p><code>BicubicResize </code>(<var>clip, int target_width, int target_height, float
  &quot;b&quot;, float &quot;c&quot;, float &quot;src_left&quot;, float &quot;src_top&quot;,
  float &quot;src_width&quot;, float &quot;src_height&quot;</var>)<br>
  <code>BilinearResize </code>(<var>clip, int target_width, int target_height, float
  &quot;src_left&quot;, float &quot;src_top&quot;, float &quot;src_width&quot;,
  float &quot;src_height&quot;</var>)<br>
  <code>BlackmanResize </code>(<var>clip, int target_width, int target_height, float
  "src_left", float "src_top", float "src_width", float "src_height", int &quot;taps&quot;</var>)<br>
  <code>GaussResize </code>(<var>clip, int target_width, int target_height, float
  "src_left", float "src_top", float "src_width", float "src_height", float &quot;p&quot;</var>)<br>
  <code>LanczosResize </code>(<var>clip, int target_width, int target_height, float
  "src_left", float "src_top", float "src_width", float "src_height", int &quot;taps&quot;</var>)<br>
  <code>Lanczos4Resize </code>(<var>clip, int target_width, int target_height, float
  "src_left", float "src_top", float "src_width", float "src_height"</var>)<br>
   <code>PointResize </code>(<var>clip, int target_width, int target_height, float "src_left",
  float "src_top", float "src_width", float "src_height"</var>)<br>
  <code>Spline16Resize </code>(<var>clip, int target_width, int target_height, float
  "src_left", float "src_top", float "src_width", float "src_height"</var>)<br>
  <code>Spline36Resize </code>(<var>clip, int target_width, int target_height, float
  "src_left", float "src_top", float "src_width", float "src_height"</var>)<br>
  <code>Spline64Resize </code>(<var>clip, int target_width, int target_height, float
  "src_left", float "src_top", float "src_width", float "src_height"</var>)
</p>
<p>С <em>v2.56</em> вы можете использовать смещения (как в <a href="crop.htm">Crop</a>) для всех этих функций:</p>
<p>
<code>GaussResize </code>(<var>clip, int target_width, int target_height, float
  "src_left", float "src_top", float -&quot;src_right&quot;, float
-&quot;src_top&quot;</var>)</p>

<p>Для всех функций изменения размера можно использовать приведенный расширенный
синтаксис, который позволяет обрезать кадр до выполнения собственно
изменения размера (масштабирования). Если поставить функцию обрезки Crop до
функции Resize, будут выполняться абсолютно те же операции, хотя может
быть заметна небольшая разница в скорости их выполнения.<br>
</p>

<pre>Crop(10,10,200,300).BilinearResize(100,150)
# тоже самое что
BilinearResize(100,150,10,10,200,300)</pre>

<p>Это важно: Изменения размеров кадра по горизонтали и вертикали - это
2 отдельные независимые друг от друга операции. Если входной размер по
одной из координатных осей такой же как и выходной, то соответственно
операция по изменению размера по этой оси пропустится.<br>
Какая операция, горизонтальная или вертикальная, будет вызываться
первой, определяется наименьшей пропорцией по уменьшению кадра. Это
сделано для того, чтобы сохранить максимальное качество картинки.
Таким образом на вход 2-й операции по изменению размера кадра подается
картинка наилучшего качества.</p>

<h3>BilinearResize</h3>

<p>Фильтр <code>BilinearResize</code> перемасштабирует входной
видео кадр к произвольному новому разрешению. Если добавить
дополнительные параметры <var>source</var>, то результат будет такой
же как, если поставить <code><a href="crop.htm">Crop</a></code> с
этими же пареметрами до <code>BilinearResize</code> (только чуть
быстрее). </p>

<p><code>BilinearResize</code>
использует стандартный билинейный фильтр
и почти тождественен опции программы VirtualDub для изменения размера
кадра "точное билинейное" ("precise bilinear"). Слово "почти"
используется потому, что в VirtualDub этот фильтр не совсем правильно
масштабирует картинку. А именно так, что пиксели вверху и справа либо
повторяются либо обрезаются. (Это заметно только, если кадр увеличить в
2 или более раз. Иначе это настолько незаметно, что об этом даже не
стоит упоминать).  Отметим, однако, что Avery Lee утверждает,
что смотря на код и сравнивая результаты,  VirtualDub 1.6 и
AviSynth 2.5 генерируют одинаковые отображения.</p>

<pre>Примеры:
# Загрузить видео файл и изменить размер на 240x180 (из любого предыдущего размера)
AVISource("video.avi").BilinearResize(240,180)

# Загрузить 720x480 (CCIR601) видео и изменить его на 352x240 (VCD),
# при этом сохраняя соотношения размеров сторон исходника
AVISource("dv.avi").BilinearResize(352,240,8,0,704,480)

# или что то же самое
AviSource(&quot;dv.avi&quot;).BilinearResize(352, 240, 8, 0, -8, -0)

# Вырезать квадрант из право-верхнего угла видео 320x240 и зумировать его так,
# чтобы он заполнил весь кадр
BilinearResize(320,240,160,0,160,120)
</pre>

<h3>BicubicResize
</h3>

<p><tt><code>BicubicResize</code></tt> похож на  <tt><code>BilinearResize</code></tt>,
за исключением того, что вместо линейного используется двухпараметрический кубический
фильтр Митчела-Нетравали (Mitchell-Netravali two-part
cubic). <br>
Параметры <i>b</i> и <i>c</i> используются, чтобы править свойства
кубического фильтра, они иногда соотносятся с терминами размытие (blurring) и
осцилляции (волны, звон, ringing) соответственно.</p>

<p>Если <i>b</i> = 0 и <i>c</i> = 0.75, то фильтр ведет себя также
как и фильтр "точный бикубический" ("precise bicubic") из VirtualDub за
исключением тех же самых проблем VirtualDub, которые были упомянуты
выше. По умолчанию <i>b</i> = 1/3 и <i>c</i> = 1/3. Эти значения
рекомендовали Митчел и Нетравали, так как они дают наиболее субъективно
приемлемые результаты. Более высокие значения дают интересные
поп-арт эффекты. Попробуйте, например,  значения <i>b</i> = 0 и <i>c</i>
= -5. </p>

<p>Увеличивая размер видео, вы достигните лучших результатов с <tt><code>BicubicResize</code></tt>
чем с <tt><code>BilinearResize</code></tt>. Если же Вы уменьшаете
видео, результат использования  <tt><code>BilinearResize</code></tt>
может быть также хорош, если даже не лучше. Не смотря на то, что
бикубический фильтр VirtualDub даёт лучшие результаты чем его же
билинейный фильтр, надо отметить, что это происходит не потому, что
бикубический фильтр выполняет преобразование качественнее, а потому,
что он увеличивает резкость. На резкие картинки приятно любоваться до
тех пор пока их не сжимают. Как только их начинают сжимать, на них уже
противно смотреть. <tt><code>BicubicResize</code></tt> по умолчанию
делает картинку не резче, чем его побратим из VirtualDub-а, но резче
чем BilinearResize. Если планируется закодировать видео с низкой
скоростью потока (bitrate), то будет не удивительно, если
BilinearResize даст лучший конечный результат.</p>

<p>Для достижения математически точной и правильной работы фильтра
нужно установить такие b и c, которые удовлетворяют соотношению:
<pre>b + 2 * c = 1</pre>
Тогда получаем максимальное значение c = 0.5, когда b = 0 , что
представляет из себя метод криволинейной интерполяции - сплайн
Катмула-Рома (Catmull-Rom spline). Что является хорошим предложением
для резкости. </p>

<p>Начиная с c&gt;0.6 то фильтр начинает "звенеть" ("ring"). Это не настоящая
резкость, а подчеркивание контуров (crispening), как при регулировке резкости
в телевизоре.<br>
Отрицательные значения недопустимы для b, используйте b = 0 для величин c &gt; 0.5. </p>

<h3>BlackmanResize</h3>

<p><code>BlackmanResize</code> является модификацией <code>LanczosResize</code>
  которая имеет лучший контроль волновых артефактов для большого количества точек интерполяции (taps). Смотрите
  <code>LanczosResize</code> для объяснения аргумента taps (по умолчанию:
  taps=4). (добавлено в <em>v2.58</em>) </p>

<h3>GaussResize</h3>

<p>Использует для изменения размеров кривые Гаусса, имеет регулируемый
параметр резкости '<var>p</var>' (по умолчанию 30).  <var>p</var>
может изменяться от 1 до 100, где 1 дает слишком размытую картинку,
тогда как 100 - очень резкую.
<code>GaussResize</code> использует 4 опорные точки, и по скорости примерно такой же, что и <code>Lanczos4Resize</code>.
(добавлен в версии <em>2.56</em>)</p>

<h3>LanczosResize / Lanczos4Resize
</h3>

<p><tt><code>LanczosResize</code></tt> (предложил Ланкзос) - это альтернатива <tt><code>BicubicResize</code></tt>
с большим значением параметра <var>c</var>, около 0.6 ... 0.75, которое дает достаточно
сильную резкость.<br>
Это обычно даёт лучшее качество (меньше побочных эффектов) и резкую
картинку.</p>

<p><code>Lanczos4Resize</code> (добавлен с версии <em>2.55</em>) тесно
связан с <code>LanczosResize</code> (правильное имя которого должно было бы быть
Lanczos3Resize).
Последний использует 2*3=6 долей (lobes), а первый 2*4=8 долей для
изменения размера кадра. В результате
<code>Lanczos4Resize</code> дает более резкую картинку. Особенно хорошо
применять его для увеличения клипа.</p>
<p>Lanczos4Resize - это короткое имя функции LanczosResize(taps=4).</p>
<p><b>Замечание: входной аргумент названный taps должен реально быть lobes (в действительности
это половина числа lobes). При обсуждении ресайзеров, taps имеет другой смысл, как описывается ниже.</b></p>

<h4>Количество опорных точек интерполяции
(параметр taps)
</h4>

<p>Пусть Taps=4.
"Для повышения разрешения отсчетов (upsampling) (увеличения изображения),
размер фильтра подбирается
так, что его уравнение охватывает (falls across) 4 входных отсчета,
делая его фильтром с 4-мя опорными точками (отводами, taps). Эти 4
опорные
точки остаются независимо от размера получающегося выходного кадра. Для
понижения разрешения отсчетов (downsampling) (уменьшения изображения),
фильтр подбирается так, что его
уравнение охватывает 4 *выходных* отсчета, которые, естественно,
расположены
дальше друг от друга, чем входные. Итак, при понижении разрешения
отсчетов вдвое
(изменении размера на вдвое меньший), фильтр покроет 2*4=8 входящих
отсчета, соответственно используя 8 опорных точек. Для 3-х кратного
уменьшения понадобится 3*4=12 опорных точек, и т.д.
</p>

<p>Таким образом, общее количество опорных точек (taps), необходимое
при понижении разрешения отсчетов (уменьшении), равно коэффициенту
уменьшения,
умноженному на количество долей (lobes) (например, при уменьшении в <b>T</b>
раз и применении Lanczos<b>k</b>Resize количество опорных точек равно
T*2*k). И фактически это значение следует округлить до следующего
четного целого. При увеличении разрешения всегда будет k опорные точки."
Источник:
[<a href="http://archive2.avsforum.com/avs-vb/showthread.php?s=&amp;postid=4760581#post4760581">avsforum
post</a>].</p>

<p>Lanczos4Resize  - это короткое обозначение для
LanczosResize(taps=4).</p>

<h3>PointResize
</h3>

<p><tt><code>PointResize</code></tt> самый простой из возможных
фильтров для изменения размеров. Он использует выборку (отсчеты) по точкам (Point
Sampler), иначе называемую алгоритмом ближайшего соседа (Nearest Neighbour), что
обычно дает картинку с сильно выраженными квадратиками (блоками). Обычно этот
фильтр можно использовать только тогда, когда Вы намерены получить
картинку с заведомо худшим качеством, или, если необходимы четкие пикселизированные рисунки (clear
pixel drawings).<br>
Очень удобен для увеличения маленьких площадей для их внимательного анализа. </p>

<h3>Spline16Resize/Spline36Resize/Spline64Resize</h3>
<p>Три основанных на сплайнах ресайзера (добавлены в <em>v2.56/v2.58</em>).
Целесообразность сплайнов - быть резкими насколько возможно с меньшими волновыми артефактами чем
производит <code>LanczosResize</code>. <code>Spline16Resize</code> использует
sqrt(16)=4 опорные точки, <code>Spline36Resize</code> использует 6 опорных точек, и т.д.
... Чем больше опорных точек использовано, тем резче будет ваш клип. Сравнение
некоторых ресайзеров приведено
<a href="http://web.archive.org/web/20060827184031/http://www.path.unimelb.edu.au/~dersch/interpolator/interpolator.html">
<cite>там</cite></a>.</p>
<p>На сегодня, авторы AviSynth не знают, как получены коэффициенты сплайновых ресайзеров.
Если вы в курсе, пожалуйста дайте нам знать.</p>

<p><b>Изменения:</b></p>

<table border="1">

<tbody>
<tr>
<td>v2.55</td>
<td>добавлен Lanczos4Resize</td>
</tr>
<tr>
<td>v2.56</td>
<td>добавлены  Spline16Resize, Spline36Resize, GaussResize и
параметр taps в LanczosResize; добавлены смещения в Crop части xxxResize</td>
</tr>
    <tr>
      <td>v2.58</td>
      <td>добавлены BlackmanResize, Spline64Resize</td>
    </tr>
</tbody>
</table>

<p><kbd>$English Date: 2008/06/22 17:53:40 $<br>
Русский перевод 27.05.2005 venometal <br>
совместно с Turyst04 <a href="mailto:Turyst04@nextmail.ru">Turyst04@nextmail.ru</a><br>
Отредактирован и обновлен 28.08.2005-22.06.2008 Fizick</kbd></p>

<form> <input value="Back" onclick="history.go(-1)" type="button">
</form>

</body></html>