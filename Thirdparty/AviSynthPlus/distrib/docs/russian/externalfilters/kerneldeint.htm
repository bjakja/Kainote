<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html lang="ru">
<head>
<title>KernelDeint</title>
  <meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<link rel="stylesheet" type="text/css" href="../../avisynth.css">
<!--
Automatically generated, don't change:
$Id: kerneldeint.htm,v 1.2 2006/12/13 21:01:40 fizick Exp $
-->
</head>
<body>
<h1>KernelDeint</h1>
<h2>Общая информация</h2>
<b>Автор:</b> Donald A. Graft
<br><b>Версия:</b>    1.4.0<br>
<b>Загрузка:</b> <a href="http://neuron2.net/mine.html">http://neuron2.net/mine.html</a>
<br><b>Категория:</b>  деинтерлейс и устранение pulldown
<br><b>Требования:</b>  цветовые пространства YV12 &amp; YUY2 &amp; RGB

<hr size=2 width="100%" align=center>

<h3>Введение</h3>
<p>Этот фильтр делает деинтерлейс (удаление чересстрочности), используя ядерный
(матричный взвешенный, kernel) подход. Это дает значительно улучшенное
вертикальное разрешение в деинтерлейсных областях по сравнению с простым
отбрасыванием поля.
<p>Если вы устанавливаете порог фильтра в 0, вы получите результат, совершенно
свободный от артефактов, но при этом с меньшей потерей вертикального
разрешения, чем простое отбрасывание одного поля. Для дальнейшего улучшения
результата установите некоторый порог фильтра, определяющий величину движения:
если движение меньше порога, то область считается статической и не
обрабатывается (при этом сохраняется полное вертикальное разрешение), а в
движущихся областях применяется матричная (kernel-based) интерполяция, что
позволяет сохранить более высокое вертикальное разрешение, чем отбрасывание
одного поля с последующей обычной интерполяцией.</p>
<p>Фильтр работает в цветовых пространствах RGB, YUY2 или YV12.</p>
<p>Чтобы применять фильтр для постобработки после Telecide(),
используйте следующий скрипт:
<pre>
Telecide(..., post=1, hints=true)
KernelDeint(...)
</pre>
<p><i>Примечание перев.: в настоящее время существует  усовершенствованная (MMX-оптимизированная) версия этого
фильтра (от Leak) под названием <code><a href="leakkerneldeint.htm">LeakKernelDeint</a></code>.
Рекомендуется пользоваться именно ей.</i></p>

<hr size="2" width="100%" align="center">
<h3>Синтаксис</h3>
<p>KernelDeint() имеет следующие именованные параметры:</p>
<p><var>order</var> (0-1, по умолчанию не задан!)
Этот параметр определяет порядок полей в клипе. Чрезвычайно важно задать его
правильно. Используйте <var>order=0</var> для задания нижнего поля первым (bff),
<var>order=1</var> для верхнего поля первым (tff). Параметр необходим, при его
отсутствии фильтр возвращает ошибку. Так как этот параметр имеет ключевое
значение, рекомендуется не делать предположений о порядке полей, а определить
его явным образом, используя следующую методику:</p>
<p>Создайте скрипт AVISynth, выдающий входной файл без всякой обработки.
Например, если это AVI файл, то используйте AviSource <i>(прим.перев.: или
лучше OpenDMLSource)</i> Добавьте строку, разделяющую поля в предположении
верхнего поля первым:
<pre>
AviSource(&quot;your_clip.avi&quot;)
AssumeTFF().SeparateFields()</pre>
<p>Загрузите этот скрипт в VirtualDub, отыщите сюжет с движением и
просматривайте его покадрово. Если движение происходит всегда в правильном
направлении, то всё в порядке и наше предположение о верхнем поле первом было
справедливо. Если движение дёрганное ("шаг назад, три шага вперед, шаг назад,
три вперед..."), то попробуйте поменять AssumeTFF на AssumeBFF, если после
этого всё встанет на свои места, то видео имеет нижнее поле первое.
<i>(прим.перев.: картинка при такой проверке может немного дрожать по
вертикали, это  нормально. нужно искать горизонтальное движение и смотреть по
нему. Кроме того, есть и более автоматизированные способы определения порядка
полей, например, скрипт <a href="checkparity.htm"><code>CheckTopFirst</code></a>)</i></p>
<p><var>threshold</var> (0-255, по умолчанию 10)
Этот параметр определяет порог движения. Движущиеся области подвергаются
деинтерлейсингу с применением матричного подхода, статические оставляются без
изменений. Используйте параметр <var>map</var> для тонкой настройки порога:
только области с "гребёнкой" должны деинтерлейситься.</p>
<p><var>sharp</var> (true/false, по умолчанию false)
Установка этого параметра в true задаёт ядро интерполяции, которое
обеспечивает более высокое вертикальное разрешение, но при этом поднимает
резкость изображения (sharpen), что может давать некоторые артефакты на
контрастных деталях.</p>
<p><var>twoway</var> (true/false, по умолчанию false)
Установка в true этого параметра задаёт ядро, включающее и предыдущее, и
последующее поле для интерполяции. В противном случае используется только
предыдущее поле, что даёт более чёткую картинку и меньше смешивает кадры (что
положительно сказывается на anime), а также быстрее. Параметр <i>twoway</i>
включён для совместимости с предыдущими версиями, где подразумевалось
использование двух полей.</p>
<p><var>map</var> (true/false, по умолчанию false)
Установка <var>map=true</var> включает режим показа движущихся областей,
определяемых параметром <var>threshold</var>. Используйте для настройки порога
определения движения.
<p><var>debug</var> (true/false, по умолчанию false)
Включает вывод отладочной информации для DebugView.
В нынешней версии информация заключается в номере версии и "подсказках" (hints) от
фильтра Telecide() о том, является кадр прогрессивным или чересстройным.
Если подсказки отсутствуют, все кадры считаются чересстрочными.
<p>&nbsp;
<hr size="2" width="100%" align="center">
<p>Copyright © 2003, Donald A. Graft, All Rights Reserved.</p>
<p>Чтобы узнать об обновлениях и других фильтрах и утилитах, посетите мой сайт:<br>
<a href="http://neuron2.net/" target="_top">http://neuron2.net/</a></p>
<p><kbd>$English Date: 2004/08/13 21:57:25 $<br>
Русский перевод 25.06.2005 Eugene Vasiliev (eugvas<span>&#64;</span>mccme.ru)</kbd></p>
</body>
</html>
