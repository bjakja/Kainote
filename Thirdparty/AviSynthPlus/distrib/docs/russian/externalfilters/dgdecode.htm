<html lang="ru">
<head>
<meta content="text/html;charset=windows-1251" http-equiv="Content-Type">
<title>DGDecode</title>
<link rel="stylesheet" type="text/css" href="../../avisynth.css">
<!--
Automatically generated, don't change:
$Id: dgdecode.htm,v 1.7 2007/09/22 22:06:10 fizick Exp $
-->
</head>
<body>
<h1>DGDecode</h1>
<h2>Общая информация</h2>
<b>авторы:</b>  MarcFD, Nic, trbarry, Sh0dan, Graft и другие
<br><b>версия:</b>   1.4.7<br>
<b>категория:</b> MPEG декодеры (источники)
<br><b>загрузка:</b>   <a href="http://neuron2.net/dgmpgdec/dgmpgdec.html"> http://neuron2.net/dgmpgdec/dgmpgdec.html</a>
<br><b>требования:<br>
лицензия:</b>  GPL
<hr>
<h2>Содержание</h2>
<ul>
  <li><a href="#description">Описание</a></li>
  <li><a href="#syntax">Синтаксис фильтра</a>
    <ul>
      <li><a href="#mpeg2source">MPEG2Source()</a></li>
      <li><a href="#LumaYV12">LumaYV12()</a></li>
      <li><a href="#BlindPP">BlindPP()</a></li>
      <li><a href="#DeBlock">Deblock()</a></li>
    </ul>
  </li>
  <li><a href="#examples">Примеры использования</a>
    <ul>
      <li><a href="#loadplugin-ex">Примеры LoadPlugin()</a></li>
      <li><a href="#mpeg2source-ex">Примеры MPEG2Source()</a></li>
      <li><a href="#LumaYV12-ex">Примеры LumaYV12()</a></li>
      <li><a href="#BlindPP-ex">Примеры BlindPP()</a></li>
      <li><a href="#Deblock-ex">Примеры Deblock()</a></li>
    </ul>
  </li>
  <li><a href="#app_A">Приложение A: BlindPP() описание</a></li>
  <li><a href="#app_B">Приложение B: iDCT описание алгоритма</a></li>
  <li><a href="#app_C">Приложение C: SIMD инструкции</a></li>
  <li><a href="#history">История версий</a></li>
  <li><a href="#credits">Участники</a></li>
</ul>
<h2><a name="description"></a>Описание</h2>
	DGDecode, часть пакета <a href="dgmpgdec_quickstart.htm">DGMPGDec</a>, являющаяся MPEG-1/2 декодером выполненного в виде плагина для AviSynth v2.5
	или выше. Он позволяет декодировать любой MPEG-1 или MPEG-2 поток, прочитанный программой DGIndex. Возможности: YV12,
	I420, или YUY2 выходное цветовое пространство (и RGB24 через <a href="dgvfapi.htm">DGVfapi</a>), оптимизированные iDCTs, пост-обработка
	(деблокинг и дерингинг), яркостный фильтр, и многое другое!<br>
	(Прим. ред.: здесь деблокинг - подавление блочности,
	дерингинг - подавление волновой окантовки, звона в блоках изображения при сжатии).<br>
<p>DGDecode основан на MPEG2Dec3 v1.10, который в свою очередь основан на MPEG2Dec2 из проекта "save-oe" на  SourceForge.</p>
<p>Важное замечание: Этот фильтр был переименован в DGDecode во избежание проблем с названиями и чтобы явно связать с
	версией DVD2AVI neuron2'а, названной DGIndex. Neuron2 очень сильно хочет подтвердить происхождение DGDECODE,
	как описал MarcFD в тексте ниже! Да, neuron2 продолжил развитие и исправлял DGDECODE, но он стоял на плечах гигантов,
	указанных в секции "Авторы".</p>
<p>Вы можете взять последние откомпилированные программы и исходные коды DGMPGDec на http://neuron2.net/dgmpgdec/dgmpgdec.html</p>
<p>Это программное обеспечение распространяется свободно под лицензией GNU GPL v2.</p>
<h2><a name="syntax"></a>Синтаксис фильтра</h2>
<h3><a name="mpeg2source"></a>MPEG2Source()</h3>
<p><code>MPEG2Source</code> (string <var>&quot;d2v&quot;</var>, int <var>&quot;idct&quot;</var>, int
<var>&quot;cpu&quot;</var>, bool <var>&quot;iPP&quot;</var>, int <var>&quot;moderate_h&quot;</var>, int
<var>&quot;moderate_v&quot;</var>, str <var>&quot;cpu2&quot;</var>, bool <var>&quot;upConv&quot;</var>, int <var>&quot;iCC&quot;</var>, bool
<var>&quot;i420&quot;</var>, int <var>&quot;info&quot;</var>, bool <var>&quot;showQ&quot;</var>, bool
<var>&quot;fastMC&quot;</var>)</p>
<p>Хотя DGDecode сейчас может декодировать MPEG-1 и MPEG-2, эта функция до сих пор называется MPEG2Source()
для совместимости с имеющимися скриптами. Вы можете использовать её для MPEG-1 и MPEG-2 потоков.</p>
<p><var>d2v</var>: "[ПУТЬ\]project.d2v"</p>
<p>Файл проекта DGIndex.<br>
	Необходимые параметры!<br>
	Замечание 1: ПУТЬ можно не писать, если файл "project.d2v" в той же папке,
	 что и Ваш AviSynth (*.avs) скрипт.</p>
<p><var>idct</var>: 0 to 7 (по умолчанию: 0)</p>
<p>Алгоритм iDCT.<br>
	Для большей информации об iDCT читайте Приложение B.<br>
	Смотрите Приложение C для списка поддерживаемых процессоров.<br>
	- 0: Использует значение, указанное в DGIndex (6 и 7 недоступны в DGIndex)<br>
	- 1: 32-bit MMX<br>
	- 2: 32-bit SSEMMX<br>
	- 3: 64-bit SSE2MMX<br>
	- 4: 32-bit Числа с плавающей запятой<br>
	- 5: 64-bit рекомендуемый IEEE-1180<br>
	- 6: 32-bit SSEMMX (Skal)<br>
	- 7: 32-bit Simple MMX (XviD)</p>
<p><var>cpu</var>: 0 to 6 (по умолчанию: 0)</p>
<p>Предустановленные значения для пост-обработки.<br>
	(Y=яркость , C= цветность , H=горизонтально, V=вертикально)<br>
	- 0: Пост-обработка отключена<br>
	- 1: DEBLOCK_Y_H<br>
	- 2: DEBLOCK_Y_H, DEBLOCK_Y_V<br>
	- 3: DEBLOCK_Y_H, DEBLOCK_Y_V, DEBLOCK_C_H<br>
	- 4: DEBLOCK_Y_H, DEBLOCK_Y_V, DEBLOCK_C_H, DEBLOCK_C_V<br>
	- 5: DEBLOCK_Y_H, DEBLOCK_Y_V, DEBLOCK_C_H, DEBLOCK_C_V, DERING_Y<br>
	- 6: DEBLOCK_Y_H, DEBLOCK_Y_V, DEBLOCK_C_H, DEBLOCK_C_V, DERING_Y, DERING_C</p>
	Здесь обозначены части комбинации:<br>
	DEBLOCK_Y_H: Деблокинг яркости по-горизонтали,<br>
	DEBLOCK_Y_V: Деблокинг яркости по-вертикали<br>
	DEBLOCK_C_H: Деблокинг цветности по-горизонтали<br>
	DEBLOCK_C_V: Деблокинг цветности по-вертикали<br>
	DERING_Y: Дерингинг яркости<br>
	DERING_C: Дерингинг цветности
<p><var>iPP</var>: true/false (по умолчанию: auto)</p>
<p>Пост-обработка, основанная на полях.<br>
	DGDecode автоматически использует флаг прогрессивного кадра (PROGRESSIVE_FRAME)
	для переключения между основанной на поле/кадре
	пост-обработке на покадровую (per-frame-basis).<br>
	Вы можете установить параметр iPP, только если хотите чтобы DGDecode использовал
	конкретный режим пост-обработки.<br>
	- true: Использовать пост-обработку по полям (чересстрочного)<br>
	- false: Использовать пост-обработку по кадрам (прогрессивного)</p>
<p><var>moderate_h</var>, <var>moderate_v</var>: 0 to 255 (по умолчанию: moderate_h=20, moderate_v=40)</p>
<p>Чувствительность определения блочности.<br>
      (moderate_h=horizontal, moderate_v=vertical)<br>
      Чем меньше значения, тем сильней, используйте осторожно.</p>
<p><var>cpu2</var>: (default: "")</p>
<p>Выборочная пост-обработка.<br>
	Проставьте "x" или "o" во всех шести пунктах перечисленных ниже. (нечуствительно к регистру)<br>
	Каждый "x" включает соответствующую опцию пост-обработки, "o" - выключает.<br>
	первый символ: Деблокинг яркости по-горизонтали<br>
	второй символ: Деблокинг яркости по-вертикали<br>
	третий символ: Деблокинг цветности по-горизонтали<br>
	четвёртый символ: Деблокинг цветности по-вертикали<br>
	пятый символ: Дерингинг яркости<br>
	шестой символ: Дерингинг цвета</p>
<p>Например, чтобы включить только обработку цветности, используйте:</p>
<pre>MPEG2Source(&quot;project.d2v&quot;, cpu2=&quot;ooxxox&quot;)</pre>
<p><var>upConv</var>: true/false (по умолчанию: false)</p>
<p>Делает YUY2 (4:2:2) из YV12 (4:2:0), основываясь на флаге прогрессивного кадра.<br>
      Игнорируется, если источник не YV12 (4:2:0)<br>
      Используйте фильтр для AviSynth, если хотите постоянный режим интерполяции отсчетов (upsampling)
      (цветности - прим ред.) YUY2->YV12.<br>
      - true: Выполняет интерполяцию  если есть флаг PROGRESSIVE_FRAME<br>
      - false: Не выполняет интерполяцию</p>
<p><var>i420</var>: true/false (по умолчанию: false)</p>
<p>Выводить в цветовом пространстве I420.<br>
      Требуется для совместимости с некоторыми приложениями.<br>
      Игнорируется, если источник не YV12 (4:2:0), или если upConv=true.<br>
      - true: Выводит в I420<br>
      - false: Выводит в YV12</p>
<p><var>info</var>: 0 to 3 (по умолчанию: 0)</p>
<p>Отладочная информация.<br>
      - 0: Не генерировать отладочную<br>
      - 1: Отладочная информация выводится на видео через оверлей<br>
      - 2: Отладочная информация выводится через OutputDebugString()<br>
      - 3: Отладочная информация выводится на видео в виде подсказок - hints (как указано в utilities.cpp/utilities.h)</p>
<p><var>showQ</var>: true/false (по умолчанию: false)</p>
<p>Показывать квантизеры (quantizer - параметр потерь деталей) макроблоков.<br>
      - true: Показывать квантизеры<br>
      - false: Не показывать.</p>
<p><var>fastMC</var>: true/false (по умолчанию: false)</p>
<p>Компенсация быстрого движения Vlad'а.<br>
      Маленькая прибавка скорости, но значительное понижение точности декодирования.<br>
      Предназначена для тестирования, и может быть удалена в будущих версиях.<br>
      Требует SSE или 3DNow!, смотрите поддерживаемые процессоры в Приложении C.</p>
<h3><a name="LumaYV12"></a>LumaYV12()</h3>
<p><code>LumaYV12</code> (clip, int <var>&quot;lumoff&quot;</var>, float <var>&quot;lumgain&quot;</var>)</p>
<p>Эта функция не связана с яркостным фильтром из DGIndex'а.<br>
Это преобразование: Y = (y * lumgain) + lumoff</p>
<p>LumaYV12() выдаёт диапазон 0->255 YUV, а не CCIR-601 16->235. Используйте встроенный в Avisynth фильтр
	ColorYUV(), если хотите изменить диапазон до 16->235. Функциональность LumaYV12() может быть получена
	использованием ColorYUV(), который более функционален, но LumaYV12() оптимизирован по скорости для
	корректировки яркостной составляющей.</p>
<p><var>lumoff</var>: -255 to 255 (по умолчанию: 0)</p>
<p>Яркостный отступ.<br>
      Изменить яркость всех пикселей на заданную величину.</p>
<p><var>lumgain</var>: 0.0 to 2.0 (по умолчанию: 1.0)</p>
<p>Увеличение яркости.<br>
      Изменить яркость всех пикселей на пропорциональную величину.</p>
	<h3><a name="BlindPP"></a>BlindPP()</h3>
<p><code>BlindPP</code> (clip, int <var>&quot;quant&quot;</var>, int <var>&quot;cpu&quot;</var>, bool
<var>&quot;iPP&quot;</var>, int <var>&quot;moderate_h&quot;</var>, int <var>&quot;moderate_v&quot;</var>, string
<var>&quot;cpu2&quot;</var>)</p>
<p>Деблокинг и/или дерингинг любого видео источника.<br>
Требует YUY2 или YV12 входное цветовое пространство.<br>
Читайте Приложение A для пояснений использования.</p>
<p><var>quant</var>: 0 to 31 (по умолчанию: 2)</p>
<p>Имитирует квантизер (quatizer).<br>
      Устанавливает силу устранения блочности.</p>
<p><var>cpu</var>: 0 to 6 (по умолчанию: 6)</p>
<p>Такая же функция как и в MPEG2Source(), но с другими значениями по умолчанию.</p>
<p><var>iPP</var>: true/false (по умолчанию: false)</p>
<p>Такая же функция как и в MPEG2Source(), но с другими значениями по умолчанию.</p>
      Автоматический режим ОТСУТСТВУЕТ.</p>
<p><var>moderate_h</var>, <var>moderate_v</var>, <var>cpu2</var>: (по умолчанию: moderate_h=20, moderate_v=40, cpu2="")</p>
<p>Такая же функция как и в MPEG2Source(), но с другими значениями по умолчанию.</p>
<h3><a name="DeBlock"></a>DeBlock()</h3>
<p><code>Deblock</code> (clip, int <var>&quot;quant&quot;</var>, int <var>&quot;aOffset&quot;</var>, int
<var>&quot;bOffset&quot;</var>, bool <var>&quot;mmx&quot;</var>, bool <var>&quot;isse&quot;</var>)</p>
<p>Фильтр устранения блочности H.264 от Manao. (v0.9.5)<br>
Требует источник в YV12.<br>
Оба (quant + aOffset) И (quant + bOffset) должны быть >= 16 иначе фильтр не имеет смысла.</p>
<p><var>quant</var>: 0 to 51 (по умолчанию: 25)</p>
<p>Имитирует квантизер.<br>
      Устанавливает силу устранения блочности.</p>
<p><var>aOffset</var>: (по умолчанию: 0)</p>
<p>Изменяет порог определения блочности.<br>
      Высокие значения означают, что больше краёв будет смазано.</p>
<p><var>bOffset</var>: (по умолчанию: 0)</p>
<p>Модификатор определения блочности и силы её устранения.<br>
      И снова чем больше значение, тем сильней.</p>
<p><var>mmx</var>: true/false (по умолчанию: true)</p>
<p>Автоматически выключается, если процессор не поддерживает набор комманд MMX<br>
      - true: Включает оптимизацию под MMX<br>
      - false: Отключает MMX</p>
<p><var>isse</var>: true/false (по умолчанию: true)</p>
<p>Автоматически выключается, если процессор не поддерживает набор комманд SSE<br>
      Читайте Приложение C для списка поддерживаемых процессоров.<br>
      - true: Включает SSE оптимизации<br>
      - false: Не использует SSE оптимизации</p>
<h2><a name="examples"></a>Примеры использования</h2>
	<h3><a name="loadplugin-ex"></a>Пример LoadPlugin() из avisynth</h3>
<p> AviSynth команда LoadPlugin() должна вызываться перед использованием любой функции DGDecode.<br>
Чтобы проделать это, добавьте эту строчку в начало Вашего AviSynth (*.avs) скрипта:</p>
<pre>LoadPlugin(&quot;[ПУТЬ\]DGDecode.dll&quot;)</pre>
<p>Замечание: ПУТЬ может быть опущен, если DGDecode.dll находится в директории по умолчанию для плагинов AviSynth, иначе ПУТЬ должен быть указан.</p>
<h3><a name="mpeg2source-ex"></a>Примеры MPEG2Source()</h3>
<p>MPEG2Source() должен использоваться для MPEG-1 и MPEG-2 источников видео.</p>
<p>Чтобы только декодировать в YV12:</p>
<pre>MPEG2Source(&quot;[ПУТЬ\]project.d2v&quot;)</pre>
<p>Замечание: ПУТЬ может быть опущен, если DGDecode.dll находится в директории по умолчанию для плагинов AviSynth, иначе ПУТЬ должен быть указан.</p>
<p>Чтобы сделать только деблокинг:</p>
<pre>MPEG2Source(&quot;project.d2v&quot;, cpu=4)</pre>
<p>Чтобы сделать деблокинг на чересстрочном источнике с повышенной вертикальной чувствительностью:</p>
<pre>MPEG2Source(&quot;project.d2v&quot;, cpu=4, iPP=true, moderate_v=20)</pre>
<p>Чтобы делать только дерингинг:</p>
<pre>MPEG2Source(&quot;project.d2v&quot;, cpu2=&quot;ooooxx&quot;)</pre>
<p>Выбрать 32-bit SSE2 iDCT и установить выходное цветовое пространство I420 можно так:</p>
<pre>MPEG2Source(&quot;project.d2v&quot;, idct=5, i420=true)</pre>
<p>Изменить цветовое пространство в YUY2 исходя из флага прогрессивного кадра:</p>
<pre>MPEG2Source(&quot;project.d2v&quot;, upConv=true)</pre>
<p>Отобразить на экране информацию о видео:</p>
<pre>MPEG2Source(&quot;project.d2v&quot;, info=1)</pre>
<h3><a name="LumaYV12-ex"></a>Примеры LumaYV12()</h3>
<p>Приведённые примеры LumaYV12() конечно же субъективны и должны подбираться индивидуально.<br>
Используйте их как Вам будет угодно.</p>
<p>Сделать темней:</p>
<pre>MPEG2Source(&quot;project.d2v&quot;)
LumaYV12(lumoff=-10, lumgain=0.9)</pre>
<p>Сделать светлей:</p>
<pre>MPEG2Source(&quot;project.d2v&quot;)
LumaYV12(lumoff=10, lumgain=1.1)</pre>
<h3><a name="BlindPP-ex"></a>Примеры BlindPP()</h3>
<p>BlindPP() не должен использоваться, если видео открыто функцией<br>
MPEG2Source(), потому что её пост-обработка работает лучше. Обычно BlindPP() используется, если видео открывается
AviSynth'вским AviSource() или DirectShowSource().</p>
<p>Значения по умолчанию для деблокинга и дерингинга:</p>
<pre>AVISource(&quot;my_video.avi&quot;)
BlindPP()</pre>
<p>Только деблокинг:</p>
<pre>AVISource(&quot;my_video.avi&quot;)
BlindPP(cpu=4)</pre>
<p>Чтобы сделать деблокинг на чересстрочном источнике с повышенной горизонтальной чувствительностью:</p>
<pre>AVISource(&quot;my_video.avi&quot;)
BlindPP(cpu=4, iPP=true, moderate_h=10)</pre>
<p>Более сильный деблокинг и дерингинг:</p>
<pre>DirectShowSource(&quot;my_video.mpg&quot;)
BlindPP(quant=12)</pre>
<p>Только дерингинг:</p>
<pre>DirectShowSource(&quot;my_video.mpg&quot;)
BlindPP(cpu2=&quot;ooooxx&quot;)</pre>
<h3><a name="Deblock-ex"></a>Примеры Deblock()</h3>
<p>Deblock() не должен использоваться на MPEG-2 видео источнике.<br>
Обычно он используется при открытие через функции AviSynth'а AviSource() или DirectShowSource().</p>
<p>Деблокинг по умолчанию:</p>
<pre>AVISource(&quot;my_video.avi&quot;)
Deblock()</pre>
<p>Сделать сильный деблокинг с повышенной чувствительностью:</p>
<pre>DirectShowSource(&quot;my_video.mpg&quot;)
Deblock(quant=32, aOffset=16, bOffset=24)</pre>
<h2><a name="app_A"></a>Приложение A: описание BlindPP()</h2>
<p>
	Блочность получается вследствие 8x8-пиксельного дискретное косинусное преобразование (далее DCT)
	используемого MPEG кодировщиком. Вы должны быть уверены что блоки, от которых Вы хотите
	избавиться имеют стороны по 8 пикселей. Это означает, что перед применением BlindPP() не нужно делать
	изменение размеров или обрезание картинки. Если источник закодирован с чередованием полей (чересстрочно),
	установите <var>iPP</var>=true, если же он прогрессивный, то значение по умолчанию - правильно (<var>iPP</var>=false).</p>
<p>Параметры: <var>quant</var>, <var>cpu2</var>, <var>moderate_h</var>, and <var>moderate_v</var>.</p>
<p><var>quant</var> определяет общую силу с которой нужно убирать блоки.</p>
<p>Установите <var>cpu2</var> в "xxxxoo" для горизонтального и вертикального деблокинга цветности и яркостной
	состовляющих, в "xooxoo" для горизонтального яркости и вертикального деблокинга цветности, и т.д. Идею Вы получили.</p>
<p><var>moderate_h</var> и <var>moderate_v</var> означают горизонтальную и вертикальную чувствительность, определяющую
	зону, где будет выполняться деблокинг, а где нет. Эти значения регулируют чувствительность распознания наличия блочности.</p>
<p><var>quant</var>=2, <var>moderate_h</var>=35-45, <var>moderate_v</var>=45-55 будет произведено очень мягкое сглаживание
	очень больших блоков. Это сохранит очень много деталей и резкости, но также не избавит от "слабых" блоков,
	и не уберёт полностью более сильные.</p>
<p><var>quant</var>=16, <var>moderate_h</var>=15-20, <var>moderate_v</var>=20-30 будет произведено очень грубое удаление
	всего, что было блоками, а также это сгладит картинку и потеряются детали и резкость.</p>
<p>Выбирать Вам в зависимости от Вашего вкуса и видео источника.</p>
<p>Ещё один пример... Так как замечательный шумодав PixieDust() сам иногда вызывает появление блоков в движущихся областях,
	я решил с этим что-нибудь сделать:</p>
<pre>PixieDust(2)
BlindPP(quant=8, cpu2=&quot;xxxxoo&quot;, moderate_h=45, moderate_v=55)</pre>
<p>Этого удаляет значительную долю наиболее видимой блочности, если только действительно PixieDust() произвёл его.
	В оставшихся 99.8% случаев, когда PixieDust() не производит блоков,
	эта функция почти ничего не делает, как и желательно.</p>
<h2><a name="app_B"></a>Приложение B: описание алгоритма iDCT</h2>
<p>
      Файл readme из FlasKMPEG содержит замечательное техническое описание работы iDCTs. В нём излагается:</p>
<blockquote>
<p><i>"Видео информация внутри MPEG файла хранится в частотном представлении, а не в пространственном
 представлении (те изображения, которые мы видим).
	Это делает информацию компактней и эту компактность мы можем использовать чтобы сжать (снизить)
	количество информации, которое мы должны послать по передающим каналам.
	(Прим перев.: Это позволяет алгоритму сжатия отбросить те элементы изображения,
	которые наименее важны для восприятия картинки человеческим глазом,
	степень сжатия, в итоге, и зависит от количества отбрасываемой информации).
	MPEG использует дискретное косинусное преобразование (DCT) чтобы перевести пространственную информацию в частотную.
	Чтобы вернуть обратно пространственную информацию из MPEG потока, мы должны применить iDCT, что означает обратное
	дискретное косинусное преобразование, которое обращает DCT, которое мы использовали при кодировании."</i></p>
<p><i>"Хотя MPEG жестко задает почти все почти полностью определяет все возможности
(при данном MPEG потоке, выход должен быть идентичен для всех декодеров), но
	стандарт позволяет использовать разные iDCT  (Прим. перев: например, для ускорения работы декодера).
	Поэтому декодер может быть легко реализован в зависимости от используемой аппаратуры.
	Стандарт требует от декодера, чтобы iDCT соответствовало IEEE-1180,
	иначе говоря чтобы ошибки iDCT не были бОльшими, чем это определено в IEEE-1180."</i></p>
</blockquote>
<p>Какой iDCT Вы будете использовать зависит в основном от Вашего процессора и степени того,  насколько точное iDCT
	Вы хотите. Большинство людей не способны сказать о разнице этих алгоритмов,
	но она может быть легко исследована
	комбининацией AviSynth фильтров
<a href="../corefilters/subtract.htm">Subtract</a>() и <a href="../corefilters/levels.htm">Levels</a>(). Все доступные
	опции совместимы с IEEE-1180, кроме <b>SSE/MMX (Skal)</b>.</p>
<p>По качеству: <b>IEEE-1180 Reference</b> > <b>64-bit Floating Point</b> > <b>Simple MMX (XviD)</b> > остальные iDCTs.</p>
<p>По скорости: <b> SSE2/MMX</b> и <b> SSE/MMX (Skal)</b> как правило самые быстрые. <b>IEEE-1180 Reference</b> - самый простой
	и медленный.</p>
<h2><a name="app_C"></a>Приложение C: SIMD инструкции</h2>
<p>SIMD расшифровывается как <i>Single Instruction</i>, <i>Multiple Data</i>(Одна инструкция, много данных). Это означает
	передачу набору команд большого кол-ва данных для эффективной параллельной обработки. Такой метод даёт большой прирост
	производительности в приложениях по обработке аудио и видео файлов. Это обычно требует повторения последовательности
	команд, которые будут выполняться теперь за один такт.</p>
<p>Существует семь разных наборов SIMD инструкций доступных в процессорах Intel и AMD, но не каждая модель процессора поддерживает
	все эти продвинутые наборы инструкций. Вот почему многие функции DGDecode снабжены опциями для определения,
	используемого набора комманд. Таблица ниже содержит SIMD инструкции, поддерживаемые DGDecode, и процессоры,
	требуемые для их использования.</p>
<ul>
  <ul>
    <table border="1px" cellspacing="2px" cellpadding="10%">
      <caption><i>Table 1: SIMD инструкции, поддерживаемые DGDecode</i></caption>
      <tr>
        <th>&nbsp;
        <th>MMX
        <th>3DNow!
        <th>SSE
        <th>SSE2
      <tr>
        <th>Требует процессор Intel
        <td>Все Intel CPUs
        <td>Не поддерживаются Intel
        <td>Pentium 3, Pentium 4
        <td>Pentium 4
      <tr>
        <th>Требует процессор AMD
        <td>Все AMD CPUs
        <td>Все AMD CPUs
        <td>Athlon XP, Athlon 64
        <td>Athlon 64
    </table>
  </ul>
</ul>
    <h2><a name="history"></a>История версий</h2>
<b>Основан на MPEG2Dec2 (выгрузка из CVS от 28.09.2002),  переработан до MPEG2Dec3 (MarcFD).</b>
<ul>
  <li><u>бета версии (с 1 по 6)</u>
    <ul>
      <li>Добавлена пост обработка Nic'а, основанная на поле PP</li>
      <li>подавленный iDCT / вариант яркостной фильтрации</li>
      <li>Исправлен код MMX в яркостном фильтре (всего три ошибки)</li>
      <li>YV12-&gt;YUY2 конвертация оптимизирована (быстрей +10%)</li>
      <li>Исправлена ошибка в пост-обработке. Теперь немного медленней.</li>
      <li>Добавлена SSE2 оптимизация trbarry.</li>
      <li>Добавлен переключатель showQ</li>
      <li>добавлена новое компенсация движения vlad'а (3dnow/ssemmx) / переписан ssemmx</li>
      <li>Добавлена передача памяти (через MMX) для поиска (+3% скорость)</li>
      <li>Добавлена поддержка чересстрочного апсэмплинга<br>
      </li>
    </ul>
  </li>
  <li>
      <u>v 0.9 (09.11.02)</u>
    <ul>
      <li>сильная чистка кода</li>
      <li>изменён интерфейс работы с Avisynth</li>
      <li>поддержка YV12</li>
      <li>поддержка RGB24</li>
      <li>много других мелочей<br>
      </li>
    </ul>
  </li>
  <li>
      <u>v 0.91 (10.11.02)</u>
    <ul>
      <li>немного почищен код</li>
      <li>Добавлен MPEG2Dec3.def в загрузку по умолчанию (как преобладающий фильтр)</li>
      <li>В SeparateFieldsYV12() первое поле нижнее (bff)<br>
      </li>
    </ul>
  </li>
  <li>
      <u>v 0.92 (17.11.02)</u>
    <ul>
      <li>Издан код</li>
      <li>Появился blindPP<br>
      </li>
    </ul>
  </li>
  <li>
      <u>v 0.93 (25.11.02)</u>
    <ul>
      <li>полный переход на YV12...</li>
      <li>...кто исправил ошибки YV12</li>
      <li>стал требовать меньше памяти</li>
      <li>быстрое MMX копирование (ускорился поиск)<br>
      </li>
    </ul>
  </li>
  <li>
      <u>v 0.94 (08.12.02)</u>
    <ul>
      <li>незначительные исправления<br>
      </li>
    </ul>
  </li>
  <li>
      <u>v 1.00 (19.01.03)</u>
    <ul>
      <li>финальная версия</li>
      <li>я исправил все, известные ошибки<br>
      </li>
    </ul>
  </li>
  <li>
      <u>v 1.01 (unknown) - trbarry</u>
    <ul>
      <li>Исправлена ошибка HDTV (0x21 PID неизменяемый)<br>
      </li>
    </ul>
  </li>
  <li>
      <u>v 1.02 (12.05.03) - Nic</u>
    <ul>
      <li>выполнено выравнивание разницы malloc'а (aligned malloc done different !!!)<br>
      </li>
    </ul>
  </li>
  <li>
      <u>v 1.03 (12.05.03) - Nic</u>
    <ul>
      <li>
        Теперь поддерживаются DVD2AVI 1.77.3 и 1.76 D2V файлы.<br>
      </li>
    </ul>
  </li>
  <li>
      <u>v 1.04 (12.05.03) - Nic</u>
    <ul>
      <li>Исправлена утечка памяти, небольшое ускорение<br>
      </li>
    </ul>
  </li>
  <li>
      <u>v 1.05a (12.05.03) - trbarry</u>
    <ul>
      <li>
        Тестовая версия trbarry для скоростных оптимизаций<br>
      </li>
    </ul>
  </li>
  <li>
      <u>v 1.06 (24.05.03)</u>
    <ul>
      <li>
        Nic: Добавлены два новых iDCT: Skal's (самый быстрый, idct=6) &amp; SimpleiDCT (очень
		точный, idct=7)</li>
      <li>Nic: Поддерживает внешнее использование MPEG2Dec3.dll без AviSynth<br>
        (Смотрите файлы example.zip и GetPic example)</li>
      <li>trbarry: Добавлен новая оптимизация Add_Block также хороша как Block
		Decoding для процессоров с SSE2</li>
      <li>sh0dan: Используется AviSynth'овская быстрая функция BitBlt для копирования в памяти, где это возможно</li>
      <li>Nic: Общая оптимизация :) Стал быстрей работать на всех протестированных компьютерах.<br>
      </li>
    </ul>
  </li>
  <li>
      <u>v 1.07 (6.06.03)</u>
    <ul>
      <li>
        Nic &amp; Sh0dan: Исправления ошибок, улучшена стабильность на битых потоках<br>
      </li>
    </ul>
  </li>
  <li>
      <u>v 1.08 (8.06.03)</u>
    <ul>
      <li>
        trbarry: Оптимизирован алгоритм Simple_iDCT, значительно быстрей теперь :)</li>
      <li>Nic: Добавлен CPUCheck, забыл исправить Lumafilter в последний раз (спасибо
        ARDA!), robUx4 помог мне сделать simple_idct в быстром вызове<br>
      </li>
    </ul>
  </li>
  <li>
      <u>v 1.09 (26.07.03)</u>
    <ul>
      <li>Nic: Новый Sparse iDCT skal'а теперь используется вместо idct=6 (самый быстрый!)</li>
      <li>Nic: Добавлен Luminance_Filter (фильтр цвета) из DVD2AVI 1.77.3, в котором
        Luminance_Filter использовался в .d2v<br>
      </li>
    </ul>
  </li>
</ul>
<ul>
  <li>
      <u>v 1.10 (28.07.03)</u>
  </li>
    <ul>
	      <li>Nic: Чёрт! Опять проблемы с этим фильтром яркости и файлами
			D2V версии 1.77.3. Исправлено!</li>
    </ul>
</ul>
<p><b>Переиздано как DGDecode (neuron2)</b></p>
<ul>
  <li>v 1.0.13 (8.06.04)
    <ul>
      <li>DG: Исправлено игнорирование DGDecode'ом B-кадров перед первым P-кадром.</li>
      <li>DG: Исправлено безоговорочное уменьшение счета кол-ва кадров на два.</li>
      <li>DG: Переписан код для декодирования и случайного поиска для правильной работы с D2V файлами созданными исправленными версиями DGIndex.</li>
      <li>DG: Исправлен DGDecode (надеюсь) для прекращения падений VirtualDub'а на выходе, когда последний кадр битый.</li>
      <li>DG: Исправлен iDCT, выбираемый не глобально в DGDecode.<br>
      </li>
    </ul>
  </li>
  <li>v 1.1.0 (21.01.05)
    <ul>
      <li>DG: Добавлена возможность открытия битых потоков (теперь не падает на них).</li>
      <li>DG: Добавлена правка файлов, у которых меняется матрица квантования на лету.</li>
      <li>tritical: Исправлен DC режим назначения деблокинга при пост-обработке.</li>
      <li>tritical: Добавлена опция "info" в mpeg2source() для вывода информации о потоке на экран.</li>
      <li>tritical: iPP изменён на "auto" по умолчанию. "auto" использует флаг прогрессивного кадра для переключения между пост-обработкой поля/кадра.</li>
      <li>tritical: Добавлена поддержка цветового формата 4:2:2 на входе.</li>
      <li>tritical: Добавлена опция "upConv" в mpeg2source() для интерполяции отсчетов до 4:2:2 из 4:2:0,
      основываясь на флаге прогрессивного кадра.</li>
      <li>tritical: BlindPP теперь поддерживает цветовое пространство YUY2.</li>
      <li>tritical: Исправлена ошибка в BlindPP - различия регистров. (x - не X!)</li>
      <li>tritical: Исправлена маленькая ошибка в showQ.</li>
      <li>tritical: Исправлена утечека памяти, когда FrameList/GOPList не был пуст.</li>
      <li>tritical: Исправлена ошибка в вертикальном цветовом деблокинге пост-обработки QP, переходный указатель, был неправильный для 4:2:0.</li>
      <li>tritical: Быстрое MMX преобразование 4:2:2, упакованного в YUY2, и YUY2 в плоскостное (planar) 4:2:2.</li>
      <li>tritical: Исправлен вывод "info", работавшего неправильно, если temporal_reference был не нулевым в начале GOP'а.<br>
      </li>
    </ul>
  </li>
  <li>v 1.2.0 (17.02.05)
    <ul>
      <li>DG: Переработан параметр "info".</li>
      <li>DG: Исправлена ошибка в пост-обработке - дерингинге.</li>
      <li>DG: Исправлены проблемы падений BlindPP() при входном YUY2.<br>
      </li>
    </ul>
  </li>
  <li>v 1.2.1 (22.02.05)
    <ul>
      <li>DG: Исправлена ошибка вызывавшая крушение BlindPP().</li>
      <li>DG: Исправлена неправильная пост-обработка для YUY2.</li>
      <li>DG: Изменён DGDecode для приёма YV12 по умолчанию.</li>
      <li>DG: добавлен параметр i420 в DGDecode.</li>
      <li>Manao: Добавлен фильтр слепого деблокинга Deblock(), как в H.264.<br>
      </li>
    </ul>
  </li>
  <li>v 1.3.0 (01.05.05)
    <ul>
      <li>DG: Добавлен перехват исключения, из-за которого DGDecode не должен рушиться при битой картинке.</li>
      <li>DG: Изменён метод интерполяции отсчетов VFAPI
      ("_P" перед расширением D2V в имени файла форсирует прогрессивный пересчет; иначе используется чересстрочный).<br>
      </li>
    </ul>
  </li>
  <li>v 1.4.0 (15.06.05)
    <ul>
      <li>DG: Добавлена возможность стандартного вызова функций из dgdecode.dll для использования в VB, и т.п. Такие как: getRGBFrame_SC().</li>
      <li>DG: Исправлена ошибка слайсового восстановления, становившаяся причиной (очень редко) ошибок декодирования картинки.</li>
      <li>DG: Программные потоки с ID видео потоков, отличных от 0xE0 теперь поддерживаются.</li>
      <li>DG: Исправлены ошибки декодирования, из потоков ранее не поддававшихся восстановлению.</li>
      <li>DG: Добавлена поддержка MPEG1 файлов.</li>
      <li>DG: Исправлена ошибка при разборе (parsing) транспортного потока (TS),
       вызывавшая несоответствия между линейным декодированием и поиском случайного кадра.</li>
      <li>DG: Удалены YV12toYUY2() и YV12toRGB24() т.к являлись дубликатами встроенных фильтров Avisynth'а.</li>
      <li>ARDA: Заменён ошибочный LumaFilter() на надёжный и оптимизированный LumaYV12().</li>
      <li>jackei: Исправлен Рекомендуемый (Reference) iDCT (№ 4).</li>
      <li>tritical: Исправлено присвоение pitch=width, позволяющее теперь нормально работать с версиями Avisynth, которые изменяют правила выравнивания.</li>
      <li>tritical: DGVfapi теперь поддерживает множество инсталяций и может так же открывать AVS скрипт также хорошо как и D2V.</li>
    </ul>
  </li>
</ul>
    <h2><a name="credits"></a>Участники&nbsp;</h2>
<p>       Mathias Born, автор MPEG2Dec<br>
      Donald Graft ("neuron2"), исправление потерянного кадра, точное индексирование, поддержка PVA, и многое другое<br>
      Peter Gubanov, автор MMX/SSEMMX iDCT<br>
      Chia-chen Kuo ("jackei"), автор DVD2AVI<br>
      "MarcFD", ввёл поддержку YV12 и многое другое<br>
      "Nic", пост обработка и многое другое<br>
      Miha Peternel, автор Floating Point и Reference iDCT<br>
      Dmitry Rozhdestvensky, автор SSE2 iDCT<br>
      "sh0dan", оптимизация кода<br>
      "Skal", for his SSEMMX iDCT<br>
      "trbarry", разбор (parsing) TS, и оптимизация кода<br>
      "tritical", интеполяция отсчетов, информация через оверлей, улучшения VFAPI, и много исправленных ошибок<br>
      "Manao", за фильтр Deblock()<br>
      "ARDA", за фильтр LumaYV12()<br>
      "Didйe", за приложение A: описание использование BlindPP()<br>
      "Cyberia", за приложения B и C, и усовершенствование пользовательской инструкции</p>
<p><kbd>$English Date: 2007/09/22 21:28:24 $<br>
Русский перевод 16.05.2006 SCIF scif@iatp.festu.ru $</kbd><br>
Редакция 18.05.2006-23.09.2007 Fizick
</p>
</body></html>