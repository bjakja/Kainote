<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="ru">
<head>
<title>TDeint</title>
<meta http-equiv="content-type" content="text/html; charset=windows-1251">
<link rel="stylesheet" type="text/css" href="../../avisynth.css">
<!--
Automatically generated, don't change:
$Id: tdeint.htm,v 1.4 2006/12/13 21:01:40 fizick Exp $
-->
</head>
<body>
<h1>TDeint</h1>
<h2>Общая информация</h2>
<b>Автор:</b> tritical <br>
<b>Версия:</b> v1.0 RC7<br>
<b>Загрузка:</b> <a href="http://bengal.missouri.edu/~kes25c/">http://bengal.missouri.edu/~kes25c/</a>
<br>
<b>Категория:</b> Удаление чересстрочности и Устранение прореженности кадров<br>
<b>Требования:</b> Цветовые пространства YV12 и YUY2<br>
<b>Лицензия:</b> GPL<P></p>

<hr size=2 width="100%" align=center>


<h2>Описание</h2>
<p>TDeint - это двунаправленый, компенсированный по движению (резкостный) удалитель
 чересстрочности (деинтерлейсер). Он также может адаптивно выбирать между использованием адаптации
 к движению по целым полям и по пикселам. Может использовать кубическую интерполяцию,
 ядерную (матричную) интерполяцию (с переключением временнОго направления), или
 одну из двух форм модифицированой краевой адаптивной (ELA) интерполяции, которая
 помогает уменьшить "зубчатые" края в движущихся областях, где интерполяция должна
 использоваться. TDeint также поддерживает ручную коррекцию пользователем через
 специальный входной файл и может работать как интеллектуальный преобразователь
 полей в полноформатный кадр (bobber) или удалитель черестрочности с сохранением
 исходной частоты кадров, а также как пост-обработчик обратного преобразования
 телекино (IVTC).</p>
<h3>Синтаксис</h3>
<p><code>TDeint</code> (видеоклип, int <var>&quot;mode&quot;</var>, int <var>&quot;order&quot;</var>,
 int <var>&quot;field&quot;</var>, int <var>&quot;mthreshL&quot;</var>, int <var>&quot;mthreshC&quot;</var>,
 int <var>&quot;map&quot;</var>, string <var>&quot;ovr&quot;</var>, int <var>&quot;ovrDefault&quot;</var>,
 int <var>&quot;type&quot;</var>, bool <var>&quot;debug&quot;</var>, int <var>&quot;mtnmode&quot;</var>,
 bool <var>&quot;sharp&quot;</var>, bool <var>&quot;hints&quot;</var>, PClip <var>&quot;clip2&quot;</var>,
 bool <var>&quot;full&quot;</var>, int <var>&quot;cthresh&quot;</var>, bool <var>&quot;chroma&quot;</var>,
 int <var>&quot;MI&quot;</var>, bool <var>&quot;tryWeave&quot;</var>, int <var>&quot;link&quot;</var>,
 bool <var>&quot;denoise&quot;</var>, int <var>&quot;AP&quot;</var>, int <var>&quot;blockx&quot;</var>,
 int <var>&quot;blocky&quot;</var>, int <var>&quot;APType&quot;</var>, PClip <var>"edeint"</var>,
 PClip <var>"emask"</var>, float <var>"blim"</var>, int <var>"metric"</var>, int
 <var>"opt"</var>)</p>
<h3>ПАРАМЕТРЫ</h3>
<p><var>mode</var>:</p>
<p>Устанавливает режим работы. Режимы mode=-2 и -1 требуют прогрессивного входного
 сигнала. </p>
<p>-2 - двойная высота с использованием модифицированной краевой адаптации (ELA)
 <br>
 -1 - двойная высота с использованием модифицированной краевой адаптации-2 (ELA-2)
 <br>
 0 - та же скорость вывода<br>
 1 - удвоенная скорость вывода (bobbing)<br>
 2 - та же скорость вывода (смешивает кадры потока с удаленной методом удвоения
 полей (bobbed) чересстрочностью)</p>
<p>по умолчанию - 0 (int)</p>
<p><var>order</var>:<br>
 <br>
 Устанавливает порядок полей для видео.</p>
<p>-1 - использовать четность из AviSynth<br>
 0 - нечетное (нижнее) поле первое (bff)<br>
 1 - четное (верхнее) поле первое (tff)</p>
<p>по умолчанию - -1 (int)</p>
<p><var>field</var>:</p>
<p>В режиме mode=0 и 2 это указывает, что полe будет интерполироваться (т.е. другое
 поле сохраняется как есть, а это поле будет воссоздано). В режиме 1 этот параметр
 не делает ничего.<br>
 <br>
 -1 - установит поле на 1, если hints = false (ложь) или 0, если hints = true
 (истина)<br>
 0 - интерполировать верхнее поле (сохранить нижнее поле)<br>
 1 - интерполировать нижнее поле (сохранить верхнее поле)</p>
<p>по умолчанию - -1 (int)</p>
<p><var>mthreshL</var>/<var>mthreshC</var>:</p>
<p>Пороги движения для яркости и цветности (mthreshL для яркости, mthreshC для
 цветности). Если разница между двумя пикселами меньше этого значения, они объявляются
 статическими. Меньшие значения уменьшат остаточную гребенчатость, большие значения
 уменьшат мерцание и увеличат точность создания поля в статических областях. Пространственно
 совпадающие части уровней яркости и цветности связаны (если связь ! = 0), так
 что mthreshC и mthreshL могут быть отчасти сцеплены. Установка обеих величин
 в 0 или ниже заблокирует компенсацию движения (т.е. каждый пиксел будет объявлен
 движущимся), разрешая деинтерлейс удвоением полей (dumb bob).</p>
<p>по умолчанию - <var> mthreshL</var> - 6  (int)<br>
<var>                mthreshC</var> - 6</p>
<p><var>map</var>:</p>
<p>Показывает карту вывода вместо деинтерлейсного кадра. Есть три возможных параметра.
 **Прим.: карты не будут показаны если у текущего кадра не удаляется чересстрочность
 из-за ручной коррекции, <var>hints</var>, <var>full</var>=false, или <var>tryWeave</var>=true.</p>
<p>**пост-обработка с порогом защиты артефактов (AP) сейчас не принимается во
 внимание при использовании <var> map</var> = 1 или 2.</p>
<p>0 - без карты<br>
 1 - карта значений (бинарная). Это выдаст кадр в котором все пикселы имеют одно
 из следующих значений (указывая, как будет построен кадр):<br>
 0 (использовать пиксел из текущего кадра)<br>
 51 (использовать пиксел из предыдущего кадра)<br>
 102 (использовать пиксел из следующего кадра)<br>
 153 (использовать среднее из текущ./след.)<br>
 204 (использовать среднее из текущ./пред.)<br>
 255 (интерполировать пиксел)<br>
 2 - объединенная карта. Это даст кадр в котором все статические части кадра (значения
 0, 51, 102, 153, и 204 от map=1) будут построены так, как они появились бы в
 кадре с удаленной чересстрочностью, а пикселы, которые должны будут интерполироваться,
 закрасятся белым.</p>
<p>по умолчанию - 0  (int)</p>
<p><var>ovr</var>:</p>
<p>Устанавливает имя и путь к файлу ручной коррекции. Когда mode=0 файл коррекции
 может использоваться чтобы управлять значениями mthreshL, mthreshC, поля, порядка
 и типа отдельных кадров или диапазонов кадров, а также управлять тем, какие кадры
 являются деинтерлейсными. Когда mode=1, файл коррекции может использоваться чтобы
 управлять значениями mthreshL, mthreshC и типом определенных кадров или диапазонов
 кадров.</p>
<p>Параметры файла ручной коррекции:</p>
<p>+ = пометить кадр, у которого должна удаляться чересстрочность (полезен лишь
 если ovrDefault = 1)<br>
 - = пометить кадр, у которого не должна удаляться чересстрочность<br>
 f = поле<br>
 o = порядок<br>
 l = mthreshL<br>
 c = mthreshC<br>
 t = тип</p>
<p>*Параметры c,f,o,l,t также требуют, чтобы при их использовании было указано
 измененное значение (смотри синтаксис ручной коррекции, чтобы увидеть как это
 сделать)</p>
<p>Синтаксис ручной коррекции:</p>
<p>[] = не требуется для +,- параметров</p>
<p>коррекция единичного кадра:</p>
<p>номер_кадра параметр [измененное_значение]</p>
<p>примеры:</p>
<pre>245 f 1
345 +
400 -
450 c -1</pre>
<p> коррекция диапазона кадров:</p>
<p>начальный_номер_кадра,конечный_номер_кадра параметр [измененное_значение]</p>
<p>примеры:</p>
<pre>100,200 +
346,352 f 0
900,1200 l 5</pre>
<p>* диапазон является включающим, означая, что обрабатываются как начальный,
 так и конечный кадры</p>
<p>основанная на шаблоне ручная коррекция диапазона кадров (лишь для +,- параметров):</p>
<p>примеры:</p>
<pre>100,300 +-+++--+++
400,456 ---+---++</pre>
<p>* будет использовать данный шаблон в указанном диапазоне кадров</p>
<p>Что нужно помнить (ключевые правила):</p>
<ol>
 <li>Диапазоны являются включающими.</li>
 <li>Когда mode = 1 (bobbing-деинтерлейс) все ручные корректировки, за исключением
  mthreshL/mthreshC и корректировок типа, игнорируются. Также, номера кадров соответствуют
  входному клипу, а не выходному клипу, так что один кадр станет двумя кадрами
  на выходе.</li>
 <li>Измененное значение всегда устанавливается обратно в свое исходное значение
  после того как коррекция выходит за пределы указанного диапазона. (т.e. если
  вы указываете коррекцию mthresh для кадров от 600 до 700, то после кадра 700
  mthresh устанавливается снова в свое первоначальное значение автоматически,
  вы не должны устанавливать ее обратно в файле коррекции!) Исходное значение
  - это то, которое установлено при загрузке (т.е. или значение по умолчанию,
  или то, которое вы устанавливаете в вашем avisynth-сценарии).</li>
 <li>Номера кадров должны быть в пределах диапазона данного файла.</li>
 <li>Номера кадров для определенных параметров должны возрастать (если нет, то
  приоритетным будет последнее значение в файле, напр. если вы задаете 300 400
  c 10, затем 350 450 c 12, то кадры с 350 по 400 будут использовать 12, не 10).</li>
 <li>Номера кадров для (+,-) параметров не могут перекрываться (т.е. не пишите
  300 400 -, а затем позже в файле 350 500 +, иначе произойдет непредсказуемое.
  Другие параметры не должны удовлетворять этому требованию, поскольку они все
  влияют на разные вещи.</li>
 <li> параметры (+, -) не требуют никакого измененного значения.</li>
 <li>Пробелы важны! Просто посмотрите на примеры.</li>
 <li>Только +, - параметры могут использоваться в определениях шаблонов.</li>
 <li>Вы можете менять множественные параметры в пределах одного и того же диапазона
  кадров до тех пор, пока вы следуете вышеуказанным правилам (например +, - номера
  кадров по возрастанию).</li>
 <li>Вы можете закомментировать строку (т.е. она будет игнорироваться), добавляя
  '#' или ';' в начало строки.</li>
 <li>0 в качестве конечного_кадра (end_frame) для диапазона кадров принимается
  за последний кадр данного видео-ряда.</li>
</ol>
<p>Пример файла ручной коррекции:&nbsp;</p>
<p> Пример синтаксиса => TDeint(order=1,ovr=&quot;c:\path\myoverridesfile.txt&quot;)</p>
<pre>100,300 o 0
100,300 f 1
90,250 c 3
40,500 -
505 -
300,700 l -1
#700,3000 f 1 &lt;- комментарий, будет проигнорирован
800,1000 -++-
500,1000 c 13</pre>
<p>по умолчанию - ""  (string)</p>
<p><var>ovrDefault</var>:</p>
<p>При использовании файла коррекции для mode 0, это определяет действие по умолчанию
 для всех кадров видео-ряда. Используя ovrDefault=1 можно легко удалить чересстрочность
 лишь у нескольких единичных кадров видео. Когда mode = 1 этот параметр не делает
 ничего.</p>
<p>0 - у всех кадров, не указанных как '-' в файле коррекции, чересстрочность
 удаляется<br>
 1 - все кадры, не указанные как '+' в файле коррекции, сохраняют чересстрочность
 и просто возвращаются как есть</p>
<p>по умолчанию - 0  (int)</p>
<p><var>type</var>:</p>
<p>Устанавливает тип используемой интерполяции. Кубическая самая быстрая, модифицированные
 краевой адаптации ELA и ELA2 дадут более гладкие, менее "зубчатые" края и являются
 самыми медленными (ELA2 быстрее), а ядерная интерполяция обусловит значительно
 меньше мерцания чем кубическая или ELA в случае использования интерполяции в
 почти статических областях. Модифицированные ELA/ELA2 работают лучше всего с
 анимацией/мультипликацией... они не так хороши с реальным видео из жизни (иногда
 и хороши, попробуйте сами).</p>
<p>0 - кубическая интерполяция<br>
 1 - модифицированная ELA интерполяция<br>
 2 - ядерная интерполяция (может быть нормальной или резкой, управляется параметром
 резкости)<br>
 3 - модифицированная ELA-2 интерполяция</p>
<p>по умолчанию - 2  (int)</p>
<p><var>debug</var>:</p>
<p> Выводит отладочную информацию, в которой для каждого кадра будут указаны значения
 порядка, поля, mthreshL, mthreshC и типа, если у кадра удаляется чересстрочность.
 Если у кадра чересстрочность сохраняется (из-за коррекции пользователя, подсказок
 или full=false), то будет просто указано, что у кадра чересстрочность не удаляется
 и приведена причина. Если выходной кадр горизонтально нестабилен, то в отладочной
 информации укажется , с каким полем текущее поле было соединено (ПРЕДЫД. или
 СЛЕДУЮЩ.).</p>
<p>по умолчанию - false (bool)</p>
<p><var>mtnmode</var>:</p>
<p> Определяет используется ли контроль движения по 4 полям или по 5 полям. 5
 полей предотвратят больше артефактов и могут работать со сдвоенными интерлейсными
 кадрами, однако это действительно медленнее чем контроль движения по 4 полям.
 Режимы 2 и 3 подобны 0 и 1 за исключением того, что в режимах 0 или 1 в областях,
 где использовалось бы среднее предыд. и следующ. полей, используется вместо этого
 вес пиксела (вычисленный по разнице полей) наиболее сходного поля (т.е. никакие
 средние не используются). </p>
<P></P>
<P> 0 - контроль по 4 полям <BR>
 1 - контроль по 5 полям <BR>
 2 - контроль по 4 полям (без средних, замена на наиболее сходное поле) <BR>
 3 - контроль по 5 полям (без средних, замена на наиболее сходное поле) </P>
<p>по умолчанию - 1  (int)</p>
<p><var>sharp</var>:</p>
<p> Определяет, используется ли резкая или нормальная матрица при использовании
 ядерной интерполяции (type = 2). Резкая матрица включает больше пиксел и дает
 более резкий результат, но - немного медленнее. </p>
<P> true (истина) - использовать резкую матрицу <BR>
 false (ложь) - использовать нормальную матрицу </P>
<p>по умолчанию - true (bool)</p>
<p><var>hints</var>:</p>
<p>Читает подсказки от телецида (telecide) или определителя полей (tfm) показывая,
 какие кадры интерлейсные и какие - нет, если подсказки присутствуют в
 видео потоке. Чтобы заставить это работать, вы должны установить post=1 в телециде
 <BR>
 или PP=1 в tfm и поместить TDeint сразу же после этого. TDeint не будет оказывать
 влияние на подсказки (до тех пор, пока ваше видео имеет ширину по крайней мере
 64 пиксела) в случае, если какие-либо фильтры впоследствии нуждаются в их считывании.
 Если hints установлены в true, но никаких подсказок от Telecide или определителя
 полей (tfm) не обнаружено в видео потоке, тогда на всех кадрах будет удалена
 чересстрочность (TDeint будет работать как будто hints=false). <BR>
 Если вы явно не определяете значение для hints, то TDeint будет проверять, есть
 ли подсказки в потоке при загрузке и установит hints в true, если они есть, или
 в false, если их нет (т.е. это устанавливается автоматически). </p>
<P> *ПРИМ.: для постобработки обратного преобразования телекино (IVTC) при чтении
 подсказок рекомендуется использовать TDeint в следующем режиме, задействуя параметр
 clip2. </P>
<pre>orig = last
fieldmatcher()
TDeint(clip2 = last)</pre>
<p>true - читать подсказки, если есть<br>
 false - не читать подсказки</p>
<p>по умолчанию - определяется автоматически при загрузке (bool)</p>
<p><var>clip2</var>:</p>
<p>При использовании tdeint как постпроцессора для Telecide или определителя полей (tfm)
 посредством параметра hints (или любого обнаружителя совпадений полей),
 неправильное удаление чересстрочности может произойти из-за того, что
 Telecide изменяет порядок полей в исходном потоке (ведь он - обнаружитель совпадений
 полей в конце концов). Это может вызвать в некоторых случаях проблемы, поскольку
 TDeint действительно нуждается в исходном потоке. Чтобы обойти это, вы может
 определить для TDeint второй клип "clip2", чтобы делать фактическое удаление
 чересстрочности из него.</p>
<p>Вот как это бы работало в сценарии:</p>
<pre>mpeg2source(&quot;c:\mysource.d2v&quot;)
orig = last
telecide(guide=1, order=1, hints=true, post=1)
tdeint(order=1, clip2=orig)</pre>
<p>Итак, TDeint читает выходной клип из Telecide как обычно. Когда подсказки указывают,
 что кадр интерлейсный, он делает деинтерлейсинг данного кадра, используя clip2.
 Этот метод также сохраняет подсказки в выходном потоке, так что любые другие
 фильтры, которые нуждаются в них впоследствии, будут по-прежнему работать.</p>
<p>Добавив full=false, можно по-другому использовать TDeint как постпроцессор,
 заставив его использовать свое собственное обнаружение кадров с эффектом &quot;гребенки&quot;,
 следующим образом (это также позволяет ему работать с любым обнаружителем совпадений
 полей, не только Telecide или tfm):</p>
<pre>mpeg2source(&quot;c:\mysource.d2v&quot;)
orig = last
fieldmatcherofchoice()
tdeint(order=1, full=false, clip2=orig)</pre>
<p>по умолчанию - NULL  (PClip)</p>
<p><var>full</var>:</p>
<p>Если full установлено в true (истина), то все кадры обрабываются как обычно.
 Если full=false, все кадры сначала проверяются есть ли у них гребенка. Если кадр
 без гребенки, он возвращается как есть. Если кадр имеет гребенку, тогда он обрабывается
 как обычно. Параметры, которые влияют на обнаружение кадров с гребенкой, это
 cthresh, chroma, blockx, blocky и MI. Full=false разрешает TDeint быть постпроцессором
 обратного преобразования телекино (IVTC) без потребности в подсказках.</p>
<p>true - нормальная обработка<br>
 false - сначала проверить все входные кадры на эффект &quot;гребенки&quot;</p>
<p>по умолчанию - true  (bool)</p>
<p><var>cthresh</var>:</p>
<p>Порог области с гребенкой, используемый для обнаружения кадров с эффектом &quot;гребенки&quot;.
 Он похож на dthresh или dthreshold в telecide () и fielddeinterlace (). Это существенным
 образом определяет насколько "сильной" или "видимой" должна быть гребенка, чтобы
 ее обнаружили. Хорошие значение - от 6 до 12; если вы знаете, что ваш источник
 имеет много кадров с гребенкой, установите это значение пониже (6-7), если вы
 знаете, что ваш источник имеет совсем мало кадров с гребенкой, установите его
 повыше (10-12). Значения намного ниже 5-6 или намного выше 12 не рекомендуются.
</p>
<p>по умолчанию - 6  (int)</p>
<p><var>blockx</var> -</p>
<p>Устанавливает размер по оси X блока, используемого для обнаружения кадров с
 гребенкой. Это имеет отношение к размеру области, в которой должно быть найдено
 количество MI пикселов с гребенкой, чтобы кадр был объявлен как имеющий гребенку.
 См. описание параметра MI для дальнейшего объяснения. Возможные значения - любое
 число, которое является степенью числа 2, начиная с 4 и до 2048 (т.е. 4, 8, 16,
 32... 2048).</p>
<p>по умолчанию:  16  (int)</p>
<p><var>blocky</var> -</p>
<p>Устанавливает размер по оси Y блока, используемого для обнаружения кадров с
 гребенкой. Это имеет отношение к размеру области, в которой должно быть найдено
 количество MI пикселов с гребенкой, чтобы кадр был объявлен как имеющий гребенку.
 См. описание параметра MI для дальнейшего объяснения. Возможные значения - любое
 число, которое является степенью числа 2, начиная с 4 и до 2048 (т.е. 4, 8, 16,
 32... 2048).</p>
<p>по умолчанию:  16  (int)</p>
<p><var>chroma</var>:</p>
<p>Использовать гребенку по цветности (chroma combing) при принятии решения о
 том, имеет ли кадр гребенку. Используйте это только если у вас один из тех странных
 источников, где цветность может быть во временном отношении отделена от яркости
 (т.е. по полю цветность сдвигается, а яркость - нет). Иначе при принятии решения
 это принесет в большинстве случаев лишь вред.</p>
<p>true - использовать гребенку по цветности<br>
 false - не использовать</p>
<p>по умолчанию - false  (bool)</p>
<p><var>MI</var>:</p>
<p>количество пикселов с гребенкой в кадре для любого блока размером blockx на
 blocky, чтобы этот кадр был определен как имеющий гребенку. В то время как cthresh
 контролирует насколько "видимой" или "сильной" должна быть гребенка, этот параметр
 определяет насколько много &quot;гребенчатости&quot; должно быть в любой определенной
 области (блок размером blockx на blocky) кадра. Миним. значение = 0, максимальное
 = blockx на blocky (точка, в которой никакие кадры уже не будут никогда определяться
 как имеющие гребенку).</p>
<p>по умолчанию - 64  (int)</p>
<p><var>tryWeave</var>:</p>
<p>Если установлено в true (истина), то когда TDeint удаляет чересстрочность в
 кадре, он сначала вычислит какое поле (ПРЕДЫДУЩ. или СЛЕД.) наиболее подобно
 текущему полю. Затем он присоединит это поле (weave), чтобы создать новый кадр
 и проверить этот новый кадр на наличие гребенки. Если новый кадр - без гребенки,
 тогда его он и возвратит. Если кадр - с гребенкой, то у кадра удаляется чересстрочность
 с использованием обычной компенсации движения по пикселам. В основном, этот параметр
 позволяет TDeint попробовать использовать компенсацию движения по полям, а не
 по пикселам там, где это возможно.</p>
<p>по умолчанию - false  (bool)</p>
<p><var>link</var>:</p>
<p>Контролирует во время создания карты гребенки (comb map), как связаны три плоскости
 (YUV). Возможные значения:</p>
<p>0 - не связаны<br>
 1 - полное сцепление (каждая плоскость с любой другой)<br>
 2 - Y с UV (яркость с цветностью)<br>
 3 - UV с Y (цветность с яркостью) </p>
<p>по умолчанию - 2 (int)</p>
<p><var>denoise</var>:</p>
<p>Контролирует, удаляется ли шум из карты гребенки или нет. True включает удаление
 шума, false - отключает.</p>
<p>по умолчанию - true  (bool)</p>
<p><var>AP</var>:</p>
<p>Порог защиты артефактов. Если AP установлен в значение большее или равное 0,
 то перед выводом кадра с удаленной чересстрочностью TDeint просканирует все объединенные
 пикселы, чтобы увидеть, порождает ли какой из них значение, большее чем AP. Любые
 пикселы, которые дают такое значение, будут интерполированы. Используйте это
 для помощи в предотвращении очень очевидных артефактов, порожденных компенсацией
 движения, рекомендуются большие значения (25+, или такие, какие удаляют артефакты,
 видимые во время проигрывания на полной скорости), поскольку меньшие значения
 уничтожат выгоды от компенсации движения в статических, богатых деталями областях.
 Система измерения AP та же, что и для cthresh, так что диапазон - 0-255... при
 ноле всё, кроме полностью плоских областей будет выявлено как имеющее гребенку,
 при 255 - ничего не будет выявлено. Использование AP замедлит обработку. Чтобы
 отключить AP, установите его значение в меньше 0 или больше 254.</p>
<p>по умолчанию - -1 (отключено) (int)</p>
<p><var>APType</var>:</p>
<p>Когда используется AP-постобработка (AP >= 0 и &lt; 255), APType контролирует
 должно ли приниматься во внимание движение окружающих пикселов. Есть 3 возможных
 значения:</p>
<p>0 = Не принимать во внимание близлежащее движение. Если объединенный пиксел
 дает величину, которая превышает AP-порог, тогда он будет интерполирован.</p>
<p>1 = Если объединенный пиксел дает величину, которая превышает AP-порог, и по
 крайней мере половина пикселов в блоке 5x5 с этим пикселом в центре определяются
 как движущиеся, тогда этот пиксел будет интерполирован.</p>
<p>2 = Точно как 1, за исключением того, что вместо 1/2 лишь 1/3 пикселов в окружающем
 блоке 5x5 должны определяться как движущиеся.</p>
<p>Режимы 1 и 2 предоставляют способ для того, чтобы &quot;прихватить&quot; больше
 артефактов (низкие значения AP) без полного принесения в жертву статических областей.</p>
<p>по умолчанию -  1  (int)</p>

<p><var>edeint</var>:</p>


<p>Позволяет указать внешний клип, чтобы брать оттуда интерполированные пикселы,
 вместо того, чтобы TDeint использовал один из его встроенных методов интерполяции.
 Если клип указан, то TDeint обрабатывает всё как обычно за исключением того,
 что вместо вычисления интерполированных пикселов самостоятельно, он будет брать
 необходимые пикселы с соответствующих мо местоположению позиций того же кадра
 из клипа edeint. Чтобы отключить использование клипа edeint, просто не указывайте
 значения для edeint.</p>
<p>по умолчанию - NULL (PClip)</p>

<p><var>emask</var>:</p>


<p>Позволяет указать внешний клип, чтобы брать оттуда маску движения, вместо того,
 чтобы TDeint строил маску сам. Использование этой опции делает следующие параметры
 TDeint не оказывающими никаго влияния: mthreshL, mthreshC, mtnmode, denoise,
 link. Возможные значения, которые могут присутствовать в кадрах маски движения,
 определены так:</p>
<p>10 - Использовать пиксел из текущего кадра<br>
 20 - Использовать пиксел из предыдущего кадра<br>
 30 - Использовать пиксел из следующего кадра<br>
 40 - Использовать среднее пикселов из текущего и следующего<br>
 50 - Использовать среднее пикселов из текущего и предыдущего<br>
 60 - Интерполировать<br>
 70 - Использовать [1 2 1] смесь пикселов из пред/текущ/следующ<br>
 Поведение для других значений неопределено, хотя другие значения должны отсекаться,
 рассматриваясь внутренне так, как если бы они были равны 60.</p>

      <p>по умолчанию -  NULL (PClip)</p>

<p><var>blim</var>:</p>


<p>Задает величину максимальной разности для режима 2. Если обе разности (иточник-предыдущ.
 и источник-следующ.) выше этой величины, тогда источник возвращается как есть.
 Иначе источник смешивается либо с предыдущ. либо со следующ., в зависимости от
 того, что из них наиболее подобно источнику. Эта величина находится в пределах
 от 0.0 до 100.0, базируясь на различии канала яркости. Используйте debug=true,
 чтобы увидеть значения порожденных различий и предельную величину. Отладочные
 выходные данные будут выглядеть так:</p>
<pre>[5776] TDeint:  frame 0:  d1 = 0  d2 = 0  lim = 1513728</pre>
<p>d1 - это разность иточник-предыдущ., а d2 - разность иточник-следующ. lim -
 это максимальное значение, преобразованное из плавающего числа в длинное целое
 без знака. Установите blim в отрицательную величину для отключения сопоставления
 (источник всегда будет смешиваться или с предыдущ. или со следующ.).</p>


      <p>по умолчанию -  -2.0  (float)</p>

<p><var>metric</var>:</p>


<p>Задает, какая пространственная система измерения гребенчатой фильтрации (combing
 metric) используется для обнаружения пикселов с гребенкой. Возможные значения:</p>
<p> Предположим, 5 соседних пикселов (a,b,c,d,e) размещены вертикально. </p>
<p>

                    a<br>
                    b<br>
                    c<br>
                    d<br>
                    e<br>
<pre>            0:  d1 = c - b;
                d2 = c - d;
                если ((d1 > cthresh && d2 > cthresh) || (d1 < -cthresh && d2 < -cthresh))
                {
                   если (abs(a+4*c+e-3*(b+d)) > cthresh*6) значит с гребенкой;
                }

            1:  val = (b - c) * (d - c);
                если (val > cthresh*cthresh) значит с гребенкой;
</pre>
<p> Система измерения 0 - это та, которую tdeint всегда использовал до v1.0 RC7.
 Система измерения 1 - это система измерения гребенчатой фильтрации применяемая
 в функциях FieldDeinterlace()/IsCombed() Дональда Графта в decomb.dll.</p>

     <p>по умолчанию:  0  (int)</p>


<p><var>opt</var>:</p>


<p>Определяет, какой тип оптимизации ЦПУ используется. Возможные значения:</p>


<p>0 - использовать C функции<br>
 1 - использовать mmx функции<br>
 2 - использовать isse функции<br>
 3 - использовать sse2 функции<br>
 4 - автоопределение</p>

      <p>по умолчанию -  4  (int)</p>

<h2>История</h2>
<p>04/10/2006 v1.0 RC7<BR>
 + оптимизированы функции обнаружения кадров с гребенкой (теперь соответствуют
 tivtc)<BR>
 + добавлена вторая система пространственного измерения гребенчатой фильтрации
 и параметр "metric" (такой же, как tfm и is/showcombeditvtc)<BR>
 + оптимизированы функции удаления шума<BR>
 + улучшена функция сравнения полей (теперь одинакова со slow=0 в tfm)<BR>
 + режим 2 использует функцию сравнения полей вместо вычитания полного кадра при
 определении наиболее совпадающего кадра (точнее)<BR>
- напрямую назначаются кадры из клипа emask (нет необходимости копировать)<BR>
 - значение blim по умолчанию изменено на -2.0 (выключено)<BR>
- вызывается setcachehints для клипов emask/edeint, в случае использования
</p>
<p>Изменения более ранних версий см. в английском оригинале документации</p>

<p><kbd>$English Date: 2006/09/18 19:02:03 $<br>
Русский перевод: 22.09.2006-03.10.2006 <B>Soroka</B> (lyakh (at) iname com)</KBD></p>

</body>
</html>