<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML lang="ru">
<head>
<title>Фильтр FDecimate для Avisynth</title>
<meta content="text/html;charset=windows-1251" http-equiv="Content-Type">
<link rel="stylesheet" type="text/css" href="../../avisynth.css">
<!--
Automatically generated, don't change:
$Id: fdecimate.htm,v 1.3 2006/12/30 23:18:46 fizick Exp $
-->
</head>

<body>
<h1>FDecimate</h1>
<h2>Общая информация</h2>
<b>автор:</b> Donald A. Graft
<br><b>версия:</b>  1.0.1<br>
<b>загрузка:</b> <a href="http://neuron2.net/mine.html">http://neuron2.net/mine.html</a><br>
<b>категория:</b> Деинтерлейс &amp; удаление Pulldown<br>
<b>требования:</b>  YV12 &amp; YUY2 цветовые форматы<hr>
<h3>Вступление</h3>
Фильтр FDecimate() позволяет производить удаление дублирующихся кадров, имея при этом более широкие возможностями
нежели фильтр Decimate(). Он может удалять кадры из клипа, достигая желаемой частоты кадров,
пока сохраняется аудио/видео синхронизация. Желательно удалять кадры там, где это возможно.
(FDecimate() основывается на "Свободном прореживании", предполагающем, что итоговая частота кадров может быть свободно
выбрана, не ограничиваясь прореживанием 1-на-N).
<p>
Всё чаще встречаются приложения (и клипы), где традиционного прореживания 1-на-N не хватает для получения желаемого
результата. Четыре из них рассмотрим здесь более детально.
<p>
Первое - телевидение высокой четкости (HDTV), часто распространяется с удвоенным частотой кадров, т.е.
59.94 fps для ATSC. Прогрессивный фильм, изначально имевший частоту кадров 24, может быть превращён в
HD дублированием кадров согласно шаблону (pattern). К примеру, для получения 60 из 24 fps мы можем использовать такой шаблон:
<p>
A A A B B C C C D D E E E F F ...
<p>
Мы называем это 3232... шаблоном дублирования кадров. Другой пример - преобразование с 25 до 60 fps,
использующее 3232232322... шаблон. Преобразование из 60 fps до широковещательных 59.94 fps может
быть достигнуто замедлением видео и соответствующей подгонкой аудио, либо исключением одного
дублирующегося кадра из каждых 1000 кадров. В любом случае, наш финальный поток имеет много
дублированных кадров и традиционное 1-на-N прореживание не может больше помочь.
Иногда, несколько последовательных 1-на-N прореживаний могут помочь, но это громоздко.
И хотя Decimate(mode=2) может быть полезен с многочисленными дублирующимися кадрами, но не во всех случаях.
<p>
Второе - аниме, часто создаётся с 12 fps и превращается в 29.97 дублированием кадров, описанным выше способом.
Результат такой же: поток с большим кол-вом дубликатов, на котором, скорей всего, не поможет 1-на-N прореживанию.
<p>
Третье - многие немые фильмы перекодируются в DVD добавлением дублирующихся полей необычными шаблонами,
потому что оригинальная частота кадров была не 24 fps. Необычно видеть видео, требующее странное прореживание,
как, например, 20 на 43. Иногда такие странные прореживания могут быть достигнуты или почти
достигнуты через повторение функции Decimate(), используя разные циклы, но это громоздкий метод,
который не всегда даст то прореживание, которое требуется.
FDecimate() позволяет устанавливать произвольная частота кадров для последовательного восстановления
исходной частоты кадров этого немого фильма.
<p>
Четвёртое - иногда клипы создаются с частотой кадров 120, чтобы точно представить гибридые клипы с кино и видео.
Если Вы хотите вернуть нормальная частота кадров, Вам нужно удалить многочисленные дубликаты.
<p>
Фильтр FDecimate() помогает в таких ситуациях. Ранний фильтр MultiDecimate() также мог помочь,
но его двухпроходная реализация требует дополнительную внешнюю программу - неуклюжий метод.
Также, при не очень аккуратном использовании, это может приводить к аудио рассинхронизации.
Я считаю, что FDecimate() является более предпочтительным решением.
<p>
Пожалуйста, учитывайте, что при использовании FDecimate() для традиционного 1-на-N прореживания,
 возможно, более  предпочтительно остановиться на обычном Decimate(), потому что он
 не требует установки порога при поиске дубликатов в режиме mode=0.<p>
Эта версия поддерживает цветовые пространства YUY2 и YV12 и предназначена для Avisynth 2.5.
<p>
Если Вы удивлены, как FDecimate() отличается от внутреннего фильтра ChangeFPS() из Avisynth,
ответ заключается в том, что FDecimate() может предпочтительно оставлять уникальные кадры,
по возможности убирая дубликаты.
<p><hr>
<h3>Как использовать FDecimate()</h3>
Чтобы добиться хороших результатов, очень важно выставить правильную выходную частоту кадров
 и установить порог для правильного определения дубликатов. Давайте сначала обсудим итоговую частоту кадров.
<p><b><i>Определение итоговой частоты кадров.</i></b> Если Вы хотите получить известную итоговую частоту кадров,
то можете просто установить параметр 'rate' для этого.  Например, Вам известно, что источником
был фильм с 24 кадрами в секунду. Но часто встречаются клипы с "неоднородным" шаблоном дублирования
и неизвестно, что сделать, чтобы узнать какой&nbsp; должна быть итоговая частота кадров.
Это частый случай при обработке немого кино.<p>
Исходную частоту кадров можно определить, используя следующую процедуру.
Найдите кусок длиной около 10 секунд, содержащий постоянное движение.
Пройдитесь пошагово по видео без прореживания и запишите шаблон дублирования. Например, Вы можете увидеть это:
<p><tt><pre>новый кадр и за ним следует его дубликат
новый кадр
новый кадр и за ним следует его дубликат
новый кадр
новый кадр и за ним следует его дубликат
новый кадр
...</pre></tt>
<p>
Я бы условно записал это как: 212121... Теперь вам нужно определить кол-во уникальных кадров
из общего числа кадров. Для повторяющегося шаблона 212121 это кол-во соответствует 2/3.
Вы можете не увидеть повторяющийся шаблон, но это и не обязательно.
Просто посчитайте число уникальных кадров в 10 секундном промежутке
и поделите на общее число кадров в этом промежутке.
<p>
Далее, Вы умножаете полученное число (пропорцию) на число кадров в оригинальном клипе.
Это даст итоговую частоту кадров клипа после удаления дубликатов. Вы можете получить странную частоту кадров,
не являющуюся стандартной. Если Вы будете просматривать это видео на компьютерном мониторе,
 то можете использовать эту странную частоту кадров, потому что компьютер будет
 способен воспроизвести его. Но если Вашей целью является просмотр на телевизоре,
 то лучше округлить частоту кадров до ближайшей стандартной. Смотрите следующую секцию
 "Почему FDecimate() не может быть совершенным, и что можно с этим сделать"
 для ответов на некоторые будущие вопросы о выбираемой частоте кадров.<p>
<b><i>Определение порога 'Threshold' для определение дубликатов</i></b>. Если клип не содержит дубликатов,
и Вы хотите просто проредить его для снижения частоты кадров, тогда этот шаг не применяйте и
выставьте параметр 'threshold' равным 0 (threshold=0). Если в клипе есть дубликаты и
Вы хотите убрать их "совершенно", тогда FDecimate() нужен метод для определения, какие кадры являются дубликатами.
<p>Действия следующие. Примените фильтр FDecimate() с включенными метриками:<pre><tt>FDecimate(metrics=true)</tt></pre>
<p>
Отобразятся различные метрики для каждого кадра (прореживание не производится при metrics=true).
Рассмотрите метрики для дублирующихся кадров. Вам нужно найти такое число, чтобы метрика для
всех дубликатов была ниже его (числа), а метрика новых кадров была выше его.
Это число и будет порогом, в который и нужно установить параметр 'threshold'.
Как правило, это число в пределах 1.0-2.5, но может отличаться, в зависимости от шумности вашего клипа.
Очень важно получить точные значения для этого порога, поэтому будьте осторожны,
исследуя несколько секций вашего клипа.<p>
<b><i>Производство прореженного видео</i></b>. Когда определены итоговая частота кадров
и порог определения дубликатов, очень просто получить прореженное видео.
При условии целевой частоты кадров в 20.8 fps и порога в 2.1, Вы просто вызываете FDecimate()
с такими параметрами:<pre><tt>FDecimate(rate=20.8,threshold=2.1)</tt></pre>
<p><hr>
<h3>Почему FDecimate() не может быть совершенным, и что можно с этим сделать</h3>
Вы можете заметить, что FDecimate() работает не безупречно на некоторых ваших фильмах.
Например, он может оставить дубликат. Люди иногда считают, что результат будет совершенным,
но после обдумывания над этим, мы понимаем, что совершенство не возможно,
 т.к. нам нужно сохранить аудио/видео синхронизацию.<p>
Идея "совершенства" состоит в простом пропуске дубликатов. Этот процесс удачен –
аудио/видео синхронизация сохранена – в случае неизменности шаблона дублирования на всем видео.
 Но если шаблон непостоянен (а это часто так), синхронизация может теряться. Чтобы увидеть почему -
 рассмотрим такой шаблон дублирования (встречающийся в HD клипах):<p>
<tt>...3232323232321222212232323232...</tt>
<p>
Большинство времени клип, как 323232..., что предполагает 24 fps в прореженном клипе
(частота кадров источника 59.94 fps). Но в середине шаблона число дубликатов падает на некоторое время,
что означает ускорение базовой частоты кадров. Если мы просто уберем все дубликаты
и оставим уникальные кадры, тогда проигрывание середины будет слишком медленным для 24 fps.
Помните, что аудио синхронизируется с видео до прореживания, так что при проигрывании
рассинхронизация будет со временем увеличиваться. Фактически, вышеуказанный шаблон
будет выкидывать 200 миллисекунд синхронизации, а это много. Так прореживание может привести
в результате к выпадению многих секунд!
<p>
(Другая проблема идеи простого удаления дубликатов заключается в наличии статичных сцен,
где нет движения. Мы не хотим выкидывать их (дубликатов - прим. переводчика)!
Их можно находить и сохранять, но это дополнительные сложности. Из описанного выше вытекает
серьёзная проблема синхронизации.)
<p>
Таким образом, мы увидели, что при наличии изменений частоты кадров из-за нерегулярности
 шаблонов дубликатов, мы потеряем аудио/видео синхронизацию, если попытаемся использовать
 "совершенный" метод прореживания. Всё, что мы можем сделать, это определиться с постоянным
 выходным частотой кадров, предпочитая оставлять уникальные кадры, по возможности без дубликатов.
  FDecimate() использует такой подход.
<p>
Если у нас такой клип, в котором присутствуют случайные секции, где кол-во дубликатов уменьшается,
мы можем пропустить хорошие кадры (уникальные) при произведении прореживания.
Таким образом, могут появиться рывки в выходном видео. Что с этим можно сделать?
Мы можем только констатировать факт, что дополнительные дубликаты менее заметны, чем пропускаемые кадры.
Если мы установим выходную частоту кадров выше, то оставим больше кадров из источника,
уменьшая тем самым шанс пропуска уникальных кадров. Конечно, этим мы оставим больше дубликатов,
но это менее нежелательно.
Например, в HD клипе, описанном выше, я установил частоту кадров в 30 fps вместо 24 fps и
получил более сносный результат, по крайней мере, это стандартная выходная частота кадров.
<p>Для законченности я добавлю эти пояснения. Возможно, что описанные выше колебания частоты
кадров могут быть двусторонними, т.е. иногда оригинальная частота кадров уменьшается,
иногда - повышается. Вот пример:
<p>
<tt>32323232222222323232323333333332323232323...</tt>
<p>Теоретически, мы можем попытаться провести совершенное прореживание (как указано выше)
и сохранить итоговый трек без аудио/видео рассинхронизации.
Насколько долго рассинхронизация остаётся в приемлемых пределах, на таком промежутке времени
мы можем получить "совершенный" результат. Если рассинхронизация выходит за пределы,
мы вынуждены пропустить или сделать дубликат кадра. Проблема этого подхода в том, что на практике
мы никогда не увидим такого клипа. Мы видим клип с определенной базовой (настоящей, оригинальной)
 частотой кадров, пронизанный ее резкими повышениями (т.е., короткие периоды, когда не так много
 дубликатов как предполагалось шаблоном).<p>
Я уверен, что не существует идеального решения для клипов с случайными вариациями базовой частоты.
Несмотря на это, я думаю, что ещё есть вещи, которыми можно улучшить его (FDecimate() - прим. переводчика).
Пожалуйста, не стесняйтесь, если у Вас есть идеи по улучшению FDecimate().
<p><hr>
<h3>Параметры FDecimate()</h3>
Синтаксис FDecimate() (замените <i>список_параметров</i> на свой, разделяя запятыми параметры):
<p>
<tt>FDecimate(<i>список_параметров</i>)</tt>
<p>
Например:
<pre><tt>FDecimate(rate=23.976,threshold=0.8,show=true)</tt></pre>
<p><hr><p>
<b><i>rate</i></b> (float, default 23.976). Этот параметр устанавливает желаемую выходную частоту кадров.
Кадры будут удаляться из видео, добиваясь этой частоты кадров, пока сохраняется аудио/видео синхронизация.
<p>
<b><i>threshold</i></b> (float, default 1.0). Этот параметр устанавливает порог разницы метрик
для определения дубликатов. Смотрите секцию "Как использовать FDecimate()" выше, для понимания,
как использовать эти параметры при установки подходящего порога.<p>
<b><i>metrics</i></b> (true/false, default false). Этот параметр используется для определения
требуемого порога при нахождении дубликатов. Когда он установлен в true, прореживания не происходит,
и различные метрики показываются для каждого кадра, накладываясь на видео и через вывод в DebugView.
Смотрите секцию "Как использовать FDecimate()" выше, для понимания, как использовать эти параметры
при установке подходящего порога.<P>
<b><i>show</i></b> (true/false, default false). Этот параметр разрешает, чтобы на кадре отображалась информация.
Также отображается версия программного обеспечения.<p>
<b><i>debug</i></b> (true/false, default false). Этот параметр разрешает вывод информации
через OutputDebugString(). Утилита  DebugView позволяет захватывать эти строки.
Информация отображается так, как указано опцией show.<p>
<hr>
<h3>Изменения параметров по умолчанию для FDecimate()</h3>
<p>Если Вам не нравятся базовые значения, описанные выше, то можете установить свои базовые значения.
Чтобы переписать базовые значения, нужно создать файл "умолчания" в папке плагинов для Avisynth'а.
Например, для установки базового значения threshold=2.0 для  FDecimate() создайте файл
с именем FDecimate.def и напишите туда это:</p>

<p>threshold=2.0</p>

<p>Вы можете переопределить столько значений параметров, сколько захотите, по одному в строке.
 Не переопределенные примут значения, указанные выше.
 Конечно, Вы можете всегда переопределить базовые значения на свои при вызове функции.
ПРИМЕЧАНИЕ: Строки в FDecimate.def не должны содержать пробелов или символов табуляции.</p>
<p><hr><p>
Copyright (C) 2004, Donald A. Graft, All Rights Reserved.
<p>
Для обновлений и других фильтров/приложений, посетите мой сайт:<br>
<a href=http://neuron2.net/>http://neuron2.net/</a>
<p><kbd>$Date: 2006/12/30 23:18:46 $<br>
Русский перевод 30.11.2006 <a href=http://scif.net.ru>SCIF</a><br>
Редакция 31.12.2006 Fizick http://avisynth.org.ru</kbd></p>
</body>
</html>