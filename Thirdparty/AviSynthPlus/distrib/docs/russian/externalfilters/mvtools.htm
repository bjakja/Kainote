<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="ru">
<head>
  <title>MVTools</title>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1251">
  <link rel="stylesheet" type="text/css" href="../../avisynth.css">
<!-- Automatically generated, don't change:
$Id: mvtools.htm,v 1.4 2006/09/17 17:41:38 fizick Exp $
-->
</head>
<body>
<h1>MVTools</h1>
<h2>Общая информация</h2>
<b>Авторы:</b>Manao и Fizick<br>
<b>Версия:</b> 1.4.11<br>
<b>Загрузка:</b> <a href="http://avisynth.org.ru/">http://avisynth.org.ru/</a><br>
<b>Категория:</b> плагины разного назначения (Misc Plugins)<br>
<b>Требования:</b> YV12, YUY2 цветовые форматы (Colorspace)
<hr>
<h2>Содержание:
</h2>
<ul>
  <li><a href="#mvtools">I) О MVTools</a></li>
  <li><a href="#functions">II) Описания функций</a></li>
  <li><a href="#examples">III) Примеры</a></li>
  <li><a href="#disclaimer">IV) Отказ (от гарантий, Disclaimer) (не
игнорируйте эту часть, хоть мы и не настаиваем на ее изучении)</a></li>
  <li><a href="#revisions">V) Ревизии</a></li>
</ul>
<h2><a name="MVTools"></a>I) О MVTools</h2>
<p>MVTools плагин для AviSynth 2.5 - это коллекция функций
для оценки и компенсации движения объектов в видео клипах.
Компенсация движения может быть использована для сильного временного понижения шума,
продвинутых преобразований частоты кадров, реставрации изображений и других задач.
</p>
<p>Плагин содержит серверную функцию оценки движения MVAnalyse (сервер) для нахождения векторов движения
и несколько клиентских функций компенсации движения (MVDenoise, MVCompensate, MVMask и других),
которые используют эти векторы.
</p>
<p>Плагин использует метод сличения блоков (block-matching) для оценки движения
(подобные методы используются в MPEG2, MPEG4 и т.д).
На стадии анализа плагин разделяет кадры на малые блоки и пробует найти для каждого блока в текущем кадре
наиболее подобный (соответствующий) блок во втором кадре (предыдущем или последующем).
Относительное смещение этих блоков и есть вектор движения.
Основной мерой подобия блоков является сумма абсолютных разностей (SAD) всех пикселов этих двух сравниваемых блоков.
SAD это величина, показывающая, насколько хороша оценка движения.
</p>
<p>Выходом функции MVAnalyse является специальный клип с информацией о векторах движения в некотором формате.
</p>
<p>На стадии компенсации клиентские функции плагина читают вектора движения и используют их,
чтобы передвинуть блоки и сформировать кадр с компенсированным движением
(или реализуют какую-либо другую функцию полной или частичной  компенсации или интерполяции).
Каждый объект (блок) в этом (полностью) скомпенсированном кадре помещен в ту же позицию, как этот объект
в текущем кадре. Таким образом, мы можем (например) использовать сильное временное понижение шума
даже для достаточно быстро движущихся объектов без производства раздражающих артефактов и призраков
(особенности и края объектов совпадают, если компенсация совершенна).
Плагин может создать компенсированные соседние кадры для каждого текущего кадра и снизить его шума с помощью
внутренней функции MVDenoise.
Альтернативно, вы можете использовать использовать компенсированные кадры, чтобы создать клип с их чередованием,
понизить его шум с использованием любого внешнего фильтра,
и выбрать для выхода центральные очищенные кадры (смотри примеры).
</p>
<p>Конечно, оценка  компенсация движения не идеальна и не точна.
В некоторых сложных случаях (видео с затуханием, сверх-быстрым движением, периодическими структурами)
оценка движения может быть полностью неверна, и компенсированный кадр будет блочным и (или) уродливым.
Трудности также представляют заслонение одного объекта другим или наоборот, открытие.
Сложные AviSynth скрипты со многими функциями компенсации движения могут съесть огромное количество памяти
и привести к очень медленной обработке.
Это не простой, а достаточно сложный плагин. Используйте его только для подходящих случаев,
и попытайтесь настроить его параметры.
Есть много обсуждений по поводу использования компенсации движения на (англоязычном) форуме doom9 по AviSynth.
В частности <a href="http://forum.doom9.org/showthread.php?s=&threadid=76041">ветка MVTools.</a>
Попробуйте почитать сообщения как дополнения к данной документации и спрашивайте там поддержку.
Если вы действительно заинтересовались вопросами оценки и компенсации движения,
вы легко найдете многочисленные научные публикации (используйте WWW поиск).
</p>
<p>Замечания. Данный плагин еще в стадии разработки. Текущая версия имеет некоторые ограничения.
Поддерживается только прогрессивное видео цветового формата YV12, YUY2.
Используйте преобразование цветовых форматов и попробуйте использовать (разумный) BOB-деинтерлейс
для чересстрочного видео.
</p>


<h2><a name="functions"></a>II)Описания функций </h2>

<h3>Общие параметры</h3>
<p>Фильтры, использующие вектора движения (MV), имеют ряд общих параметров.
Это пороги детектирования сцен и флаги использования mmx/isse. Кроме
того фильтры используют один или несколько потоков векторов.
</p>
<var>int thSCD1</var>: порог определения,
изменился ли блок в
текущем кадре относительно предыдущего. Если блок изменился, для меня
это значит, что предварительный прогноз движения для него в целом
некорректен. Это происходит, например, при смене сцен. То есть это один
из порогов, используемых для отладки механизма детектирования смены сцен.
Его увеличение уменьшит количество блоков,
определяемых как измененные. Это может быть полезно для шумного или мерцающего видео.
Порог сравнивается со значением SAD (Sum
of Absolute Differences - суммой абсолютных различий, значение,
говорящее о качестве рассчитываемого прогноза движения).
Предположим мы имеем два сравниваемых блока 8х8 с каждым из пикселов отличающихся на 5.
В этом случае SAD будет 8x8x5 = 320 (блок будет зарегистрирован как неизменившийся при thSCD1=400).
Если используются блоки 4x4, величина SAD будет  320/4.
Если используются блоки 16x16, величина SAD будет 320/4.
На самом деле этот параметр масштабируется внутренне,
и Вы должны всегда использовать величину, приведенную к размерам блока 8x8.
По умолчанию задано 400 (с версии 1.4.1).
<p><var>int thSCD2</var>: порог, задающий количество блоков, которые
должны измениться, чтобы принять решение о смене сцен. Его диапазон
0...255, 0 соответствует 0 %, 255 - 100 %. По умолчанию задано 130 (что
соответствует 51 %).</p>
<p><var>bool isse</var> : флаг, установка в false позволяющий
отключить ISSE и MMX оптимизацию для отладки. По умолчанию: true. Если Ваш процессор не
поддерживает mmx оптимизацию, она все равно будет отключена
(и активировать ее не удастся)</p>
<p><var>bool mmx </var>: флаг, позволяющий отключить mmx
оптимизацию.
По умолчанию: true. Данный параметр игнорируется в текущей и всех (?) предыдущий версиях.</p>

<h3>MVAnalyse</h3>
<code>MVAnalyse</code> (<var>clip, int "blksize", int "pel", int "level", int "search",
int "searchparam", bool "isb", int "lambda", bool "chroma", int "delta", int "idx",
bool "truemotion", int "lsad", int "pnew", int "plevel", bool "global", int "overlap",
string "outfile", int "sharp"</var>)
<p> Оценивает движения методом сличения блоков
и производит специальный выходной клип с данными по векторам движения
(используемыми другими программами).<br>
Реализованы некоторые иерархические многоуровневые методы поиска (от грубого масштаба изображения к тонкому).
Функция использует нулевой вектор и векторы соседних блоков как предикторы (начальные приближения) для текущего блока.
Сначала оценивается разница (SAD) для предикторов,
затем пробный вектор изменяется на некоторую величину в некотором направлении,
оценивается SAD, и так далее.
Принятый новый вектор для блока - это вектор с минимальной разностью (SAD)
(с некоторой поправкой-штрафом для согласованности движения)
</p>
<p><var>blksize</var>: Размер блока. Возможны только значения 4, 8 или
16 (по умолчанию 8). БОльшие блоки менее чувствительны к шумам, и
обрабатываются быстрее, но и менее точны.
</p>
<p><var>pel</var> : Это точность прогнозирования движения. 1 означает
точность до пикселя, 2 - до полу-пикселя. Пока возможные значения
только 1 и 2. (Теоретически рассматривались также значения 4 и 8, выше
8 задавать
бессмысленно и расходуется слишком много памяти). По умолчанию: 2 с версии 1.4.10.
</p>
<p><var>level</var>: Это количество уровней, не используемых при
иерархическом анализе во время нахождения векторов движения. Чем оно
меньше, тем лучше. Переменная оставлена для учебных (тестовых) целей.
По умолчанию: 0. <br>
</p>
<p><var>search, searchparam</var> : <var>search</var>
определяет тип поиска, и <var>searchparam</var> - дополнительные
установки для поиска:</p>
<ul>
  <li><var>search </var>= 0 : 'Однопроходный Поиск' (OneTimeSearch). <var>searchparam</var>
- шаг между каждыми пробуемыми векторами (если <var>searchparam</var>
больше 1, шаг будет постепенно уменьшаться).</li>
  <li><var>search </var>= 1 : 'N-проходный Поиск'(NStepSearch). N
задается параметром <var>searchparam</var>. Это наиболее хорошо
известный алгоритм поиска векторов движения.</li>
  <li><var>search </var>= 2 : Логарифмический поиск, также
называемый Бриллиантовый поиск (Diamond Search). <var>searchparam</var>
определяет начальный шаг поиска, и он (шаг) как и ранее, постепенно
уменьшается. Это метод
поиска по умолчанию (с параметром <var>searchparam</var> = 2).</li>
  <li><var>search</var>= 3 : Исчерпывающий поиск, <var>searchparam</var>
- это радиус. Метод медленный, но дает лучшие результаты по значению SAD.</li>
</ul>
<p><var>isb</var> : позволяет выбрать прямое направление поиска (между
текущим и предыдущим кадром) либо обратное (между текущим и последующим
кадром). <var>isb </var>= false означает прямой поиск ( <var>isb</var>
установленное в true - обратное направление поиска).</p>
<p><var>chroma</var> : установка в true позволяет учитывать и цветовую
информацию при оценке движения (false - толькоя яркостную). По умолчанию true. </p>
<p><var>delta</var> : устанавливает кадровый интервал между указанным и
текущим кадром. По умолчанию он равен 1, что означает, что вектора
движения ищутся между текущим и предыдущим
(или следующим) кадром. Установка в 2 позволит искать mvs между кадром
n и n-2 или n+2 (в зависимости от значения <var>isb</var>).</p>
<p><var>idx</var> : позволяет фильтру сохранит
производимую им
интерполяцию в течении процесса оценки движения, для последующего
повторного использования другими составляющими фильтра для того же
клипа. Это позволяет, например, при выполнении поиска вперед и назад
для того же клипа, избежать повторного расчета билинейной интерполяции
при pel = 2. По умолчанию, задается уникальное отрицательное число
(уникальное для каждого фильтра). Если вы используете его, то должны
задавать аналогичные положительные числа, и вы должны использовать
только те же значения для фильтров, работающих с тем же клипом (иначе
анализ не будет работать правильно).</p>

<p>Существуют дополнительные параметры, которые устанавливают согласованность векторов движения
для оценки так называемого истинного движения (true motion).
Некоторые найденные поиском блоки другого кадра могут быть наиболее подобны образцовым блокам
текущего блока по критерию интенсивности (SAD), но не отвечать истинному движению объекта.
Например, они могут принадлежать другому подобному объекту в дугом углу кадра,
или относиться к некоторой периодической структуре.
Параметры "истинного движения" (true motion) пытаются поддерживать поле движения согласованным, слаженным,
вместо некоторого случайного распределения векторов.
Это особенно важно для частичной компенсации и интерполяции движения.
Некоторые параметры являются экспериментальными и могут быль удалены (заменены)
из последующих версий после тестирования. Пожалуйста, сообщайте ваши заключения.
</p>
<p><var>truemotion</var> это предварительно созданный набор значений этих параметров.
Он позволяет легко переключать значения по умолчанию сразу всех параметров "истинного движения".
Установите его равным <var>true</var> для поиска истинного движения (высокой согласованности векторов),
Установите его равным <var>false</var> для поиска векторов движения с наилучшей SAD.
По умолчанию - <var>true</var> c версии v1.4.10.
В любом случае вы можете настроить каждый параметр индивидуально.</p>
<p><var>lambda</var> : устанавливает связанность (слаженность, coherence) поля векторов.
Чем выше, тем больше связанность. Однако, если задать его слишком высоким,
некоторые 'правильные' вектора движения могут быть пропущены.
Величины около 400 - 2000 (для размера блока 8х8) настоятельно рекомендуются.
Внутренне это коэффициент штрафа к SAD для квадратичной разности вектора от предиктора (соседей),
масштабированная на 256.<br>
По умолчанию 0 для <var>truemotion</var>=false и 1000*blksize*blksize/64 для <var>truemotion</var>=true.
</p>
<p><var>lsad</var>: предел SAD для использования <var>lambda</var>. Локальная <var>lambda</var> сбрасывается в 0
для предиктора вектора (сформированного из соседей) с большей чем порог величиной SAD.
Это предотвращает использование плохих предикторов, но расстраивает согласованность движения.
Величины выше 1000 (для размера блока 8) настоятельно рекомендуются для истинного движения.<br>
По умолчанию 400*blksize*blksize/64 для <var>truemotion</var>=false и 1200*blksize*blksize/64 для <var>truemotion</var>=true.
</p>
<p><var>pnew</var>: штраф к SAD стоимости для нового вектора-кандидата. SAD (стоимость) нового пробного вектора
должна быть лучше чем у предиктора на эту величину, чтобы он бы принят как новый.
Величины около 50-100 (для размера блока 8х8) рекомендуются для истинного движения.
Это предотвращает замену вполне хороших предикторов на новый вектор с немного лучшей SAD,
но другой длиной и направлением.<br>
Значение <var>pnew</var> также используется как верхний предел величины SAD предикторов для отмены дальнейшего поиска.<br>
По умолчанию 0 для <var>truemotion</var>=false и 75*blksize*blksize/64 для <var>truemotion</var>=true.
</p>
<p><var>plevel</var>:  режим масштабирования штрафного коэффициента <var>lambda</var> от уровня.
Величина =0 - без масштабирования, 1 - линейная, 2 - квадратичная зависимость от размера иерархического уровня.
Заметьте, что длина вектора меньше на более низком уровне.<br>
По умолчанию 0 для <var>truemotion</var>=false и 1 для <var>truemotion</var>=true.
</p>
<p><var>global</var>:  оценить глобальное движение (на каждом уровне) и использовать его как дополнительный предиктор.
Оценивается только панорамное смещение (ни зум, ни вращение).
Величина = false означает отменить, true - разрешить.
По умолчанию false для <var>truemotion</var>=false и true для <var>truemotion</var>=true.
</p>
<p><var>overlap</var>:  величина перекрытия блоков.  Должна быть четной и меньше размера блока
(до blksize/2 для MVCompensate).
Перекрытие происходит по вертикали и по горизонтали.
Шаг между блоками для оценки движения равен (blksize-overlap).
N блоков покрывают размер ((blksize-overlap)*N + overlap) на кадре.
Параметр экспериментальный. Попробуйте значения перекрытия от blksize/4 до blksize/2.
Чем больше перекрытие, тем больше число блоков, и меньше скорость обработки.
Величина по умолчанию 0. <br>
Функции, поддерживающие режим перекрытия: MVFlow, MVFlowInter, MVFlowFps1/2, MVShow, MVVMask, MVCompensate, MVDeGrain1/2.
</p>
<p><var>outfile</var>:  имя файла для вывода данных по векторам движения.
Эти данные могут быть использованы некоторыми внешними программами
или может быть следующими версиями MVTools для кодирования второго прохода и т.п. <br>
Протзводимый двоичный файл имеет заголовок (структура MVAnalysisData, смотри исходный код MVInterface.h),
и последовательность данных:<br>
номер кадра, данные вектора (Vx, Vy, SAD) кахдого блока,
номер следующего пригодного кадра, данные векторов этого кадра, и т.д.<br>
По умолчанию - пустая строка, не записывать файл.</p>
<p><var>sharp</var>:  метод субпиксельной интерполяции для <var>pel</var>=2. <br>
Используйте 0 для мягкой (билинейной) интерполяции, 1 для бикубической (по 4 точкам, Catmull-Rom),
2 для резкой Wiener (по 6 точкам, подобно Lanczos).<br>
По умолчанию 2.
</p>

<p>Попробуйте использовать функцию <code>MVShow</code> function для контроля оцененного поля движения
и настройки параметров.</p>

<h3>MVCompensate</h3>
<p><code>MVCompensate</code> (<var>clip,
clip "vectors", bool "scbehavior", int "mode", int "idx"</var>)
</p>
<p>Выполняет полную компенсацию движения кадра. Это означает, что блоки
указываемые векторами движения в предыдущем кадре (или последующем, в зависимости от
установок <code>MVAnalyse</code>) будут двигаться вдоль векторов с
целью достичь своих мест в текущем кадре.
</p>
<p><var>scbehavior</var> (по умолчанию true), определяет, какой кадр
будет сохранен при смене сцен. Если true, кадр оставляется неизменным.
Иначе указанный кадр копируется в текущий.</p>
<p><var>mode</var> может быть 0 , 1 (по умолчанию)или 2. Mode=0 (быстрая)
означает использование компенсации, созданной во время поиска векторов.
Mode=1 означает перерасчет этой компенсации по векторам (так как возможно вы хотите
использовать вектора к другому клипу чем тот, в котором выполнялся
поиск). 2 означает перерасчет компенсации, но она выполняется
циклически, предполагая, что вектора применяются к последнему
просчитанному кадру. Результат будет ужасным, и этот режим не стоит
использовать кроме случаев, когда вы точно знаете, что делаете.</p>
<p><var>idx</var> работает аналогично <var>idx</var>
в <code>MVAnalyse</code>. Используется только с <var>mode</var> = 1.
</p>
<p>Обработка прекрывающихся блоков реализована  в режиме mode=1 как оконное суммирование блоков
(аналогично FFT3DFilter, величина overlap до blksize/2) для снижения артефактов блочности,
и пока как последовательное покрытие блоками слева направо, сверху вниз для остальных режимов 0,2.</p>

<h3>MVDenoise</h3>
<p><code>MVDenoise</code> (<var>clip,
clip mvs [,...], bool "Y", bool "U", bool "V", int "thT", int "thSAD",
int "thMV"</var>)
</p>
<p>Выполняет базовое временнОе шумоподавление с
компенсацией движения. Для опорных кадров выполняется компенсация
движения и затем они сливаются с текущим кадром. Два порога
используются для предотвращения артефактов.
</p>
<p>Первый порог, <var>thT</var>,
определяет, надо ли пиксель, взятый из
предыдущего или следующего кадра, включать в процесс суммирования. Если
этот пиксель отличается более чем на
<var>thT</var> от пикселя текущего кадра, то он не используется.
</p>
<p>Второй, <var>thSAD</var>, определяет,
будет ли блок изменен или нет (по тем же правилам, что и
<var> thSCD1</var>). Если блок изменился, пиксель не сливается с
соответствующими из предыдущего и последующего кадров.</p>
<p><var>thMV</var>
это длина вектора, выше которой блок не используется для шумопонижения.</p>
<p>Наконец, <var>Y</var>, <var>U</var> и <var>V</var> говорят, какие
плоскости должны быть обработаны шумоподавителем.
</p>
<p>По умолчанию:<var>Y</var>, <var>U</var>
и <var>V</var> установлены в true (да), <var>thT</var>
= 10, <var>thSAD</var> = 200 и <var>thMV</var> = 30.
</p>

<h3>MVMask</h3>
<p><code>MVMask</code> (<var>clip, clip "vectors", int "ml", float "gamma",
int "kind", int "Ysc"</var>)
</p>
<p>Создает клип масок на основе данных векторов движения.
Маска определяется данными по блокам, но интерполируется до полного размера кадра.
Маска создается как в яркостном канале, так и в плоскостях цветности.
Величины в маске могут быть от 0 (мин) до 255 (макс).</p>
<p>Параметр <var>kind</var> определяет разновидность маски.
<p>Режим <var>kind=0</var> создает маску движения исходя из длины векторов
движения. Функция строит маску лучше, чем
<a href="masktools.htm#motionmask"> MotionMask</a> (
<a href="masktools.htm"> MaskTools</a> ), так
как вектора движения намного более достоверны, чем алгоритм в
MotionMask.
Значение маски 0 означает отсутствие
движения вообще (длина вектора нулевая). Чем больше длина вектора,
тем больше величина маски (насыщается до 255), масштаб
определяется параметром <var>ml</var>.
</p>
<p><var>kind=1</var> позволяет построить маску из величин SAD (суммы абсолютных разностей)
вместо длин векторов. Это может быть полезно, чтобы выявить проблемные области с плохой оценкой движения.
(Используется внутренний коэффициент blocksize*blocksize/4 для нормализации масштаба <var>ml</var>.)
<p><var>kind=2</var> позволяет построить маску окклюзий (разрывности, заграждения, occlusion) (плохих блоков из-за разрыва, растяжения).
В настоящей версии используется некоторая нормализованная сумма положительных разностей движения блоков.
Она может масштабироваться <var>ml</var>.</p>
<p><var>ml</var> определяет масштаб (шкалу) маски движения.
Если длина вектора (или величина другой разновидности) больше и равна <var>ml</var>, то выходная величина
насыщается до 255. Меньшие величины дают меньшее выходное значение.
</p>
<var>gamma</var> используется для определения показателя степени
зависимости выхода от входа.
<var>gamma</var> = 1.0 подразумевает
линейную зависимость, а <var>gamma</var> = 2.0 дает квадратичную.</p>
<var>И наконец, Ysc</var> есть величина, принимаемая маской при смене сцены.
</p>
<p>По умолчанию: <var>kind</var>=0, <var>ml</var> = 100, <var>gamma</var> = 1.0,
и <var>Ysc</var> = 0.
</p>

<h3>MVSCDetection</h3>

<p><code>MVSCDetection</code> (<var>clip, clip "vectors", int "Ysc"</var>)
</p>
<p>Создает клип маски смены сцены на основе данных векторов движения.
Маска создается для каналов яркости и цветоразности. Выход без смены сцены равен 0.</p>
<p><var>Ysc</var> - это величина, принимаемая маской при смене сцены, по умолчанию 255.</p>

<h3>MVShow</h3>
<p><code>MVShow</code> (<var>clip,
clip "vectors", int "scale", int "sil", int "tol', bool "showsad"</var>)
</p>
<p>Показывает вектора движения. Параметр <var>scale</var>
позволяет увеличить вектора движения, например для увеличения точности
(когда <var>pel</var> &gt; 1 и <var>scale</var> = 1, невозможно увидеть
изменения менее чем на 1 пиксель).
<var>sil</var> позволяет увидеть различные уровни анализа
(когда для поиска векторов движения задан иерархический анализ и
интересно увидеть что произойдет при более высоких уровнях).
<var>tol</var> - порог допуска (толерантности). Если искажения, вызванные вектором
движения больше <var>tol</var>, то вектор не показывается. Наконец, <var>showsad</var>
позволяет показать среднее значение SAD картинки после компенсации.</p>
<p>По умолчанию: <var>scale</var> = 1, <var>sil</var> = 0, <var>tol</var>
= 20000 и <var>showsad</var> = false (что обеспечивает показ всех
векторов).</p>

<h3>MVChangeCompensate</h3>
<p><code>MVChangeCompensate</code> (<var>clip vectors, clip</var>)</p>
<p>Позволяет изменить компенсационную информацию, сохраненную в
потоке векторов движения <var>vectors</var>.</p>

<h3>MVIncrease</h3>
<p><code>MVIncrease</code> (<var>clip, clip "vectors", int "horizontal",
int "vertical", int "idx"</var>)</p>
<p>Позволяет использовать вектора, рассчитанные для версии клипа с
уменьшенными размерами для выполнения компенсации клипа оригинального
размера.</p>
<p><var>horizontal</var> горизонтальное соотношение
между шириной оригинального и уменьшенного клипа.</p>
<p><var>vertical</var> вертикальное соотношение между
высотой оригинального и уменьшенного клипа.</p>
<p><var>idx</var> работает так же, как и в <code>MVAnalyse</code></p>

<h3>MVDepan</h3>
<p><code>MVDepan</code> (<var>clip, clip "vectors", bool "zoom", bool "rot",
float "pixaspect", float "error", bool "info", string "log"</var>) </p>
<p>Получает вектора движения, оценивает глобальное
движение и помещает данные в выходной кадр в специальном формате для
плагина <a href="depan.htm">DePan</a> (от Fizick).</p>
<p>Меж-кадровое глобальное движение (панорамирование, зум, вращение)
оценивается итерационной процедурой, с использованием только хороших
блоков. </p>
<p>Отвергаемые блоки: 1) вблизи границ кадра; 2) с большим SAD
(по параметру <var>thSCD1</var>); 3) с движением, отличающимся от
глобального.</p>
<p>Параметры <var>zoom</var> и <var>rot</var> включают оценку зума и
вращения, <var>pixaspect</var> это аспект
пиксела (1.094 для стандартного PAL, 0.911 для стандартного NTSC), <var>error</var>
это максимум отличия от среднего движения.</p>
<p>Оцениваемое глобальное движение кадра выключается в нулевое
для больших ошибок движения <var>error</var> или на смене
сцены (по параметрам <var>thSCD1, thSCD2</var>).
</p>
<p>Параметр <var>info</var> позволяет вывести
информацию по глобальному движению для отладки. </p>
<p>Параметр <var>log</var> позволяет задать имя лог-файла для вывода значений в формате DeShaker, DePan.</p>
<p>Значения по умолчанию: <var>zoom</var> = true, <var>rot</var> =
true, <var>pixaspect</var> = 1.0, <var>error</var> = 15.0, <i>info</i>
= false.</p>
<p>Для оценки глобального движения чересстрочного видео, вы должны разделить поля
(как для MVAnalyse, так и MVDepan).</p>

<h3>MVFlow</h3>

<p><code>MVFlow</code> (<var>clip, clip "vectors", float "time", int "mode", int "idx"</var>)
</p>
<p>Делает компенсацию движения кадра не по блокам (как MVCompensation), а по пикселам. (Flow - течение).
Вектор движения каждого пиксела вычисляется путем билинейной интерполяции векторов движения
текущего и соседних блока (в соответствии с положением пиксела).
Это означает, что пикселы, указываемые вектором в опорном кадре
будут двигаться (течь) вдоль вектора, чтобы достичь их мест в текущем кадре.
Данный метод компенсации движения течением не производит блочных артефактов, и хорош для понижения шума,
но иногда может создать очень странные деформированные картины :).
Оценка истинного движения настоятельно рекомендуется для этой функции.
Компенсация движения может быть полной или частичной (в промежуточное время).<br>
Ограничение: вектора с компонентами выше 127 будут сброшены к нулевой длине.
</p>
<p><var>time</var>:  процент компенсации движения (по умолчанию=100.0, полная компенсация),
определяет временной момент между опорным и текущим кадром.</p>
<p><var>mode</var>: режим может быть или 0 (по умолчанию), или 1. <br>
mode=0 - поднести пикселы к каждому месту целевого кадра. Это основной рабочий режим.<br>
mode=1 - сдвинуть пикселы от каждого места источника (опорного).
Это отладочный (учебный) режим с некоторыми пустыми местами (с нулевой интенсивностью).
Он может быть использован для генерации маски окклюзий.
</p>
<p><var>idx</var> (может) работать как указано для <var>idx</var> в MVAnalyse.</p>

<h3>MVFlowInter</h3>

<p><code>MVFlowInter</code> (<var>clip, clip "mvbw", clip "mvfw", float "time", float "ml", int "idx"</var>)
<p>Функция интерполяции движения. Это не то же самое (но подобное) функции MVInterpolate более старых версий MVTools.
Она использует обратные "mvbw" и прямые "mvfw" вектора движения,
чтобы создать изображение в некоторый промежуточный момент времени между текущим и следующим кадром.
Она использует по-пиксельную компенсацию движения (методом MVFlow) из обоих кадров.
Используются внутренние прямая и обратная маски окклюзий - разрывности (методом MVMask <var>kind=2</var>)
и временные взвешивающие факторы, чтобы произвести выходное изображение с минимальными артефактами.
Оценка истинного движения настоятельно рекомендуется для этой функции.</p>
<p><var>time</var>:  положение интерполяционного момента времени между кадрами (в процентах, по умолчанию=50.0, посредине)</p>
<p><var>ml</var>:  масштабный параметр маски. Большие величины соответствуют более слабой маске окклюзий
(как в функции MVMask, используйте ее для настройки и отладки). По умолчанию=100.
<p><var>idx</var> (может) работать как указано для <var>idx</var> в MVAnalyse.</p>

<h3>MVFlowFps</h3>

<p><code>MVFlowFps</code> (<var>clip, clip "mvbw", clip "mvfw", int "num", int "den", float "ml", int "idx"</var>)
<p>Будет изменять частоту кадров (fps) клипа (и число кадров).
Функция может быть использована для преобразования частоты, эффектов замедления движения и т.п.
Она использует обратные "mvbw" и прямые "mvfw" вектора движения
чтобы создать интерполированные изображения в некоторые промежуточные моменты времени между кадрами.
Функция использует по-пиксельный метод компенсации движения (как MVFlow, MVFlowInter).
Используются внутренние прямая и обратная маски окклюзий - разрывности (методом MVMask <var>kind=2</var>)
и временные взвешивающие факторы, чтобы произвести выходное изображение с минимальными артефактами.
Оценка истинного движения настоятельно рекомендуется для этой функции.</p>
<p><var>num</var>:  fps числитель (по умолчанию=25)</p>
<p><var>den</var>:  fps знаменатель (по умолчанию=1). Результирующая частота кадров fps = num/den.
Например, используйте 30000/1001 для 29.97</p>
<p><var>ml</var>:  масштабный параметр маски. Большие величины соответствуют более слабой маске окклюзий
(как в функции MVMask, используйте ее для настройки и отладки). По умолчанию=100.
<p><var>idx</var> (может) работать как указано для <var>idx</var> в MVAnalyse.</p>

<h3>MVFlowFps2</h3>

<p><code>MVFlowFps2</code> (<var>clip, clip "mvbw", clip "mvfw", clip "mvbw2", clip "mvfw2",
int "num", int "den", float "ml", int "idx", int "idx2"</var>)
<p>Будет изменять частоту кадров (fps) клипа (и число кадров) подобно MVFlowFps,
но с немного лучшим качеством (и более медленной обработкой).
В дополнении к обратным "mvbw" и прямым "mvfw" векторам движения оригинального исходного клипа,
функция использует обратные "mvbw2" и прямые "mvfw2" вектора движения второго (модифицированного) клипа-источника.
Второй клип должен быть сделан из оригинального исходного клипа путем обрезки (то есть диагонального сдвига)
 на половину размера блока.
Это может быть сделано командой <code>Crop(a,a,-b,-b)</code>,
где a=b=4 должны использоваться для blksize=8, a=b=8 для blksize=16, и a=2, b=6 для blksize=4 (смотри пример).
Границы блоков будут на разных частях объектов.
MVFlowFps2 обращает сдвиг внутренне и усредняет вектора движения двух источников
для снижения ошибок оценки движения.
Функция использует по-пиксельный метод компенсации движения (как MVFlow, MVFlowInter).
Используются внутренние прямая и обратная маски окклюзий - разрывности (методом MVMask <var>kind=2</var>)
и временные взвешивающие факторы, чтобы произвести выходное изображение с минимальными артефактами.
Оценка истинного движения настоятельно рекомендуется для этой функции.</p>
<p><var>num</var>:  fps numerator (default=25)</p>
<p><var>den</var>:  fps denominator (default=1). Результирующая частота кадров fps = num/den.
Например, используйте 30000/1001 для 29.97</p>
<p><var>ml</var>:  масштабный параметр маски. Большие величины соответствуют более слабой маске окклюзий
(как в функции MVMask, используйте ее для настройки и отладки). По умолчанию=100.
<p><var>idx</var> (может) работать как указано для <var>idx</var> в MVAnalyse.</p>
<p><var>idx2</var> это индекс MVAnalyse второго (смещенного) клипа clip (не должен совпадать с первым idx).</p>

<h3>MVFlowBlur</h3>

<p><code>MVFlowBlur</code> (<var>clip, clip "mvbw", clip "mvfw", float "blur", int "prec", int "idx"</var>)
<p>Экспериментальная простая функция размытия движения (motion blur).
Она может быть использована для создания эффекта Фильма (чтобы имитировать конечное время открытия затвора кинокамеры).
Она использует обратные "mvbw" и прямые "mvfw" вектора движения
для создания и наложения многих копий частично компенсированных пикселов
в промежуточные моменты времени в некотором интервале размытия вокруг текущего кадра.
Используется по-пиксельная компенсация (метод MVFlow).
Оценка истинного движения настоятельно рекомендуется для этой функции.</p>
<p><var>blur</var>: временной интервал размытия между кадрами, время открытия затвора (в процентах, по умолчанию=50.0)</p>
<p><var>prec</var>: точность размытия в единицах пикселов.
 Максимальный шаг между компенсированными размытыми пикселами. По умолчанию =1 (наиболее точно).
<p><var>idx</var> (может) работать как указано для <var>idx</var> в MVAnalyse.</p>

<h3>MVDeGrain1 и MVDeGrain2</h3>

<p><code>MVDeGrain1</code> (<var>clip, clip "mvbw", clip "mvfw", int "thSAD", int "plane", int "idx"</var>)</p>
<p><code>MVDeGrain2</code> (<var>clip, clip "mvbw", clip "mvfw", clip "mvbw2", clip "mvfw2", int "thSAD", int "plane", int "idx"</var>)</p>
<p>Производит динамическое понижение шума с компенсацией движения.
Блоки опорных предыдущих и последующих кадров компенсируются и затем усредняются с текущим кадром
с весовыми факторами зависящими от разницы блоков от текущего (SAD). Функции поддерживают режим перекрытия блоков (overlap).
Обработка прекрывающихся блоков реализована  как оконное суммирование блоков
(аналогично FFT3DFilter, величина overlap до blksize/2) для снижения артефактов блочности.</p>
<p>MVDeGrain1 имеет временной радиус 1 (использует вектора предыдущего <var>mvfw</var>
и последующего <var>mvbw</var> кадров).</p>
MVDeGrain2 имеет временной радиус 2 (использует вектора двух предыдущих <var>mvfw2, mvfw</var>
и двух последующих <var>mvbw,mvbw2</var> кадров). Он медленнее, но дает чуть лучшие результаты.</p>
<p>Степень фильтрации управляется параметром "thSAD".
Он определяет порог суммы абсолютных разностей блоков (SAD).
Вы должны ввести величину thSAD приведенную к блоку 8x8.
Чем больше SAD, тем меньше вес. Блоки с SAD выше порога thSAD имеют нулевой вес.<br>
По умолчанию : <var>thSAD</var>=400.
<p>Параметр <var>plane</var> устанавливает обрабатываемые цветовые плоскости:<br>
0 - яркость, 1 - цветность U, 2 - цветность V, 3 - обе цветности, 4 - все. По умолчанию 4.
<p><var>idx</var> (может) работать как указано для <var>idx</var> в MVAnalyse.</p>

<p>&nbsp;</p>

<h2><a name="examples"></a>III) Примеры</h2>
<p>Показать вектора движения (вперед) :
</p>
<pre>vectors = source.MVAnalyse(isb = false)
return source.MVShow(vectors)</pre>
<p>Показать аналогичное назад:
</p>
<pre>vectors = source.MVAnalyse(isb = true)
return source.MVShow(vectors)</pre>
<p>Использование MVMask :
</p>
<pre>vectors = source.MVAnalyse(isb = false)
return source.MVMask(vectors)</pre>
<p>Для шумоподавления:
</p>
<pre>backward_vec2 = source.MVAnalyse(isb = true, lambda = 1000, delta=2)
backward_vec1 = source.MVAnalyse(isb = true, lambda = 1000, delta=1)
forward_vec1 = source.MVAnalyse(isb = false, lambda = 1000, delta=1)
forward_vec2 = source.MVAnalyse(isb = false, lambda = 1000, delta=2)
return source.MVDenoise(backward_vec2,backward_vec1,forward_vec1,forward_vec2,tht=10,thsad=300)</pre>
<p>Чтобы убрать блочность компенсации, хранимой в потоке векторов
движения:</p>
<pre>vectors = source.MVAnalyse(isb = false, lambda = 1000)
compensation = source.MVCompensate(vectors, mode = 0)
compensation = compensation.Deblock() # используем функцию DeBlock
vectors = vectors.MVChangeCompensate(compensation)</pre>
<p>Чтобы
понизить шум c <var>pel</var> = 2, эффективно :</p>
<pre>backward_vec2 = source.MVAnalyse(isb = true, lambda = 1000, delta = 2, pel = 2, idx = 1)
backward_vec1 = source.MVAnalyse(isb = true, lambda = 1000, delta = 1, pel = 2, idx = 1)
forward_vec1 = source.MVAnalyse(isb = false, lambda = 1000, delta = 1, pel = 2, idx = 1)
forward_vec2 = source.MVAnalyse(isb = false, lambda = 1000, delta = 2, pel = 2, idx = 1)
return source.MVDenoise(backward_vec2,backward_vec1,forward_vec1,forward_vec2,tht=10,thsad=300)</pre>
<p>Чтобы
использовать MVIncrease : </p>
<pre>vectors = source.reduceby2().mvanalyse(isb = true)
return source.MVIncrease(vectors, horizontal = 2, vertical = 2)</pre>
<p>Чтобы использовать MVDepan с плагином <a href="depan.htm">Depan</a> для чересстрочного видео
(пример функции DepanStabilize):</p>
<pre>source = source.AssumeTFF().SeparateFields() # установи корректный порядок полей
vectors = source.MVAnalyse(isb = false)
globalmotion = source.MVDepan(vectors, pixaspect=1.094, thSCD1=400)
DepanStabilize(source, data=globalmotion, cutoff=2.0, mirror=15, pixaspect=1.094)
Weave()
</pre>

<p>Чтобы сгладить проблемные (блочные) области компенсированного кадра с маской заграждения:</p>
<pre>vectors = source.MVAnalyse(isb = false, lambda = 1000)
compensation = source.MVCompensate(vectors) # или используйте MVFlow функцию здесь
# приготовим размытый кадр с некоторой сильной функцие блюра или deblock:
blurred = compensation.DeBlock(quant=51) # используем функцию DeBlock
badmask = source.MVMask(vectors, kind = 2, ml=50)
overlay(compensation,blurred,mask=badmask) # или используйте более быструю MaskedMerge
</pre>

<p>Чтобы восстановить испорченные кадры интерполяцией c MVFlowInter:</p>
<pre>
backward_vectors = source.MVAnalyse(isb = true, truemotion=true, pel=2, delta=2, idx=1)
forward_vectors = source.MVAnalyse(isb = false, truemotion=true, pel=2, delta=2, idx=1)
inter = source.MVFlowInter(backward_vectors, forward_vectors, time=50, ml=70, idx=1)
# Предположим плохие кадры 50 и 60
source.trim(0,49) ++ inter.trim(49,-1) \
 ++ source.trim(51,59) ++ inter.trim(59,-1) ++ source.trim(61,0)
</pre>

<p>Чтобы изменить частоту кадров с MVFlowFps:</p>
<pre>
# предполагаем прогрессивный PAL 25 fps источнмк
backward_vec = source.MVAnalyse(isb = true, truemotion=true, pel=2, idx=1)
# we use explicit idx for more fast processing
forward_vec = source.MVAnalyse(isb = false, truemotion=true, pel=2, idx=1)
return source.MVFlowFps(backward_vec, forward_vec, num=50, den=1, ml=100, idx=1) # получили 50
</pre>

<p>Чтобы изменить частоту (fps) с MVFlowFps2:</p>
<pre>
# Предполагаем прогрессивный PAL 25 fps источнмк. Преобразуем его к 50 к/с.
backward_vec = source.MVAnalyse(isb = true, truemotion=true, pel=2, idx=1)
# мы используем явное указание idx для более быстрой обработки
forward_vec = source.MVAnalyse(isb = false, truemotion=true, pel=2, idx=1)
cropped = source.crop(4,4,-4,-4) # обрезка на половину размера блока 8
backward_vec2 = cropped.MVAnalyse(isb = true, truemotion=true, pel=2, idx=2)
forward_vec2 = cropped.MVAnalyse(isb = false, truemotion=true, pel=2, idx=2)
return source.MVFlowFps2(backward_vec,forward_vec,backward_vec2,forward_vec2,num=50,idx=1,idx2=2)
</pre>

<p>Чтобы генерировать приятное размытие движения с MVFlowBlur:</p>
<pre>
backward_vectors = source.MVAnalyse(isb = true, truemotion=true)
forward_vectors = source.MVAnalyse(isb = false, truemotion=true)
return source.MVFlowBlur(backward_vectors, forward_vectors, blur=15)
</pre>

<p>Понижение шума с некоторым внешним фильтром (который использует три кадра: предыдущий, текущий, следующий):</p>
<pre>backward_vectors = source.MVAnalyse(isb = true, truemotion=true, delta = 1, idx = 1, thSCD1=500)
# мы используем явное idx для более быстрой обработки
forward_vectors = source.MVAnalyse(isb = false, truemotion=true, delta = 1, idx = 1, thSCD1=500)
forward_compensation = source.MVFlow(forward_vectors, idx=1) # или используйте MVCompensate
backward_compensation = source.MVFlow(backward_vectors, idx=1) # или используйте MVCompensate
# создадим чередующиеся трех-кадровые последовательности
interleave(forward_compensation, source, backward_compensation)

DeGrainMedian() # поместите  предпочитаемый Вами временной (пространственно-временной) фильтр здесь

return selectevery(3,1) # возвращает фильтрованные только центральные (не компенсированные) кадры
</pre>

<p>Чтобы использовать предварительно отфильтрованный клип для более надежной оценки движения,
но компенсировать движение нефильтрованного клипа (на примере подавления шума):</p>

<pre># Используем некий шумоподавитель (блюр) или стабилизатор яркости для предварительной фильтрации
prefiltered = source.DeGrainMedian()
backward_vectors = prefiltered.MVAnalyse(isb = true, truemotion=true, delta = 1, idx = 1)
# мы используем явное idx для более быстрой обработки
forward_vectors = prefiltered.MVAnalyse(isb = false, truemotion=true, delta = 1, idx = 1)
# используем нефильтрованный оригинальный клип для компенсации движения (с другим idx)
forward_compensation = source.MVFlow(forward_vectors, idx=2) # или используйте MVCompensate(mode=1)
backward_compensation = source.MVFlow(backward_vectors, idx=2) # или используйте MVCompensate(mode=1)
# создадим чередующиеся трех-кадровые последовательности
interleave(forward_compensation, source, backward_compensation)

DeGrainMedian() # поместите предпочитаемый Вами временной (пространственно-временной) фильтр здесь

return selectevery(3,1) # возвращает фильтрованные только центральные (не компенсированные) кадры
</pre>

<p>Чтобы подавить шум функцией MVDegrain2 с перекрывающимися блоками и субпиксельной точностью :</p>
<pre>backward_vec2 = source.MVAnalyse(isb = true, delta = 2, pel = 2, overlap=4, sharp=1, idx = 1)
backward_vec1 = source.MVAnalyse(isb = true, delta = 1, pel = 2, overlap=4, sharp=1, idx = 1)
forward_vec1 = source.MVAnalyse(isb = false, delta = 1, pel = 2, overlap=4, sharp=1, idx = 1)
forward_vec2 = source.MVAnalyse(isb = false, delta = 2, pel = 2, overlap=4, sharp=1, idx = 1)
source.MVDegrain2(backward_vec1,forward_vec1,backward_vec2,forward_vec2,thSAD=400, idx=1)</pre>

<p>Чтобы подавить шум чересстрочного источника функцией MVDegrain1 с перекрывающимися блоками и субпиксельной точностью:</p>
<pre>fields=source.AssumeTFF().SeparateFields() # or AssumeBFF
backward_vec = fields.MVAnalyse(isb = true, delta = 2, pel = 2, overlap=4, sharp=1, idx = 1)
forward_vec = fields.MVAnalyse(isb = false, delta = 2, pel = 2, overlap=4, sharp=1, idx = 1)
fields.MVDegrain1(backward_vec,forward_vec,thSAD=400,idx=1)
Weave()</pre>

<h2><a name="disclaimer"></a>IV) Отказ (от гарантий)</h2>
<p>Плагин распространяется на условиях лицензии GPL.
Вы должны согласиться с условиями в
'Copying.txt' прежде чем использовать плагин и его исходный код.
Прошу материальную помощь для поддержки.
</p>

<h2><a name="revisions"></a>V) Ревизии </h2>
<small>
<p>1.4.11 (06.09.2006 by Fizick)</p>
<ul>
<li>Подправил интерполяцию предикторов векторов (от грубого до тонкого масштаба) для overlap>0.</li>
<li>Исправлена ошибка с шириной для overlap=0, YV12 в MVDegrain1 (спасибо Boulder за доклад)</li>
</ul>
<p>1.4.10 (18.08.2006 by Fizick)</p>
<ul>
<li>Подправил обработку правого и нижнего края в MVCompensate для произвольных размеров кадра.</li>
<li>Изменил значения по умолчанию в MVAnalyse: pel=2, truemotion=true, sharp=2.</li>
</ul>
<p>1.4.9 (14.08.2006 by Fizick)</p>
<ul>
<li>Исправил ошибку в MMX оптимизации к режиму перекрытия в MVDeGrain, MVCompensate для YUY2 с blksize=8
 (спасибо TSchniede за доклад).</li>
</ul>
<p>1.4.8 (31.07.2006 by Fizick)</p>
<ul>
<li>Добавил некоторую MMX оптимизацию к режиму перекрытия в MVDeGrain, MVCompensate.</li>
<li>Исправил ошибку с последними (не обрабатываемыми) строками в MVDeGrain.</li>
</ul>
<p>1.4.7 (25.07.2006 by Fizick)</p>
<ul>
<li>Снизил сеточность перекрытия в MVDeGrain1, MVDeGrain2, MVCompensate.</li>
<li>Добавил пример с MVDeGrain1 для чересстоочного</li>
</ul>
<p>1.4.6 (24.07.2006 by Fizick)</p>
<ul>
<li>Снижено шумоподавление в MVDeGrain1, MVDeGrain2.</li>
<li>Параметр plane в MVDeGrain1, MVDeGrain2 теперь работает :)</li>
</ul>
<p>1.4.5 (22.07.2006 by Fizick)</p>
<ul>
<li>Добавлен параметр plane в MVDeGrain1, MVDeGrain2.</li>
</ul>
<p>1.4.4 (19.07.2006 by Fizick)</p>
<ul>
<li>Исправил значение по умолчанию thSAD=400 в MVDeGrain1, MVDeGrain2.</li>
<li>Исправил ошибку с цветовой плоскостью V в MVChangeCompensate.</li>
</ul>
<p>1.4.3 (17.07.2006 by Fizick)</p>
<ul>
<li>Снизил сеточность перекрытия в MVDeGrain1, MVDeGrain2.</li>
</ul>
<p>1.4.2 (16.07.2006 by Fizick)</p>
<ul>
<li>Исправил ошибку доступа к памяти в MVDeGrain1, MVDeGrain2. Спасибо krieger2005 за доклад.</li>
</ul>
<p>1.4.1 (23.06.2006 by Fizick)</p>
<ul>
<li>Изменил режим MVDeGrain1, MVDeGrain2 на взвешивание по SAD.</li>
<li>Изменил thSCD1 по умолчанию с 300 до 400.</li>
</ul>
<p>1.4.0 (19.06.2006 by Fizick)</p>
<ul>
<li>Добавил MVDeGrain1, MVDeGrain2 ограниченные усредняющие шумоподавители.</li>
<li>Исправил масштаб thSAD в MVDenoise.</li>
<li>Исправил документацию о SAD.</li>
</ul>
<p>1.3.1 (11.06.2006 by Fizick)</p>
<ul>
<li>Добавил бикубический метод субпиксельной интерполяции для pel=2 (с iSSE оптимизацией для sharp=1,2).</li>
<li>Ассемблерная SSE оптимизация скорости для метода компенсации с перекрытием блоков.</li>
</ul>
<p>1.3.0 (05.06.2006 by Fizick)</p>
<ul>
<li>Реализовал компенсацию движения перекрывающихся блоков в MVCompensation(mode=1).</li>
<li>Изменил режим по умолчанию на mode=1 в MVCompensation как наиболее универсальный.</li>
<li>Добавил метод резкой субпиксельной интерполяции для pel=2.</li>
<li>Исправил ошибку для blksize=16 с YUY2.</li>
<li>(Список на будущее: ассемблерная SSE оптимизация скорости для новых методов компенсации и интерполяции.)</li>
</ul>
<p>1.2.6 beta (21.05.2006 by Fizick)</p>
<ul>
<li>Добавил опцию выводить данные по векторам движения в лог файл, как просил Endre.</li>
</ul>
<p>1.2.5 (08.05.2006 by Fizick)</p>
<ul>
<li>Снижен вес нулевого вектора, погрешнось итераций в MVDepan</li>
</ul>
<p>1.2.4 (07.04.2006 by Fizick)</p>
<ul>
<li>Исправлена ошибка v.1.2.3 в режиме info в MVDepan</li>
</ul>
<p>1.2.3 (31.03.2006 by Fizick)</p>
<ul>
<li>Реализована обработка разделеного на поля чересстрочного видео в MVDepan;</li>
<li>добавлена опция лог-файла в MVDepan.</li>
</ul>
<p>1.2.2 beta (01.03.2006 by Fizick)</p>
<ul>
<li>Исправлена ошибка сдвига кадра v1.2.1 MMX YUY2 преобразования (спасибо <b>WorBry</b> за сообщение)</li>
</ul>
<p>1.2.1 beta (20.02.2006 by Fizick)</p>
<ul>
<li>Fixed bug of v1.2,</li>
<li>Скорость восстановлена,</li>
<li>MMX YUY2 преобразование (из Avisynth 2.6 функции от sh0dan) </li>
<li>Но режим overlap кажется все еще работает неверно</li>
</ul>
<p>1.2 beta (17.02.2006 by Fizick)</p>
<ul>
<li>YUY2 формат (кроме MVIncrease), без оптимизации </li>
</ul>
<p>1.1.1 (16.02.2006 by Fizick)</p>
<ul>
<li>Удалил фильтры DeBlock и Corrector (не используют вектора движения, будут отдельными плагинами)</li>
<li>Документировал старую функцию MVSCDetection.</li>
<li>Очистил проект от неиспользуемых исходных файлов.</li>
</ul>

<p>1.1 (не публичный выпуск 9.01.2006 by Fizick)</p>
<ul>
<li>Достаточно большая ревизия (бета). Новая опция для оценки движения перекрывающихся блоков в MVAnalyse
для использования в MVFlow, MVFlowInter, MVFlowFps для улучшенной компенсации движения.</li>
<li>Таблицы для интерполяции движения.</li>
<li>Небольшая коррекция величины смещения в MVFlowFps2.</li>
</ul>
<p>1.0.3 (Выпущена 30.12.2005 by Fizick)</p>
<ul>
<li>Исправил ошибку смещения в MVFlowInter, MVFlowFps (введенную в v1.0.2).</li>
</ul>
<p>1.0.2 (Выпущена 28.12.2005 by Fizick)</p>
<ul>
<li>Скорректровал величину смещения в MVFlow (немного).</li>
</ul>
<p>1.0.1 (Выпущена 24.12.2005 by Fizick)</p>
<ul>
<li>Исправил утечку памяти в MVAnalyse с глобальным движением (спасибо <b>AI</b> за доклад).</li>
<li>Удалил пенальти для нулевого вектора-предиктора в MVAnalyse (был введен в v1.0).</li>
<li>Изменил chroma=true по умолчанию в MVAnalyse.</li>
<li>Добавил пример предварительной фильтрации.</li>
</ul>
<p>1.0 (Выпущена 29.11.2005 by Fizick)</p>
<ul>
<li>Восстановил нулевой вектор как предиктор в MVAnalyse.</li>
<li>Изменил масштаб времени блюра в MVFlowBlur (100 это полностью открытый затвор теперь) как просил <b>Mug Funky</b>.</li>
</ul>
<p>0.9.13.3 (Выпущена 27.11.2005 by Fizick)</p>
<ul>
<li>Добавил вектор глобального движения (простой метод) в качестве предиктора в MVAnalyse.</li>
<li>Поиск векторов прекращается (для скорости), если найден хороший предиктор (с SAD &lt; pnew).</li>
<li>Параметр <var>scale</var> в MVShow теперь работает правильно.</li>
<li>Отменил вывод некоторой отладочной и профилирующей инфомации (для увеличения скорости).</li>
<li>Изменил значение по умолчанию <var>prec</var>=1 (было 2) в MVFlowBlur.</li>
</ul>
<p>0.9.13.2 (Выпущена 22.11.2005 by Fizick)</p>
<ul>
<li>Исправил ошибку в MVFlowFps, MVFlowFps2 для нецелых частот.</li>
</ul>
<p>0.9.13.1 (Выпущена 21.11.2005 by Fizick)</p>
<ul>
<li>Исправил ошибку в MVFlowFps, MVFlowFps2, MVFlowInter, MVFlowBlur (введенную в 0.9.13).</li>
<li>Убрал параметр <var>plen</var> из MVAnalyse как бесполезный.</li>
</ul>
<p>0.9.13 (Выпущена 20.11.2005 by Fizick)</p>
<ul>
<li>Добавил <var>truemotion</var> пресет к MVAnalyse.</li>
<li>Добавил экспериментальную MVFlowFps2.</li>
<li>Изменил метод округления при интерполяции вектора во всех MVFLow... функциях.</li>
<li>Немного отредактирована документация, обновлена русская.</li>
</ul>
<p>0.9.12.4 (Выпущена 15.11.2005 by Fizick)</p>
<ul>
<li>Изменил тип параметра <var>ml</var> в MVMask, MVFlowInter, MVFlowFps с int на float.</li>
<li>Добавил проверки диапазона параметров <var>ml, time, blur</var>.</li>
<li>Исправил малую возможную ошибку (emms).</li>
<li>Частично обновил документацию. Но я не уверен, что <b>sh0dan</b> запрашивал <b>имено такое</b> обновление :).
Это все еще не руководство пользователя, а справочник по функциям.</li>
</ul>
<p>0.9.12.3 (Выпущена 14.11.2005 by Fizick)</p>
<ul>
<li>Исправлена ошибка для цветности для ширины не кратной 16 в MVMask (введена в v0.9.11).</li>
<li>Некоторая оптимизация скорости MVFlowFps.</li>
<li>Переустановил размер внутренего буфера кадров в превоначальную величину 10. Пробуйте разные версии.</li>
</ul>
<p>0.9.12.2 (Выпущена 13.11.2005 by Fizick)</p>
<ul>
<li>Добавил экспериментальный точную но медленую функцию MVFlowBlur как запрашивал <b>scharfis_brain</b>.</li>
<li>Временно изменил разиер внутреннего буфера на 5.</li>
</ul>
<p>0.9.12.1 (Выпущена 12.11.2005 by Fizick)</p>
<ul>
<li>Добавил экспериментальную функцию MVFlowFps.</li>
<li>Убрал функцию MVInter.</li>
<li>Временно изменил размер внутреннего буфера кадров с 10 до 3 для снижения использования памяти.
Скорость должна быть протестирована для сложных скриптов.</li>
</ul>
<p>0.9.12 (Выпущена 09.11.2005 by Fizick)</p>
<ul>
<li>Добавлена функция MVFlowInter. Функция MVInter будет удалена из следующего выпуска (она хуже).</li>
<li>Изменил масштаб <var>ml</var> для kind=2 MVMask до более оптимального умолчания.</li>
<li>Исправил небольшую ошибку в Bilinear.asm (странные пикселы у правой границы для pel=2).</li>
</ul>
<p>0.9.11.1 (Выпущена 06.11.2005 by Fizick)</p>
<ul>
<li>Добавил поддержку полу-пикселов pel=2 к MVFlow.</li>
<li>Увеличен максимальный <var>quant</var> с 51 до 60 в DeBlock для очень сильного подавления блочности.</li>
<li>Исправлена документация.</li>
</ul>
<p>0.9.11 (Выпущена 04.11.2005 by Fizick)</p>
<ul>
<li>Улучшена MVMask: Заменен булевый параметр <var>showsad</var> на целый <var>kind</var>,
добавил опцию маски окклюзий, изменил код билинейного масштабирования на более корректный и быстрый SimpleResize.</li>
</ul>
<p>0.9.10.1 (Выпущена 01.11.2005 by Fizick)</p>
<ul>
<li>Исправил ошибку с малым изменением яркости и цветности в MVInter (ошибка округления).</li>
<li>Интерполяция векторов в MVFlow и маски в MVInter теперь корректны (благодаря исправлению ошибки в SimpleResize).</li>
</ul>
<p>0.9.10 (Выпущена 31.10.2005 by Fizick)</p>
<ul>
<li>Добавлены некоторые опции оценки истинного (сглаженного) движения к MVAnalyse</li>
<li>Добавлена функция MVFlow для по-пиксельной компенсации</li>
<li>Добавлена функция MVInter для интерполяции движения (очень экспериментальная).</li>
</ul>
<p>0.9.9.1 (Выпущена 20.01.2005 by Manao)</p>
<ul>
  <li>Больше нет необходимости в stlport_vcxxxx.dll </li>
</ul>
<p>0.9.9</p>
<ul>
  <li>Добавлена функция: Corrector </li>
  <li>Добавлена
функция: MVIncrease </li>
  <li>Возможен новый размер
блока: 16 </li>
  <li>Новый параметр в MVAnalyse : <var>chroma</var></li>
  <li>Изменения в ядре</li>
</ul>
<p>0.9.8.5</p>
<ul>
  <li>MVCompensate изменена: новый параметр idx,
работающий как idx в
MVAnalyse, и позволяющий увеличить скорость при многократной
компенсации тех же кадров. </li>
</ul>
<p>0.9.8.4</p>
<ul>
  <li>Оценка движения (ME) теперь берет в расчет и
цветовую информацию, как просил tsp. </li>
</ul>
<p>0.9.8.3</p>
<ul>
  <li>Добавлена функция Corrector, как просил scharfi. </li>
</ul>
<p>0.9.8.2</p>
<ul>
  <li>Новая функция MVDepan (добавлена Fizick) для
плагина Depan. </li>
</ul>
0.9.8
<ul>
  <li>Вновь некоторые изменения в синтаксисе фильтров.Сильно изменено
ядро, в основном с целью выигрыша по скорости где возможно. Однако, по
умолчанию выигрыш в скорости не заметен, необходимо корректно
сконфигурировать анализирующий фильтр с помощью параметра "idx" для
выигрыша в скорости (в режиме "pel" = 2). </li>
  <li>Устранены
ошибки в MVDenoise, и цветовом шумоподавлении в
MVDenoise. </li>
  <li>Теперь фильтры, стоящие ниже по
цепочке фильтров, говорят фильтру анализа, если нуждаются в
компенсации, так что вы не должны об этом заботиться на стадии анализа.</li>
</ul>
<p>0.9.7</p>
<ul>
  <li>Вновь многое переписано. Отключены
интерполирующие фильтры (на
время), все другие фильтры работают и предположительно, стабильны.
Слегка изменен синтаксис, и будет меняться до достижения версии 1.0
(если она однажды будет достигнута). Изменения затронули главным
образом <code>MVAnalyse</code>. Новый фильтр:
 <code>MVChangeCompensate</code>. </li>
</ul>
<p>0.9.6.2</p>
<ul>
<li> Исправлена ошибка в параметрах <code>MVMask</code>.</li>
</ul>

<p>0.9.6.1</p>
<ul>
<li>Lot of bugfixes for the existing filters. MVMask, MVShow, MVCompensate, MVDenoise and MVSCDetection, and MVAnalyse should work .
Other may crash unexpectedly.</li>
<li>Now, for the three new filters. Two have nothing to do with motion compensation,
but I didn't want to put them in separate binaries, since they'll mainly be used with filters from this package.
The third one uses vectors, and integrates somehow the two others.</li>
<li>QDeQuant(clip c, int quant, int level) : takes a clip and quantizes it, using an approximation of the H264 DCT.
It filters the three planes ( 4x4 blocks for each of them, so the chroma isn't processed as in H264 ).
It's not exactly the H264 DCT because at q1, it's lossless, and a q51 it's not that bad, but you can raise quant over 51.
Level is the reference level of the picture.
By default it's zero, but it can be set, for example, to 128.
The picture is then treates as if pixels were ranging from -128 to 127, hence avoiding errors around 128.</li>
<li>Deblock(clip c, int quant, int aOffset, int bOffset ) : takes a clip, and deblock it using H264 deblocking,
as if the picture was made only of inter blocks. This time, quant ranges from 0 to 51 as in H264, and has the same impact.
aOffset and bOffset allow to raise / lower the quant when deciding for some internal thresholds.
They are set by default to 0. Be warned that the filter should do nothing at quant < 16, if aOffset and bOffset are both zero.
It's a wanted behavior ( thus it respect the partially the norm ).</li>
<li>EncDenoise(clip c, clip vectors, bool scbehavior, int quant, int aOffset, int bOffset, int thSCD1, int thSCD2) :
it merges Deblock, QDeQuant and MVCompensate, taking from them the name and behavior of their parameters.
It basically does a h264 encode as if all blocks were 8x8 inter blocks.
Reference frame is the previous frame output by the filter ( if it is the correct one, else it's the previous frame of the source ),
mvs are those given by mvanalyse on the source. The reference frame is compensated by the vectors,
then the residual difference is quantized / dequantized and added to the result of the motion compensation.
Finally, the frame is deblocked, and serves as reference for the next one.</li>
</ul>

<p>0.9.5.3</p>
<ul>
<li>Mainly a bugfixe ( several filters were affected by a silly bug , and MVCompensate now do padded motion compensation,
and compensate also the chroma ( though it rounds the vector to odd coordinates to do so )</li>
<li>A new feature, as asked by Fizick, for mvcompensate :
"scbehavior", a boolean set to true by default, will allow you to keep the previous frame over a scenechange if you set it to false.</li>
</ul>

<p>0.9.5.2</p>
<ul>
<li>MVMask has two new parameters : showsad (bool) which allows to build the mask of the SAD values instead of the mask of the vectors' length. Ysc allows you to set the value taken by the mask on scene changes</li>
<li>MVCompensate : behavior modification on scene changes. Now, the current frame is left untouched if a scene change was detected.</li>
<li>New filter : MVSCDetection, with one parameter, Ysc, which works as previously.</li>
<li>MVInterpolate, MVConvertFPS and MVBlur are enabled, but may be buggy ( though I wasn't able to make MVConvertFPS crash )</li>
</ul>

<p>0.9.5</p>
<ul>
  <li>Очень существенно переписано
исполняемое ядро. Вектора теперь
ищутся с точностью от пикселя и выше (в связи с тем, что никакой другой
фильтр, кроме MVShow, еще не может работать с большей точностью).
Механизм поиска сейчас быстрый (что не обязательно подразумевает, что и
фильтры, использующие его информацию тоже быстрые)</li>
  <li>Новый параметр в MVAnalyse : lambda. Смотри документацию выше о
том, как он работает</li>
  <li>MVDenoise работает лучше.</li>
</ul>
<p>0.9.4</p>
<ul>
  <li>Вектора можно сохранять в файле. С этой
целью в фильтре MVAnalyse
добавлен параметр filename="C:\foo.bar". Если файл не существует,
вектора будут сохраняться в нем. Если он существует, то вектора будут
из него читаться. Но обратите внимание:
    <ul>
      <li>Файл для целого фильма будет около 500 MБ</li>
      <li>Сохранение / считывание файла требует в этот момент наличие
прямого доступа к кадрам, потому его можно использовать только во время
кодирования фильма, но не в процессе случайного доступа к его кадрам.</li>
      <li>Прирост скорости не настолько велик, как я надеялся, так как
SAD-ы не могут быть сохранены (это требует слишком много места) и
должны пересчитываться.</li>
    </ul>
  </li>
  <li>Фильтр
MVDenoise теперь работает на 5 кадрах, и его параметры
теперь "thT" и "sadT" (смотрите в документации как они работают). Он
работает&nbsp; весьма приятно (очень хорошо для тяжелого
шумоподавления)</li>
  <li>Порог детектирования смены сцен
слегка изменен. Теперь блок
изменяется, если его SAD больше thSCD1. По умолчанию thSCD1 = 300, и
thSCD2 = 130. Работает хорошо (лучше, чем предыдущий SCD-механизм).</li>
</ul>
<p>0.9.3</p>
<ul>
  <li>Последние чистки в механизме поиска векторов.Теперь должно
работать слегка быстрее</li>
  <li>Больше
параметров поиска, устанавливаемых пользователем, особенно
алгоритм поиска. Смотри документацию </li>
  <li>Обеспечивается
работа клиент / сервер. Теперь сначала
используется MVAnalyse, а потом уже желаемый фильтр. Смотри
документацию и примеры, которые я изменил.</li>
  <li>MVCompensate отделена от MVShow (это более логично). На данный
момент не работает с цветовыми компонентами (поведение аналогично
MVShow в последних версиях)</li>
  <li>Некоторые чистки в MVBlur / MVInterpolate / MVConvertFPS, но
работают они примерно так-же. Теперь MVBlur выполняет размытие в
пределах кадра, а не между текущим и предыдущим кадром.</li>
  <li>Проделано
половина работы для записи векторов в файл. Но
результирующий файл будет больше (около 500 MБ - 1 ГБ, я думаю).</li>
  <li>MVDenoise слегка быстрее (по крайней мере - должен быть)</li>
  <li>Оптимизировано копирование в фильтре, благодаря функциям
копирования AviSynth.</li>
  <li>MVShow может отображать
средний SAD компенсации (с использованием
showsad = true)</li>
</ul>
<p>0.9.2.1</p>
<ul>
  <li>Возвращена функция MVInterpolate.</li>
  <li>MVConvertFPS должна работать и на последних кадрах клипа</li>
</ul>
<p>0.9.2</p>
<ul>
  <li>MVInterpolate больше не существует.</li>
  <li>MVBlur и MVConvertFPS улучшены. Они так же обзавелись новыми
параметрами, смотрите об этом в документации.</li>
  <li>в MVShow возвращен режим компенсации ( MVShow(cm = true) )</li>
</ul>
<p>0.9.1 - 12.05.2004</p>
<ul>
  <li>Первая версия переименованная в MVTools. </li>
</ul>
<p>0.1-0.6 - Выпущена 24.01.2004 - 01.04.2004 by Manao</p>
<ul>
  <li>Первые публичные версии MotionVectors (Motion.dll). </li>
</ul>
</small>

<p><kbd>$English Date: 2006/09/17 20:32:46 $<br>
Начальный русский перевод и дополнения 08.07.2005 Turyst04 <a
 href="mailto:Turyst04@nextmail.ru">Turyst04@nextmail.ru</a><br>
Редакция и дополнения 14.07.2005 Fizick http://bag.hotmail.ru<br>
Подробное введение, добавленные функции 31.10.2005-17.09.2006 Fizick http://avisynth.org.ru</kbd></p>
</body>
</html>
