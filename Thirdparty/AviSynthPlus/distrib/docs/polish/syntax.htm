<html>
<head>
<meta http-equiv="Content-type" content="text/html; charset=iso-8859-2" />
<title>Jak zacz±æ</title>
<STYLE type=text/css>
</STYLE>
<link rel="stylesheet" type="text/css" href="corefilters/style2.css">
</head>
<h1><span class="titresmall"><a name="Gettingstarted"></a>Jak zacz±æ</h1>
<p>W zasadzie, AviSynth dzia³a nastêpuj±co: najpierw tworzysz prosty dokument tekstowy ze specjalnymi poleceniami,
który nazywa siê skryptem, a polecenia odnosz± siê do jednego lub wiêcej klipów video i filtrów, które chcesz u¿yæ. Nastêpnie uruchamiasz aplikacjê video, tak± jak np. VD (VirtualDub), i wczytujesz do niej skrypt. W tym
w³a¶nie momencie AviSynth zaczyna dzia³aæ. Otwiera klipy video, które wskaza³e¶ w skrypcie, uruchamia okre¶lone filtry i wyprowadza materia³ wyj¶ciowy do aplikacji video. Jednak¿e aplikacja nie jest ¶wiadoma, ¿e w tle pracuje AviSynth. Zamiast tego, aplikacja s±dzi, ¿e jest to bezpo¶redni plik AVI z HDD.&nbsp;<br>
Ta wersja AviSynth jest wa¿nym, wewnêtrznym uaktualnieniem.<p>
<p><b><u>Edycja liniowa<br>
</u></b>Prost± rzecz±, któr± mo¿esz wykonaæ w AviSynth jest rodzaj edycji
podobny do tego co w VD. Skrypty s± proste do napisania, poniewa¿, je¶li nie chcesz, nie musisz martwiæ siê o zmienne ani o skomplikowane sk³adnie.
Dla próby, stwórz plik o nazwie <i> test.avs</i> i umie¶æ w nim nastêpuj±c± pojedyncz± liniê tekstu:
<div align="center">
  <center>

<table width="99%" border="1" cellspacing="0" cellpadding="4">
  <tr>
    <td><p>
      <p1>Version</p1>
    </p></td>
  </tr>
</table>

  </center>
</div>

<p>Teraz otwórz ten plik w jakim¶ odtwarzaczu video (chocia¿by w Windows
Media Player'ze). Powiniene¶ zobaczyæ dziesiêciosekundowy klip video wy¶wietlaj±cy
numer wersji u¿ywanego AviSynth&#8217;a oraz notkê o prawach autorskich.&nbsp;<br>
<b>
Version</b> jest tym co nazywa siê <i> "filtrem ¼ród³owym&quot;</i>, oznacz to, ¿e zamiast
modyfikowania, tworzy klip video. Pierwszym poleceniem w skrypcie AviSynth zawsze
powinno byæ wywo³aniem filtru ¼ród³owego.<br>
<br>
Do poprzedniego skryptu dodaj drug± linijkê poleceñ, tak by skrypt wygl±da³ nastêpuj±co:
<div align="center">
  <center>

<table width="99%" border="1" cellspacing="0" cellpadding="4">
  <tr>
    <td><p>
      <p1>Version<br>
      ReduceBy2</p1>
    </p></td>
  </tr>
</table>

  </center>
</div>

<p>Ponownie odtwórz skrypt w jakim¶ player'ze. Tym razem równie¿ powiniene¶
zobaczyæ notkê o prawach autorskich, jednak¿e w zmniejszon± o po³owê
rozdzielczo¶ci. <b> ReduceBy2</b> jest <i> "filtrem transformacyjnym&quot;</i>,
oznacza to, ¿e pobiera poprzedni klip video i modyfikuje go w jaki¶ sposób. Mo¿esz ³±czyæ ze sob± wiele filtrów transformacyjnych, tak jak w VD.<br>
<br>
Dodaj kolejn± linijkê skryptu, powoduj±c± ¶ciemnienie siê klipu video do czerni na jego koñcu:
<div align="center">
  <center>

<table width="99%" border="1" cellspacing="0" cellpadding="4">
  <tr>
    <td><p>
      <p1>Version<br>
      ReduceBy2<br>
      FadeOut(24)</p1>
    </p></td>
  </tr>
</table>

  </center>
</div>

<p>Ponownie odtwórz skrypt. Klip powinien byæ taki sam jak poprzedni, ale
tylko przez dziewiêæ pierwszych sekund, w ostatniej sekundzie, powinien spokojnie ¶ciemniaæ siê do uzyskania czerni.<br>
Filtr <b> FadeOut</b> przyjmie numeryczny argument, który wskazuje liczb± klatek podlegaj±ce ¶ciemnianiu. Video wytworzone przez filtr
<b> Version</b> ma prêdko¶æ klatek równ± 24 (fps=24, <i>fps: frames per
second - klatki na sekundê</i>), wiêc argument równy 24 dla <b> FadeOut</b> sprawi, i¿ ¶ciemnianie rozpocznie siê w ostatniej sekundzie trwania klipu.<br>
Du¿o czasu zajmuje oczekiwanie na rozpoczêcie ¶ciemniania, by skróciæ ten czas
nale¿y u¿yæ filtra <b>Trim</b>.&nbsp;<br>
 Klip wytworzony przez <b> Version</b> ma d³ugo¶æ 240 klatek (24 fps, 10
sekund). AviSynth rozpoczyna numeracjê klatek od 0, wiêc klip posiada numeracjê klatek od 0 do 239. Filtr
<b> FadeOut</b> dodaje jedn±, dodatkow± klatkê na koñcu klip, czyli nasz klip bêdzie mia³ numeracjê klatek od 0 do 240.&nbsp;<br>
<br>
By pozbyæ siê pierwszych 192 klatek (8 sekund, 192/24=8), zmodyfikuj poprzedni skrypt dopisuj±c kolejn± linijkê tekstu:
<div align="center">
  <center>

<table width="99%" border="1" cellspacing="0" cellpadding="4">
  <tr>
    <td><p>
      <p1>Version<br>
      ReduceBy2<br>
      FadeOut(24)<br>
      Trim(192,240) # ucina pierwsze 8 sekund</p1>
    </p></td>
  </tr>
</table>

  </center>
</div>

<p>Po raz pierwszy u¿yli¶my komentarza. Komentarz rozpoczyna siê od znaku # i jest aktywny do koñca linii
(AviSynth ignoruje wszystko co jest po znaku #).<br>
Filtr <b> Trim</b> przyjmuje dwa argumenty oddzielone przecinkiem: pierwsz± i
ostatni± klatkê, które wskazuj± na aktywny zakres klatek (pozosta³a czê¶æ klipu video jest ignorowana). Je¶li ostatni± klatkê okre¶lisz
jako 0, bêdzie to oznacza³o &quot;eof&quot; (<i>end of file - koniec pliku)</i>, wiêc powy¿sze wywo³anie
filtra <b> Trim</b> mog³oby wygl±daæ tak: <i>Trim(192,0)</i>.&nbsp;<br>
Okre¶lanie zakresu klatek w ten sposób jest dosyæ ¿mudne. Jest jednak prostszy sposób.
Otwórz czê¶ciowo ukoñczony skrypt w VD lub innej aplikacji, która pokazuje numer wy¶wietlanej klatki. Mo¿esz równie¿ u¿yæ filtra
<b> ShowFrameNumber</b>, który wy¶wietla na ka¿dej klatce jej numer.<br>
<br>
W praktyce, bardziej przydatnym filtrem ¼ród³owym ni¿ <b> Version</b> jest <b> AVISource</b>, który wczytuje plik AVI (lub jeden z kilku innych typów pliku) z HDD. Je¶li masz
pod rêk± jaki¶ plik AVI spróbuj zastosowaæ te same filtry dla swojego
klipu:
<div align="center">
  <center>

<table width="99%" border="1" cellspacing="0" cellpadding="4">
  <tr>
    <td><p>
      <p1>AVISource("d:\capture.avi")   # oczywi¶cie podajesz swoj± ¶cie¿kê dostêpu&nbsp;<br>
 ReduceBy2&nbsp;<br>
 FadeOut(15)&nbsp;<br>
      Trim(192,0)</p1>
    </td>
  </tr>
</table>

  </center>
</div>

<p>Nawet pojedyncza linia skryptu zawieraj±ca tylko polecenie <b> AVISource</b> mo¿e byæ przydatna
przy korzystaniu z aplikacji przyjmuj±cych pliki AVI, które maj± wielko¶æ poni¿ej 2 GB, dziêki temu skryptowi zabezpieczenie to zostanie ominiête
(najczê¶ciej dotyczy to materia³u DV).
<p><u><b>Edycja nieliniowa<br>
</b>
</u>Stwórz plik AVS z nastêpuj±cym skryptem:

<table width="99%" border="1" cellspacing="0" cellpadding="4">
  <tr>
    <td><p>
      <p1>StackVertical(Version, Version)</p1>
    </p></td>
  </tr>
</table>

<p>Teraz odtwórz go. Rezultat: wyj¶ciowy materia³ video zawiera dwie identyczne notki o prawach autorskich, przy czym jedna jest nad drug±.&nbsp;<br>
Zamiast przyjmowania argumentu numerycznego lub znakowego, <b> StackVertical</b>
przyjmuje, jako argumenty, klipy video. W tym skrypcie filtr <b> Version</b> jest okre¶lony dwa razy. Ka¿de powtórzenie zwróci kopie klipu
<b> Version</b>. Te dwa klipy podane s± do <b> StackVertical</b>, który ³±czy je razem (bez wiedzy sk±d pochodz±).&nbsp;<br>
Jednym z przydatniejszych <i> filtrów ³±cz±cych</i> jest <b> UnalignedSplice</b>, który ³±czy video metod±
&quot;ete&quot; (<i>end to end - koniec z koñcem)</i>. Poni¿szy skrypt wczytuje trzy pliki AVI i ³±czy je
razem:

<table width="99%" border="1" cellspacing="0" cellpadding="4">
  <tr>
    <td><p>
      <p1>UnalignedSplice(AVISource("d:\capture.00.avi"), AVISource("d:\capture.01.avi"), AVISource("d:\capture.02.avi"))</p1>
    </p></td>
  </tr>
</table>

<p>Oba filtry, <b> StackVertical</b> i <b> UnalignedSplice</b>, mog± przyj±æ wiêcej ni¿ dwa argumenty, ale nie wiêcej ni¿ sze¶ædziesi±t. Jako
skrót dla filtra <b> UnalignedSplice</b> mo¿esz u¿yæ operatora dodawania (+). Dla przyk³adu, stwórz podobny skrypt do poni¿szego
(ma on identyczne dzia³anie jak powy¿szy przyk³ad):

<table width="99%" border="1" cellspacing="0" cellpadding="4">
  <tr>
    <td><p>
      <p1>AVISource("d:\capture.00.avi") + AVISource("d:\capture.01.avi") + AVISource("d:\capture.02.avi")</p1>
    </p></td>
  </tr>
</table>

<p>Teraz przypu¶æmy, ¿e przechwytujesz video w aplikacji, która równie¿ umo¿liwia zapis pliku AVI podzielonego na czê¶ci, ale audio jest w
jednym, oddzielnym pliku WAV. Czy mo¿emy co¶ zaproponowaæ? Oczywi¶cie:

<table width="99%" border="1" cellspacing="0" cellpadding="4">
  <tr>
    <td><p>
      <p1>AudioDub(AVISource("d:\capture.00.avi")+AVISource("d:\capture.01.avi")+AVISource("d:\capture.02.avi"), WAVSource("d:\audio.wav"))</p1>
    </p></td>
  </tr>
</table>

<br>
<h1><span class="titresmall"><a name="Syntax">Sk³adnia</h1>
<p><u><b>Przypisanie do zmiennej<br>
</b></u>Skrypt AviSynth sk³ada siê z ró¿nych poleceñ, równie¿ podobnych do tego:
<table width="99%" border="1" cellspacing="0" cellpadding="4">
  <tr>
    <td><p>
      <p1>zmienna = wyra¿enie</p1>
    </td>
  </tr>
</table>
<p>W przyk³adzie tym, <i> wyra¿enie</i> jest oceniane i w rezultacie przydzielone do
<i>zmienna</i>.</p>
<table width="99%" border="1" cellspacing="0" cellpadding="4">
  <tr>
    <td><p>
      <p1>wyra¿enie</p1>
    </td>
  </tr>
</table>
<p>Natomiast tym razem, <i> wyra¿enie</i> jest oceniane i w rezultacie przydzielone do specjalnej zmiennej klipu -
<i> last</i>. Oznacza to samo co:&nbsp;</p>
<table width="99%" border="1" cellspacing="0" cellpadding="4">
  <tr>
    <td><p>
      <p1>last = wyra¿enie</p1>
    </td>
  </tr>
</table>
<p>Koniec takiego skryptu zawsze wygl±da tak:&nbsp;</p>
<table width="99%" border="1" cellspacing="0" cellpadding="4">
  <tr>
    <td><p>
      <p1>return zmienna</p1>
    </td>
  </tr>
</table>
<p>Powy¿ej <i>zmienna</i> zostanie oceniano i u¿ywana jako: <i>&quot;zwróæ warto¶æ</i><i>"</i> skryptu - jest to klip video, który bêdzie widziany przez aplikacjê podczas otwarcia pliku AVS.&nbsp;<br>
Podstawowa forma wyra¿enia która wywo³uje funkcjê jest nastêpuj±ca:&nbsp;</p>
<table width="99%" border="1" cellspacing="0" cellpadding="4">
  <tr>
    <td><p><p1>funkcja(args)</p1>
    </td>
  </tr>
</table>
<p>Funkcje klipu zawsze wytwarzaj± nowy klip video i nigdy nie modyfikuj± istniej±cego.
<b><i> args</i></b> jest list± argumentów oddzielonych przecinkiem. Lista ta mo¿e byæ pusta (oznacza to przyjêcie domy¶lnych warto¶ci dla wszystkich lub niektórych argumentów). Je¶li filtr, jako pierwszy argument, spodziewa siê klipu video, a argument ten nie jest dostarczony to zostanie u¿yty klip ze specjalnej zmiennej
<i> last</i>.&nbsp;<br>
Filtry AviSynth mog± przyjmowaæ nazwy argumentów. Nazwy argumentów mog± byæ okre¶lone w obojêtnie jakiej kolejno¶ci, a filtr wybierze domy¶ln± warto¶æ dla ka¿dego, który zostanie ominiêty. Nazwy argumentów s± dodatkowe, ale przy ich wpisaniu wiadomo czego dotyczy dana warto¶æ.</p>
<table width="99%" border="1" cellspacing="0" cellpadding="4">
  <tr>
    <td> <p>
      <p1>Subtitle(&quot;Hello, World!&quot;, 100, 200, 0, 999999, &quot;Arial&quot;,
      24, $00FF00)</p1>
    </p></td>
  </tr>
</table>
<p>poni¿szy skrypt jest bardziej czytelny dla osoby czytaj±cej skrypt (równie¿
w przypadku edycji skryptu, np. nastêpnego dnia):</p>
<table width="99%" border="1" cellspacing="0" cellpadding="4">
  <tr>
    <td> <p>
      <p1>Subtitle(&quot;Hello, World!&quot;, text_color=$00FF00, x=100,
      y=200)</p1>
    </p></td>
  </tr>
</table>
<p>i jak widaæ w pierwszym przyk³adzie kolejno¶æ argumentów jest z góry
okre¶lona i nie mo¿e zostaæ zmienione, natomiast w przyk³adzie drugim, dziêki
dodaniu nazw argumentom ich kolejno¶æ nie jest istotna.<br>
<br>
Alternatywn± sk³adni± (zwan± <i>&quot;notacja OOP&quot;</i>) dla funkcji klipów jest:&nbsp;</p>
<table width="99%" border="1" cellspacing="0" cellpadding="4">
  <tr>
    <td> <p>
      <p1>wyra¿enie.funkcja(args), np.: Version.ReduceBy2.FadeOut(15)</p1>
    </td>
  </tr>
</table>
<p>jest to równowa¿ne do:</p>
<table width="99%" border="1" cellspacing="0" cellpadding="4">
  <tr>
    <td> <p>
      <p1>funkcja(wyra¿enie, args), np.: FadeOut(15, ReduceBy2(Version))</p1>
    </td>
  </tr>
</table>
<p>Jedyn± wad± <i> notacji OOP</i> jest to, i¿ mo¿e byæ u¿yta tylko z filtrami, które przyjmuj± jako argument tylko jeden klip
video.<br>
Wszystkie funkcje AviSynth wytwarzaj± okre¶lon± liczbê klatek wyj¶ciowych i
okre¶lon± prêdko¶æ klatek (fps). AviSynth, przed wczytaniem skryptu, wie jak d³ugi bêdzie materia³ wyj¶ciowy i jaki bêdzie mia³ fps, wylicza to z "wyciêtych sekwencji&#8221; wszystkich klipów wej¶ciowych.
Wyliczane to ma miejsce w trakcie otwarcia skryptu.<br>
<br>
Jak ju¿ dowiedzieli¶my siê z jednego z powy¿szych przyk³adów, AviSynth
ignoruje wszystko co znajduje siê po znaku #, czyli wszelkiego rodzaju
komentarze. Twórcy tego narzêdzia postarali siê równie¿ o to, by nie by³o
problemu z wielko¶ci± liter, tak wiêc aViSouRCe jaki i AVISource s± równoznaczne.
Znak \&nbsp;jest przydatny przy poleceniu, który jest d³u¿szy ni¿ jedna
linijka tekstu i chcemy go <i>&quot;przerzuciæ&quot; </i>do nastêpnej linii w
okre¶lonym miejscu, najlepiej odwzorowuj± to poni¿sze przyk³ady (wszystkie
trzy mo¿liwe wywo³ania tego skryptu, ze znakiem \ i bez, s± sobie równowa¿ne):</p>
<table width="99%" border="1" cellspacing="0" cellpadding="4">
  <tr>
    <td height="18", width="25%">
      <p><p1>Subtitle
      (&quot;Test-Text&quot;) </p1>
    </td>
    <td height="18", width="25%"> <p>
      <p1>Subtitle (&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      \&nbsp;<br>
      &quot;Test-Text&quot;)</p1>
    </td>

<td height="18", width="25%"> <p>
      <p1>Subtitle (  \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      &quot;Test-<br>
      Text&quot;)</p1>
    </td>

  </tr>
</table>
<p><b><u>Zmienne:</u></b>&nbsp;<br>
Nazwy zmiennych mog± byæ d³u¿sze ni¿ 50 znaków i mog± zawieraæ litery, cyfry, i podkre¶lenia (_), ale nie mog± zawieraæ innych znaków
oraz nie mog± zaczynaæ siê cyfr±.&nbsp;Nastêpuj±ce typy zmiennych s±
wykorzystywane w AviSynth:<br>
<b><i>
clip</i></b>: klip video (zawiera video i/lub audio)<br>
<b><i>
string</i></b>: wpisywany jest w cudzys³owach i zawiera wszystkie znaki oprócz znaków cytuj±cych (powodowa³oby to b³±d, kiedy dana warto¶æ string siê koñczy kiedy zaczyna) oraz oprócz podwójnych apostrofów<br>
<b><i>
int</i></b>: liczba ca³kowita<br>
<b><i>
float</i></b>: liczba zmiennopozycyjna (u³amek dziesiêtny)<br>
<b><i>
val</i></b>: typ zmiennej, gdy nie wiadomo czy jest to <b><i> int</i></b> czy <b><i> float</i></b><br>
<b><i>
bool</i></b> : przyjmuje warto¶ci TRUE (prawda) lub FALSE (fa³sz)<br>
<b><i>
hexadecimal numbers</i></b>: liczby ca³kowite, które rozpoczynaj± siê znakiem $. Przewa¿nie, tego typu, u¿ywa siê do okre¶lenia koloru, np. $FF8800 jest odcieniem pomarañczowego<br>
<b><i>
global</i></b>: definicja zmiennej globalnej, która mo¿e byæ u¿yta przez wszystkie funkcje
zdefiniowane przez u¿ytkownika w skrypcie g³ównym<br>
<br>
Poni¿ej s± dwa przyk³ady wykonuj±ce t± sam± czynno¶æ, z t± ró¿nic±, ¿e drugi u¿ywa zmiennej globalnej:</p>
<table width="99%" border="1" cellspacing="0" cellpadding="4">
  <tr>
    <td> <p>
      <p1>AudioDub(AVISource("d:\capture.00.avi")+AVISource("d:\capture.01.avi")+AVISource("d:\capture.02.avi"), WAVSource("d:\audio.wav"))<br>
      <br>
      przejrzy¶ciej mo¿na to zapisaæ tak:<br>
      <br>
  a = AVISource(&quot;d:\capture.00.avi&quot;)&nbsp;<br>
 b = AVISource(&quot;d:\capture.01.avi&quot;)&nbsp;<br>
 c = AVISource(&quot;d:\capture.02.avi&quot;)&nbsp;<br>
 audio = WAVSource(&quot;d:\audio.wav&quot;)&nbsp;<br>
      AudioDub(a+b+c, audio)</p1>
    </td>
  </tr>
</table>
<h1><span class="titresmall"></a><a name="Operators"><br>
Operatory</h1>
<p>Dla wiêkszo¶ci typów zmiennych (clip, int, float, string, bool) mo¿esz u¿yæ nastêpuj±cych operatorów:&nbsp;<br>
== <b> jest równy&nbsp;<br>
</b>
!= <b> nie jest równy<br>
</b>
|| <b> lub&nbsp;<br>
</b>
&amp;&amp; <b> i&nbsp;<br>
</b><br>
Dla typów numerycznych (int, float):&nbsp;<br>
+ <b> dodaje<br>
</b>
- <b>odejmuje<br>
</b>
* <b>mno¿y<br>
</b>
/ <b>dzieli<br>
</b>
% <b> modulo </b> (reszta z dzielenia ca³kowitego)&nbsp;<br>
>= <b> wiêksze lub równe&nbsp;<br>
</b>
&lt;= <b> mniejsze lub równe<br>
</b>
&lt; <b> mniejsze&nbsp;<br>
</b>
> <b> wiêksze&nbsp;</b></p>
<table width="99%" border="1" cellspacing="0" cellpadding="4">
  <tr>
    <td><p><p1>We wcze¶niejszych wersjach AviSynth, wylicza³ wyra¿enia od prawej do lewej co dawa³o b³êdne wyniki:&nbsp;<br>
      <br>
      a = 10 - 5 - 5 w rezultacie 10 - (5 - 5) = 10 zamiast (10 - 5) - 5 = 0 !&nbsp;&nbsp;<br>
      <br>
      B³±d ten zosta³ wyeliminowany! Pocz±wszy od wersji 2.53
      równie¿  mno¿enie i dzielenie jest wykonywane od lewej do prawej (zamiast od prawej do
      lewej)</p1>
    </td>
  </tr>
</table>
<p>dla typu string:&nbsp;<br>
+ <b> dodaje </b> (a raczej scala, je¿eli w dwóch &quot;stringach&#8221; jest znak 1 to w wyniku otrzyma siê 11)<br>
>= <b> wiêksze lub równe</b> (niewra¿liwy przypadek)&nbsp;<br>
&lt;= <b> mniejsze lub równe</b> (niewra¿liwy przypadek)&nbsp;<br>
&lt; <b> mniejsze</b> (niewra¿liwy przypadek)&nbsp;<br>
> <b> wiêksze</b> (niewra¿liwy przypadek)&nbsp;<br>
<br>
dla typu clip:&nbsp;<br>
+ <b> taki same dzia³anie jak filtr UnalignedSplice&nbsp;<br>
</b>
++ <b> taki same dzia³anie jak filtr AlignedSplice&nbsp;<br>
</b>
<br>
dla typu bool:&nbsp;<br>
?: <b> wykonanie kodu warunkowego&nbsp;</b>
</p>
<table width="99%" border="1" cellspacing="0" cellpadding="4">
  <tr>
    <td><p><p1>b = (a==true) ? 1 : 2<br>
      <br>
      oznacza to samo co poni¿szy zapis:<br>
      <br>
      if (a=true) then b=1 else b=2 </p1>
    </td>
  </tr>
</table>
<span class="titresmall"></a><a name="ScriptFunctions"><h1>Funkcje skryptowe</h1>
<p>Danymi wej¶ciowymi i wyj¶ciowym w poni¿szych funkcjach ni s± klipy video, a
jedynie zmienne u¿ywane w skyrpcie.<br>
<br>
<b><u>Funkcje numeryczne:</u></b>
<div align="center">
  <center>
<table border="1" width="99%" cellspacing="0" cellpadding="4">
  <tr>
    <td width="40%"><p1>Floor (float): rzutowanie float na int</td>
    <td width="35%"><p1>Floor(1.2) = 1  Floor(1.6) = 1&nbsp;<br>
      Floor(-1.2) = -2  Floor(-1.6) = -2</td>
  </tr>
  <tr>
    <td width="40%"><p1>Ceil (float): rzutowanie float na int</p></td>
    <td width="35%"><p1>Ceil(1.2) = 2.0  Ceil(1.6) = 2.0&nbsp;<br>
      Ceil(-1.2) = -1  Ceil(-1.6) = -1</td>
  </tr>
  <tr>
    <td width="40%"><p1>Round (float): rzutowanie float na int</p></td>
    <td width="35%"><p1>Round(1.2) = 1  Round(1.6) = 2&nbsp;<br>
      Round(-1.2) = -1  Round(-1.6) = -2</td>
  </tr>
  <tr>
    <td width="40%"><p1>Int(float): rzutowanie float na int (w pobli¿u zera)</td>
    <td width="35%"><p1>Int(1.2) = 1  Int(1.6) = 1&nbsp;<br>
      Int(-1.2) = -1  Int(-1.6) = -1</td>
  </tr>
  <tr>
    <td width="40%"><p1>Float(int): rzutowanie int na float</p></td>
    <td width="35%"><p1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td width="40%"><p1>Frac(float): zwraca czê¶æ u³amkow± z float</td>
    <td width="35%"><p1>	Frac(3.7) = 0.7&nbsp;<br>
      Frac(-1.8) = -0.8</td>
  </tr>
  <tr>
    <td width="40%"><p1>Abs (integer) / Abs(float): warto¶æ bezwzglêdna</td>
    <td width="35%"><p1>Abs(-3.8) = 3.8</p></td>
  </tr>
  <tr>
    <td width="40%"><p1>Sign(int) / Sign(float): zwraca znak liczby: -1, 0 lub 1</p></td>
    <td width="35%"><p1>Sign(-3.5) = -1&nbsp;<br>
  Sign(3.5) = 1&nbsp;<br>
  Sign(0) = 0</td>
  </tr>
  <tr>
    <td width="40%"><p1>HexValue(string): rzutowanie hex na string</p></td>
    <td width="35%"><p1>HexValue ( "FF00" ) = 65280</p></td>
  </tr>
  <tr>
    <td width="40%"><p1>Sin (float): sinus k±ta&nbsp;</td>
    <td width="35%"><p1>&nbsp;</td>
  </tr>
  <tr>
    <td width="40%"><p1>Cos (float): cosinus k±ta</td>
    <td width="35%"><p1>&nbsp;</td>
  </tr>
  <tr>
    <td width="40%"><p1>Pi (): zwraca warto¶æ liczby pi&nbsp;</td>
    <td width="35%"><p1>&nbsp;</td>
  </tr>
  <tr>
    <td width="40%"><p1>Log (float): zwraca logarytm dziesiêtny&nbsp;</td>
    <td width="35%"><p1>&nbsp;</td>
  </tr>
  <tr>
    <td width="40%"><p1>Exp (float): zwraca liczbê e(e=2.71828...) podniesion± do potêgi danej
      przez argument&nbsp;</td>
    <td width="35%"><p1>&nbsp;</td>
  </tr>
  <tr>
    <td width="40%"><p1>Pow (float base, float power) zwraca liczbê <b><i> base</i></b> podniesion± do potêgi
      <b><i> power</i></b></td>
    <td width="35%"><p1>&nbsp;</td>
  </tr>
  <tr>
    <td width="40%"><p1>Sqrt (float): zwraca pierwiastek kwadratowy</td>
    <td width="35%"><p1>&nbsp;</td>
  </tr>
  <tr>
    <td width="40%"><p1>Rand([int max] [, bool scale] [, bool seed]): zwraca losow± liczbê ca³kowit± pomiêdzy 0 a max domy¶lnie:
      <i> max = 32768&nbsp;<br>
    scale = TRUE </i> ( TRUE = tryb normalny, FALSE = tryb modulo)&nbsp;<br>
      <i>    seed = FALSE</i> (TRUE = u¿ywa czasu jako <b><i> seed</i></b>)</td>
    <td width="35%"><p1>Rand(100) = liczba ca³kowita pomiêdzy 0 a 99</td>
  </tr>
  <tr>
    <td width="40%"><p1>Spline (float X,  x1,y1, x2,y2, ...., bool "cubic")  interpolacja warto¶æ
      <b><i> Y</i></b> w punkcie <b><i> X</i></b> u¿ywaj±c punktów
      kontrolnych; powinny byæ przynajmniej dwie pary x/y.  Interpolacja mo¿e byæ u¿yta w przestrzeni (wynikiem jest
      <i> spline</i>) lub w linii (wynikiem jest <i> polygon</i>)</td>
    <td width="35%"><p1>Spline(5, 0,0, 10,10, 20,0, false) = 5&nbsp;<br>
  Spline(5, 0,0, 10,10, 20,0, true) = 7</td>
  </tr>
</table>
  </center>
</div>
<p><b><u>Funkcje znakowe:</u></b></p>
<div align="center">
  <center>
<table width="99%" border="1" cellspacing="0" cellpadding="4">
  <tr>
    <td width="300"><p1>UCase(string): zwraca argument napisany wielkimi
      literami</td>
    <td width="*%%"><p1>UCase(&quot;AviSynth&quot;) = &quot;AVISYNTH&quot;</td>
  </tr>
  <tr>
    <td width="300"><p1>LCase(string): zwraca argument napisany ma³ymi literami</td>
    <td width="*%%"><p1>LCase(&quot;AviSynth&quot;) = &quot;avisynth&quot;</td>
  </tr>
  <tr>
    <td width="300"><p1>RevStr(string): zwraca argument napisany w wspak</td>
    <td width="*%%"><p1>RevStr("AviSynth") = &quot;htnySivA&quot;</td>
  </tr>
  <tr>
    <td width="300"><p1>StrLen(string): zwraca ilo¶æ znaków w argumencie</td>
    <td width="*%%"><p1>StrLen("AviSynth") = 8</td>
  </tr>
  <tr>
    <td width="300"><p1>Findstr(string1, string2): zwraca przesuniêcie teksu <b><i> string2</i></b> wzglêdem tekstu
      <b><i> string1</i></b> - inaczej, pozycjê tekstu <b><i> string2</i></b> w tek¶cie
      <b><i> string1</i></b></td>
    <td width="*%%"><p1>Findstr("AviSynth","syn") = 4</td>
  </tr>
  <tr>
    <td width="300"><p1>LeftStr(string, length) / RightStr(string, length): zwraca czê¶æ znaków (licz±c od lewej / prawej) o okre¶lonej ilo¶ci</td>
    <td width="*%%"><p1>LeftStr("AviSynth",3) = &quot;Avi&quot;</td>
  </tr>
  <tr>
    <td width="300"><p1>MidStr(string, start [, length]): zwraca znaki zaczynaj±c od kolejno¶ci znaku wpisanego w start (pierwszy znak ma start=1) do ustalonej ilo¶ci znaków w length lub wszystkie pozosta³e znaki (je¿eli length jest nie ustalone)</td>
    <td width="*%%"><p1>MidStr("AviSynth",3,2) = &quot;iS&quot;</td>
  </tr>
  <tr>
    <td width="300"><p1>VersionNumber()</td>
    <td width="*%%"><p1>VersionNumber() = 2.07</td>
  </tr>
  <tr>
    <td width="300"><p1>VersionString()</td>
    <td width="*%%"><p1>VersionString() = "AviSynth 2.08 (avisynth.org) 22 nov. 2002&quot;</td>
  </tr>
  <tr>
    <td width="300"><p1>Chr(int): zwraca postaæ ASCII </td>
    <td width="*%%"><p1>&nbsp;</td>
  </tr>
  <tr>
    <td width="300"><p1>Time(string): zwraca ci±g znaków w bie¿±cym systemie czasowym w okre¶lonej formie</td>
    <td width="*%%"><p1>Spis form wyj¶ciowych:<br>
      %a skrócone nazwy dni tygodnia<br>
      %A pe³ne nazwy dni tygodnia<br>
      %b skrócone nazwy miesiêcy<br>
      %B pe³ne nazwy miesiêcy<br>
      %c bie¿±ca data i czas<br>
      %d dni miesi±ca w systemie dziesiêtnym (01 - 31) <br>
      %H godziny w formie 24-godzinnej (00 - 23) <br>
      %I godziny w formie 12-godzinnej (01 - 12) <br>
      %j dni roku w systemie dziesiêtnym (001 - 366) <br>
      %m miesi±ce w systemie dziesiêtnym (01 - 12) <br>
      %M minuty w systemie dziesiêtnym (00 - 59) <br>
      %p wstawia znak A.M./P.M. w formacie 12-godzinnym<br>
      %S sekundy w systemie dziesiêtnym (00 - 59) <br>
      %U tydzieñ w systemie dziesiêtnym; niedziela jest pierwszym dniem
      tygodnia (00 - 53) <br>
      %w dni tygodnia w systemie dziesiêtnym (0 - 6; niedziela=0) <br>
      %W tydzieñ w systemie dziesiêtnym; poniedzia³ek jest pierwszym dniem tygodnia (00 - 53) <br>
      %x bie¿±ca data<br>
      %X bie¿±cy czas <br>
      %y rok bez stulecia w systemie dziesiêtnym (00 - 99) <br>
      %Y rok ze stuleciem w systemie dziesiêtnym<br>
      %z, %Z nazwa strefy czasowej<br>
 %% znak procentu<br>
      <br>
      W przypadku znacz±cego formatu, znak # zmienia jego znaczenie:<br>
      %#a, %#A, %#b, %#B, %#p, %#X, %#z, %#Z, %#% - <i> znak # jest ignorowany</i><br>
      %#c <i> pe³na forma bie¿±cej daty i czasu, np.: &quot;Tuesday, March 14, 1995, 12:41:29&quot;</i><br>
      %#x <i>
      pe³na forma bie¿±cej daty, np.: &quot;Tuesday, March 14, 1995&quot;&nbsp;</i><br>
 %#d, %#H, %#I, %#j, %#m, %#M, %#S, %#U, %#w, %#W, %#y, %#Y - <i> znak # usuwa
      wyprowadzane zera (je¶li s±), np.: %d - &quot;05&quot;, a %#d -
      &quot;5&quot;</i></td>
  </tr>
</table>
  </center>
</div>
<p><b><u>Konwersje (rzutowanie):</u></b></p>
<div align="center">
  <center>
<table width="99%" border="1" cellspacing="0" cellpadding="4">
  <tr>
    <td width="40%"><p1>Value(string): zwraca warto¶æ string'u</td>
    <td width="35%"><p1>Value( "-2.7" ) = 2.7</p></td>
  </tr>
  <tr>
    <td width="40%"><p1>String(float / int / string): rzutuje liczbê (int, float) na string</td>
    <td width="35%"><p1>Subtitle( "Clip height is " + String(last.height) )<br>
    </p></td>
  </tr>
</table>
  </center>
</div>
<p><b><u>Funkcje testowe:</b></u><br>
<p>IsBool (var)&nbsp;<br>
IsInt (var)&nbsp;<br>
IsFloat (var)&nbsp;<br>
IsString (var)&nbsp;<br>
IsClip (var)&nbsp;<br>
<br><b><u>Inne funkcje:</b></u><br>
Select(index, item0 [, item1...]): zwraca warto¶æ wskazan± przez index
(0=item0); warto¶ci mog± byæ ka¿dego typu<br>
Defined (var): definicja dodatkowego parametru we w³asnej funkcji<br>
Default (x, d): zwraca x je¶li Defined(x), w innym przypadku zwraca d&nbsp;<br>
Exist(filename): zwraca TRUE lub FALSE po sprawdzeniu czy plik istnieje<br>
NOP zwraca NULL, s³u¿y do wykonania warunku z nie zwracan± warto¶ci±, tak± jak import.<br>
Eval (string)&nbsp;<br>
Apply (func-string, arg,...): Eval("f(x)") jest równoznaczne do f(x), a to jest równoznaczne do Apply("f", x))&nbsp;<br>
<br>
Funkjcê Eval mo¿na zosta³a wykorzystana w poni¿szym przyk³adzie:</p>
<div align="center">
  <center>
<table border="1" cellpadding="4" cellspacing="0" width="99%">
  <tr>
    <td><p><p1>Settings = "352, 288" Eval( "BicubicResize(" + settings + ")" )</td>
  </tr>
</table>
  </center>
</div>
<p>Import(filename): wczytuje zawarto¶æ innego skryptu AviSynth (importuje tekst innego skryptu)&nbsp;<br>
<br>
By w swoich funkcjach informowaæ o b³êdach nale¿y u¿yæ funkcji:
Assert (bool, string error-message)<br>
Funkcja Try... Catch jest funkcj± sprawdzaj±c±, czyli dzia³a w przypadku
wyst±pienia b³êdu:&nbsp;</p>
<div align="center">
  <center>
<table border="1" cellpadding="4" cellspacing="0" width="99%">
  <tr>
    <td width="100%"><p1>Try {&nbsp;<br>
      &nbsp;&nbsp;&nbsp; AviSource(&quot;file.avi")<br>
      }&nbsp;<br>
 Catch(err_msg) {<br>
      &nbsp;&nbsp;&nbsp; Blackness.Subtitle(err_msg)<br>
      }</td>
  </tr>
</table>
  </center>
</div>
<p><u><b>Funkcje uruchomieniowe<br>
</b></u>Mamy równie¿ do dyspozycji filtry warunkowe, które oceniaj± skrypt w
trakcie przetwarzania klatki, wiêc mo¿na zmieniaæ warto¶æ zmiennej przed dan± klatk±.
Poni¿szy, prosty przyk³ad wylicza ¶redni± warto¶æ lumy dla ka¿dej klatki:</p>
<div align="center">
  <center>
<table border="1" cellpadding="4" cellspacing="0" width="99%">
  <tr>
    <td width="100%"><p1>Version() # tworzy klip testowy<br>
      ConvertToYV12 # potrzebujemy przestrzeni kolorów YV12&nbsp;<br>
 FadeIn(10) # stworzy zmianê w kana³ach lumy&nbsp;<br>
  ScriptClip(" Subtitle(String(AverageLuma())) ")&nbsp; # ocenia Subtitle(...) dla ka¿dej klatki&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      #
      dane wyj¶ciowe AverageLuma s± rzutowane do<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      # string i wy¶wietlane na klipie wej¶ciowym<br>
      ConvertToRGB # zamiana przestrzeni kolorów na RGB</td>
  </tr>
</table>
  </center>
</div>
<h1><span class="titresmall"></a><a name="ControlFunctions"><br>
Funkcje kontrolne</h1>
<p>SetMemoryMax(int): ustala maksymaln± pamiêæ, któr± wykorzysta AviSynth (w MB)<br>
W kilku poprzednich wersjach domy¶ln± warto¶ci± dla tej funkcji by³a warto¶æ 5MB, która,
jak siê okaza³o, by³a zbyt ma³a. Je¶li napotka³e¶ jaki¶ problem (np. wolna prêdko¶æ) spróbuj zmieniæ warto¶æ tej funkcji na chocia¿ 32MB.&nbsp;<br>
<br>
SetWorkingDir(string): ustala domy¶lny katalog dla AviSynth<br>
Nadaje siê wy³±cznie prosto wczytuj±cym klipom ¼ród³owym, itd. Nie dotyczy automatycznie wczytywanych plugin&#8217;ów. Zwraca warto¶æ: 0 je¶li zadanie zosta³o wykonane pomy¶lnie, w innym
przypadku zwraca -1<br>
<h1><span class="titresmall"></a><a name="ClipProperties">W³a¶ciwo¶ci klipu</h1>
<p>Poni¿sze filtry jako argument wymagaj± tylko jednego klipu video i zwracaj± jego
okre¶lon± w³a¶ciwo¶æ:&nbsp;<br>
Width(clip)&nbsp;<br>
Height(clip)&nbsp;<br>
Framecount(clip)&nbsp;<br>
Framerate(clip)&nbsp;<br>
Audiorate(clip)&nbsp;<br>
Audiolength(clip)&nbsp;<br>
Audiochannels(clip)&nbsp;<br>
Audiobits(clip)&nbsp;<br>
IsRGB(clip)&nbsp;<br>
IsRGB24(clip)<br>
IsRGB32(clip)<br>
IsYUY2(clip)&nbsp;<br>
IsYV12(clip)&nbsp;<br>
IsYUV(clip)&nbsp;<br>
IsPlanar(clip)&nbsp;<br>
IsInterleaved(clip)&nbsp;<br>
IsRGB24(clip)(clip)&nbsp;<br>
IsRGB32(clip)(clip)&nbsp;<br>
IsFieldBased(clip)&nbsp;<br>
IsFrameBased(clip)&nbsp;<br>
GetParity(clip)&nbsp;<br>
<br>
Nie zapomnij, ¿e filtry te mo¿esz u¿ywaæ z ukryt± zmienn± <i>last</i> lub w notacji
OOP:</p>
<div align="center">
  <center>
<table border="1" cellpadding="4" cellspacing="0" width="99%">
  <tr>
    <td width="100%"><p1>BilinearResize(Width/2, Height/2)&nbsp;<br>
      <br>
      tak samo jak<br>
      <br>
      BilinearResize(Width(Last)/2, Height(Last)/2)&nbsp;<br>
      <br>
      tak samo jak<br>
      <br>
      BilinearResize(Last.Width / 2, Last.Height / 2)</td>
  </tr>
</table>
  </center>
</div>
<h1><span class="titresmall"></a><a name="userdefined"><br>
Funkcje w³asne</h1>
<p>Mo¿esz zdefiniowaæ swoj± w³asn± funkcjê. Najlepszym wyja¶nieniem jest poni¿szy przyk³ad:
<div align="center">
  <center>
<table border="1" cellpadding="4" cellspacing="0" width="99%">
  <tr>
    <td width="100%"><p1>Function NTSC2PAL(clip c)&nbsp;<br>
 {&nbsp;<br>
      &nbsp;&nbsp;&nbsp; Assert(c.height == 480, "NTSC2PAL: klip wej¶ciowy musi mieæ wysoko¶æ 480 linii")<br>
      &nbsp;&nbsp;&nbsp; Bob(c, height=576)<br>
      &nbsp;&nbsp;&nbsp; return Weave()<br>
      }</td>
  </tr>
</table>
  </center>
</div>
<p>Funkcjê mo¿na równie¿ zdefiniowaæ tak:&nbsp;</p>
<div align="center">
  <center>
<table border="1" cellpadding="4" cellspacing="0" width="99%">
  <tr>
    <td width="100%"><p1>function TRANSITION(clip clip, int start,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      int expo, int overlap)&nbsp;<br>
 {&nbsp;<br>
      &nbsp;&nbsp;&nbsp; return ( start >= clip.framecount-expo ?&nbsp;<br>
      &nbsp;&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp; Trim(clip,start,0) :&nbsp;<br>
      &nbsp;&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp; Dissolve(Trim(clip,start,start+expo-1),&nbsp;<br>
      &nbsp;&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRANSITION(clip,start+expo,expo,overlap),&nbsp;<br>
      &nbsp;&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; overlap&nbsp;<br>
      &nbsp;&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp;<br>
 }</td>
  </tr>
</table>
  </center>
</div>
<h1></a><a name="multiclip">Funkcje z wiêcej ni¿ jednym klipem wej¶ciowym</h1>
<p>Poni¿sze funkcje ³±cz± w okre¶lony sposób co najmniej dwa klipy. W poni¿ej tabeli s± tylko
w³a¶ciwo¶ci klipów wynikowych.&nbsp;Pamiêtaj, ¿e przy jakimkolwiek ³±czeniu, wszystkie klipy musz± mieæ t± sam± przestrzeñ kolorów i t± sam± rozdzielczo¶æ.
<div align="center">
  <center>
<table border="1" cellpadding="4" cellspacing="0" width="99%">
  <tr>
    <td width="20%" align="center"><p1><b>nazwa filtru</b></td>
    <td width="20%" align="center"><p1><b>prêdko¶æ klatek (fps)</b></td>
    <td width="20%" colspan="2" align="center"><b>ilo¶æ klatek</b></td>
    <td width="20%" align="center"><p1><b>audio</b></p></td>
    <td width="20%" align="center"><p1><b>czêstotliwo¶æ próbkowania audio</b></td>
  </tr>
  <tr>
    <td width="20%" align="center"><p1><b>AlignedSplice, UnalignedSplice</b></p1></td>
    <td width="20%"><p1>pierwszego klipu</p1></td>
    <td width="10%"><p1>suma klatek wszystkich klipów</td>
    <td width="10%"><p1>&nbsp;</td>
    <td width="20%"><p1>zobacz opis filtru</td>
    <td width="20%"><p1>pierwszego klipu</td>
  </tr>
  <tr>
    <td width="20%" align="center"><p1><b>Dissolve</b></p></td>
    <td width="20%"><p1>&nbsp;</td>
    <td width="10%"><p1>suma klatek wszystkich klipów odj±æ warto¶æ argumentu <b><i>overlap</i></b></td>
    <td width="10%"><p1>&nbsp;</td>
    <td width="20%"><p1>zobacz opis filtru</td>
    <td width="20%"><p1>&nbsp;</td>
  </tr>
  <tr>
    <td width="20%" align="center"><p1><b>MergeLuma, MergeChroma</b></td>
    <td width="20%"><p1>&nbsp;</td>
    <td width="10%"><p1>pierwszego klipu</td>
    <td width="10%"><p1>ostatnia klatka najkrótszego klipu jest powtarzana do koñca klipu</td>
    <td width="20%"><p1>z pierwszego klipu</td>
    <td width="20%"><p1>&nbsp;</td>
  </tr>
  <tr>
    <td width="20%" align="center"><p1><b>Subtract</b></td>
    <td width="20%"><p1>&nbsp;</td>
    <td width="10%"><p1>najd³u¿szego klipu</td>
    <td width="10%"><p1>&nbsp;</td>
    <td width="20%"><p1>&nbsp;</p></td>
    <td width="20%"><p1>&nbsp;</p></td>
  </tr>
  <tr>
    <td width="20%" align="center"><p1><b>Interleave</b></td>
    <td width="20%"><p1>(fps pierwszego klipu)  x  (ilo¶æ klipów)</td>
    <td width="10%"><p1>dwukrotna ilo¶æ klatek najd³u¿szego klipu</td>
    <td width="10%"><p1>&nbsp;</td>
    <td width="20%"><p1>&nbsp;</p></td>
    <td width="20%"><p1>&nbsp;</p></td>
  </tr>
</table>
  </center>
</div>
<p>
Jak widaæ, funkcje nie s± ca³kowicie symetryczne, jednak pobieraj± kilka cech z
pierwszego klipu.<br>
<span class="titresmall"></a><a name="Plugins"><h1>Plugin'y</h1>
<p>Z wymienionymi funkcjami mo¿esz dodaæ do AviSynth funkcje zewnêtrzne. Kolejno¶æ funkcji, w przypadku tej samej
nazwy jest nastêpuj±ca:<br>
<b>
1. </b><i>funkcje zewnêtrzne&nbsp;</i><b><br>
2. </b><i>funkcje zdefiniowane przez u¿ytkownika<br>
</i><b>
3. </b><i>funkcje wewnêtrzne<br>
</i><br>
LoadPlugin ("filename"[,...])&nbsp;<br>
Wczytuje jeden lub wiêcej zewnêtrznych plugin&#8217;ów AviSynth (pliki DLL).&nbsp;<br>
<br>
LoadVirtualDubPlugin ("filename","filtername", preroll)&nbsp;<br>
Wczytuje pluginy napisane pod VD. <b><i> "filename"</i></b> jest nazw± pliku z rozszerzeniem .vdf. Po wywo³aniu tej funkcji, filtr, w AviSynth,  bêdzie nazywany
<b><i> "filtername&quot;</i></b>. Filtry VD wspó³pracuj± tylko z przestrzeni± kolorów RGB32. Je¶li video jest zapisane z przestrzeni± kolorów RGB24, to bêdziesz musia³ skorzystaæ z filtru ConvertToRGB32 (nie wystarczy
samo ConvertToRGB).&nbsp;Niektóre filtry wyj¶ciowe zale¿± od poprzednich klatek; dla takich, parametr
<b> preroll</b> powinien byæ ustawiony przynajmniej na numer klatki, która potrzebuje danego filtra do przetwarzania, wype³nienia buforu i/lub do uaktualnienia swoich wewnêtrznych zmiennych.<br>
<br>
LoadVFAPIPlugin ("filename","filtername")&nbsp;<br>
Pozwala na wykorzystanie plugin&#8217;ów VFAPI.&nbsp;<br>
<br>
<b><u>
Automatycznie ³adowane plugin&#8217;y i nazwy pierwszeñstwa<br>
</u></b>
Mo¿liwe jest umieszczenie wszystkich plugin&#8217;ów i skryptów z w³asnymi funkcjami lub (globalnymi) zmiennymi we wspólnym katalogu, w którym
wszystkie pliki z rozszerzeniem .AVS i .DLL s± wczytywane na starcie, nie
wczytywane i potem wczytywane dynamicznie jako potrzebuj±cy skrypt. Skrypty w tym katalogu powinny zawieraæ tylko zdefiniowane
funkcje i zmienne globalne, a nie g³ówne czê¶ci obróbki video (mog± spowodowaæ powstawanie dziwnych b³êdów) oraz nie jest zalecane
umieszczenie innego pliku w tym¿e katalogu.<br>
Katalog jest przechowywany w rejestrze systemowym (oczywi¶cie, klucz rejestru mo¿na zmieniæ). Mo¿esz u¿yæ pliku .REG z nastêpuj±cymi poleceniami, by ustaliæ ¶cie¿kê dostêpu do wspomnianego katalogu (oczywi¶cie, wstawiasz swoj± aktualn±
¶cie¿kê, niekoniecznie t± sam± co jest podana w poni¿szym przyk³adzie):&nbsp;
<div align="center">
  <center>
<table border="1" cellpadding="4" cellspacing="0" width="99%">
  <tr>
    <td width="100%"><p1>REGEDIT4   [HKEY_LOCAL_MACHINE\SOFTWARE\Avisynth] "PluginDir2_5"="c:\\program
      files\\avisynth\\plugins&quot;</td>
  </tr>
</table>
  </center>
</div>
<p>Kolejno¶æ funkcji z t± sam± nazw± jest nastêpuj±ca:&nbsp;<br>
<b>
1.</b><i> funkcje zewnêtrzne </i> (zawsze maj± najwy¿szy priorytet)<i><br>
</i><b>
2.</b><i> funkcje zdefiniowane przez u¿ytkownika </i> (maj± wy¿szy priorytet ni¿
funkcje wewnêtrzne, przez co mo¿esz uniewa¿niæ jak±¶ funkcjê wewnêtrzn±)<br>
<b>
3.</b> <i>funkcje wewnêtrzne<br>
</i>Funkcje wewnêtrzne ³aduj± siê jako ostatnie, dziêki czemu nie ma
konfliktów pomiêdzy nazwami filtrów.<br>
<br>
<b><u>Zmiana domy¶lnych warto¶ci parametrów w filtrach zewnêtrznych</u></b><br>
Je¶li nie lubisz domy¶lnych warto¶ci takie jakie s± to mo¿esz ustawiæ w³asne warto¶ci domy¶lne. By uniewa¿niæ warto¶ci domy¶lne, najpierw stwórz katalog plugin&#8217;ów AviSynth i wprowad¼ to do
rejestru (wyt³umaczone w podrozdziale powy¿ej). Nastêpnie tworzysz plik z warto¶ciami domy¶lnymi
w katalogu z plugin'ami. Dla przyk³adu, by ustawiæ domy¶ln± warto¶æ dla <i> highq=false</i> dla
<b>
MSharpen</b>, stwórz plik o nazwie <i> MSharpen.def</i> i umie¶æ w nim tak± liniê
tekstu:
</p>
<table border="1" cellpadding="4" cellspacing="0" width="99%">
  <tr>
    <td width="100%"><p>
highq=false</td>
  </tr>
</table>
<p>
Mo¿esz wypisaæ kilka parametrów w jednej linii. Nie wpisane parametry przyjm±
warto¶ci domy¶lne podane przez autora filtra. Oczywi¶cie, zawsze mo¿esz uniewa¿niæ warto¶ci domy¶lne w swoim skrypcie, kiedy wywo³ujesz
jej funkcjê.
</p>
<hr>
<h3>translated by Slim</h3>
</html>
