<HTML>
<head>
<meta http-equiv="Content-type" content="text/html; charset=iso-8859-2" />
<TITLE>nazwa_filtra</TITLE>

<link rel="stylesheet" type="text/css" href="../style2.css">

</HEAD>

<h3>[YV12][YUY2][wspomaganie SSEMMX]</h3>
<h1>STMedianFilter</h1>

<div align="left">
  <table border="0" cellpadding="0" cellspacing="0" width="100%">
    <tr>
      <td width="*%" valign="middle" align="left"><h2><b>STMedianFilter</b>(int S_FilterThreshHold,
        int S_EdgeThreshHold, int T_FilterThreshHold, int T_MotionThreshHold)</h2></td>
      <td width="172" valign="middle" align="left"><p><b>autor</b>: Tom Barry<br>
        <b>wersja</b>: 0.1.0.0<br>
        <b>download</b>: <a href="../../../mywebpages.comcast.net/trbarry/downloads.htm" target="blank">download</a><a></p></a></td>
    </tr>
  </table>
</div>

<hr>

<p><i><b>S_FilterThreshHold</b></i>: nie przestrzenne filtrowanie piksela;
sugerowana warto¶æ 8<br>
<br>
<i><b>S_EdgeThreshHold</b></i>: nie przestrzenne filtrowanie piksela je¶li na krawêdzi
warto¶ci zmieniaj± siê bardziej ni¿ na pikselu; sugerowana warto¶æ 15<br>
<br>
<i><b>T_FilterThreshHold</b></i>: nie czasowe filtrowanie piksela. Warto¶ci
powy¿ej 10 i poni¿ej 5 powoduj± tzw. efekt duchów; sugerowana warto¶æ 4<br>
<br>
<i><b>T_MotionThreshHold</b></i>: nie czasowe filtrowanie piksela z uwzglêdnieniem
ruchu. Warto¶ci powy¿ej 10 i poni¿ej 5 powoduj± tzw. efekt duchów;
sugerowana warto¶æ 7</p>

<hr>

<p>Jest to prosty ¶rednio-zaawansowany filtr, który jest w³a¶ciwie wycinkiem
kodu, w którym warto¶æ jest ustawiana by nie powiêkszyæ pikseli znajduj±cych
siê powy¿ej i poni¿ej bie¿±cego piksela. Na przyk³ad, je¶li mia³e¶ trzy
piksele z rzêdu, które mia³y warto¶ci &lt;5,8,7> mog³e¶ usun±æ centralny
piksel, by nie wybrano ni¿szej warto¶ci ni¿ 5 ani wy¿szej ni¿ 7, wiêc
przyjêto warto¶æ 7.&nbsp;<br>
Teraz wyobra¼ sobie, ¿e masz ma³y ekran video 3x3 piksele, taki jak jedna powierzchnia kostki
Rubik'u. Wyobra¼ sobie poprzedni± klatkê, która jest na dolnej warstwie, bie¿±ca
klatkê, która jest na ¶rodkowej warstwie oraz nastêpn± klatkê, która jest
na górnej warstwie kostki. Czyli bie¿±cy, centralny piksel bêdzie w ¶rodku kostki
Rubik'u i jest teraz 13 sposobów by nakre¶liæ linie przechodz±c± przez ni±
i przez dwie pobliskie klatki (poprzednia i nastêpna). Co zrobi³em by porównaæ ka¿d± z tamtych pary
klatek, by zobaczyæ która para by³a najbardziej zgadzaj±c± siê warto¶ci±.
Ustali³em, ¿eby para pikseli usuwa³a warto¶æ ¶rodkowego piksela. Równie¿
usun±³em warto¶æ piksela je¶li obydwa:<br>
&nbsp;- nie zmieni± warto¶ci piksela wiêcej ni¿ warto¶æ <b><i> FilterThreshold</i></b><br>
&nbsp;- suma ich warto¶ci by³a ni¿sza ni¿ warto¶æ <b><i> MotionThreshHold</i></b></p>

<hr>
<h3>translated by Slim</h3>
</HTML>