<HTML>
<head>
<meta http-equiv="Content-type" content="text/html; charset=iso-8859-2" />
<TITLE>nazwa_filtra</TITLE>

<link rel="stylesheet" type="text/css" href="../style2.css">

</HEAD>

<h3>[YV12]</h3>
<h1>SmoothUV</h1>

<div align="left">
  <table border="0" cellpadding="0" cellspacing="0" width="100%">
    <tr>
      <td width="*%" valign="middle" align="left"><h2><b>SSHiQ</b>(int rY, int rC, int tY, int tC, int str,
        bool HQY, bool HQC, bool field)<br>
        <br>
        <b>SmoothUV</b>(int radius, int threshold, bool field)</h2></td>
      <td width="172" valign="middle" align="left"><p><b>autor</b>: Kurosu<br>
        <b>wersja</b>: 1.4.0<br>
        <b>download</b>: <a href="../../../www.avisynth.org/warpenterprises/default.htm" target="blank">download</a><a></p></a></td>
    </tr>
  </table>
</div>

<hr>

<p><i><b>rY, rC</b></i>: s± odpowiednio promieniem dla lumy i chromy (zasiêg u¿ywanych
pikseli). Im wy¿sza warto¶æ tym wyg³adzenie jest wiêksze<br>
<i><b>tY, tC</b></i>: s± progami wyg³adzania (wra¿liwo¶æ szczegó³ów). Im
wiêksza warto¶æ tym wyg³adzenie jest wiêksze (nie dok³adnie tak samo jak
parametr <i>fpr</i> w inny filtrze SSHiQ).<br>
<br>
<i><b>str</b></i>: si³a wyg³adzania (jedynie w trybie HiQ)<br>
<br>
<i><b>HOY, HOC</b></i>: informuj± czy u¿yæ trybu HiQ mode, gdzie informacja o krawêdziach automatycznie
redukuje warto¶æ <b><i>str</i></b>&nbsp;<br>
<br>
(HQ == 0) ? wyg³adzony_piksel : ((str-krawêd¼)*wyg³adzony_piksel + (256-(str-krawêd¼))*piksel_wyj¶ciowy)/256<br>
<i>
(je¿eli HQ jest równe zeru to str przyjmie warto¶æ <b>wyg³adzony_piksel</b>,
je¿eli nie to wtedy przyjmie warto¶æ <b> ((str-krawêd¼)*wyg³adzony_piksel + (256-(str-krawêd¼))*piksel_wyj¶ciowy )/256</b>)<br>
</i>
<br>
<i><b>field</b></i>: pozwala przetwarzaæ niezale¿ne pola (ryzyko gorszego
zamazania)<br>
<br>
<i><b>radius</b></i>: zasiêg wyg³adzania<br>
<br>
<i><b>threshold</b></i>: jest jednym zastosowaniem w smartsmoothIQ</p>

<hr>

<p><b>
 SmoothUV</b> s³u¿y do redukcji efektu têczy wytworzony przez smartsmoothIQ.
Natomiast drugi filtr nie przetwarza lumy jako ca³o¶æ i mo¿e byæ u¿ywany w
skróconej wersji: <i>SSHiQ(int rY, int radius, -1, int threshold, 255, false, false,
bool field)</i>
</p>

<hr>

<h3>translated by Slim</h3>
</HTML>