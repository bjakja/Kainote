<HTML>
<head>
<meta http-equiv="Content-type" content="text/html; charset=iso-8859-2" />
<TITLE>AVISource / OpenDMLSource / AVIFileSource / WAVSource</TITLE>

<link rel="stylesheet" type="text/css" href="style2.css">

</HEAD>

<h1>AVISource / OpenDMLSource / AVIFileSource / WAVSource</h1>
<h2><b>AVISource</b>(string filename [, ...], bool &quot;audio&quot;, string &quot;pixel_type&quot;)
<br><br>
<b>OpenDMLSource</b>(string filename [, ...] [,bool audio = true] [, string pixel_type = YV12])<br><br>
<b>AVIFileSource</b>(string filename [, ...] [,bool audio = true] [, string pixel_type = YV12])
<br><br>
<b>WAVSource</b>(string filename [, ...])</h2>

<hr>

<p><i><b>filename</b></i>: dok³adna ¶cie¿ka do pliku
<br>
<br>
<i><b>audio</b></i>: przyjmuje warto¶æ true (prawda) - w³±cza ¶cie¿kê audio (warto¶æ domy¶lna) - a false (fa³sz) j± wy³±cza<br><br>
<b><i>pixel_type</i></b>:
przestrzeñ kolorów klipu wynikowego, mo¿liwe warto¶ci: &quot;RGB24&quot;,
&quot;RGB32&quot;, &quot;YUY2&quot; lub &quot;YV12&quot;</p>

<hr>

<p><b>AVISource</b> jako argumentu wymaga co najmniej jednej nazwy pliku, wpisanej w cudzys³owach,
i wyczytuje z pliku/plików u¿ywany interfejs pliku AVI (Video-for-Windows),
lub wykorzystuje wewnêtrzny szyfr OpenDML (zapo¿yczone z VirtualDub). Filtr
ten potrafi czytaæ ka¿dy plik, który jest handlerem AVIFile. Obejmuje to nie
tylko pliki AVI, ale równie¿ pliki WAV, AVS (skrypt AviSynh) i VDR (serwer
klatek VirtualDub). Je¶li jako argument zostanie podanych kilka plików to bêd± one
scalane w jeden za pomoc± <a href="splice.htm" target="main">filtru UnalignedSplice</a>.
Argument bool jest dodatkowy i domy¶lnie ma warto¶æ &quot;true&quot;
(&quot;prawda&quot;).<br><br>
Filtr <b>AVISource</b>
analizuje plik, by okre¶liæ jego typ i podaæ go któremu¶ z handlerów,
AVIFile lub OpenDML, jako w³a¶ciwy plik. W przypadku problemów z chocia¿
jednym handlerem, mo¿na skorzystaæ z jednego z filtrów: <b>OpenDMLSource</b> lub <b>AVIFileSource</b>,
które usi³uj± u¿yæ jednego z handlerów. Handlery potrafi± wczytaæ zwyk³e
pliki AVI (mniejsze od 2GB), ale tylko handler OpenDML potrafi obs³u¿yæ wiêksze
pliki AVI, i tylko handler AVIFile potrafi wczytaæ inne typy plików, takie
jak: WAV, VDR i AVS.<br><br>
Do wersji 2.04, <b>WAVSource</b>
by³ pseudonimem <b>AVIFileSource</b>. W pó¼niejszych wersjach, <b>WAVSource</b>
nie próbuje ju¿ otwieraæ strumieni video. Potrafi byæ u¿yteczny je¶li jest potrzeba
odzyskania strumienia audio z pliku AVI, w którym strumieñ video jest uszkodzony
lub jego metoda kompresji nie jest wspomagana przez system.<br><br>
Powy¿ej wersji 2.04 filtr ten jest
wspomagany przez ACM audio (Audio Compression Manager, np.: mp3-AVIs). <b>AVISource</b>
równie¿ nie otwiera plików WAV, które musz± byæ wczytane przez filtr <b>WAVSource</b>.
<br><br>
Od wersji 2.06 mo¿na okre¶liæ
argument <b><i>pixel_type</i></b>, który pozwala na zmianê
formatu wyj¶ciowego dekompresora. Mo¿liwe warto¶ci to: &quot;YUY2&quot;,
&quot;RGB32&quot; i &quot;RGB24&quot;. Je¶li video
jest w formacie nie skompresowanym (YUY2, RGB32 lub RGB24) to nie ma najmniejszego sensu okre¶lanie jakiegokolwiek argumentu dla <b><i>pixel_type</i></b>, poniewa¿ w tym przypadku dekompresor nie bêdzie z niego korzysta³. Od wersji 2.5 domy¶ln± warto¶ci± dla <b><i>pixel_type</i></b> jest YV12, czyli gdy nie zostanie ustawiony argumentu dla <b><i>pixel_type</i></b> to
dane wyj¶ciowe w AVI bêd± rzutowane do YV12, je¶li jest to niemo¿liwe
filtr spróbuje rzutowania do YUY2, a je¶li i to jest niewykonalne, to pozostaje
próba rzutowania do RGB.<br><br>
Czasem kolory w klipie wynikowym mog± byæ zniekszta³cone, gdy do AviSynth zostania wczytany klip DivX (kana³y chromy (kolor) U i V s±
zamieniane) - jest to b³±d po stronie DivX (do wersji 5.02 w³±cznie). Mo¿na u¿yæ
filtru SwapUV do zniwelowania tych zniekszta³ceñ.<br><br>
Od wersji 2.53 <b>AVISource</b>
potrafi równie¿ otwieraæ video w formacie DV typu 1 (tylko video, nie audio).
<br><br>
Niektóre kodeki MJPEG/DV podczas
u¿ywania filtru <b>AVISource</b>, przekazuj± niepoprawnie, uzgodnione dane
wyj¶ciowe CCIR 601. Problem móg³ powstaæ je¶li przestrzeñ kolorów kodeka
danych wej¶ciowych i wyj¶ciowych jest ró¿ny. Na przyk³ad, je¶li przestrzeni±
kolorów danych wej¶ciowych jest YUY2, gdy dla danych wyj¶ciowych formatem tym
jest RGB, lub odwrotnie. S± dwa sposoby na rozwi±zanie tego problemu:<br><br>1) Zmusiæ dane wyj¶ciowe by
mia³y tak± sam± przestrzeñ kolorów jak dane wej¶ciowe, a zatem (je¶li dane wej¶ciowe
maj± przestrzeñ RGB32):<br>
<br><i>AVISource(&quot;file.avi&quot;, pixel_type=&quot;RGB32&quot;)</i><br><br>2) Za pomoc± filtra ColorYUV:<br><br>
<i>AVISource(&quot;file.avi&quot;).ColorYUV(levels=&quot;PC-&gt;TV&quot;)</i></p>

<hr>

<p><b>Przyk³ady:</b>
  <table border="0" cellpadding="0" cellspacing="0" width="100%">
    <tr>
      <td width="233" valign="top" align="left"><p>AVISource(&quot;d:\capture.avi&quot;)</p></td>
            <td width="11" valign="top" align="left">
        <p>#</p>
      <td width="*%" valign="top" align="left"><p>
        programi¶ci w C zauwa¿± zapewne, ¿e backslash'e (\)
        nie s± podwójne, ale byæ nie musz±</p></td>
    </tr>
    <tr>
      <td width="233" valign="top" align="left"><p>&nbsp</p></td>
      <td width="11" valign="top" align="left">
        </td>
      <td width="*%" valign="top" align="left">
        </td>
    </tr>
    <tr>
      <td width="233" valign="top" align="left"><p>AVISource(&quot;c:/capture/00.avi&quot;)</p>
      <td width="11" valign="top" align="left">
        <p>#</p></td>
      <td width="*%" valign="top" align="left">
        <p>slash'e (/) równie¿ dzia³aj±</p></td>
    </tr>
    <tr>
      <td width="233" valign="top" align="left"><p>&nbsp</p></td>
      <td width="11" valign="top" align="left">
        <p>&nbsp</p></td>
      <td width="*%" valign="top" align="left">
        <p>&nbsp</p></td>
    </tr>
    <tr>
      <td width="233" valign="top" align="left"><p>WAVSource(&quot;f:\soundtrack.wav&quot;)&nbsp;</p></td>
      <td width="11" valign="top" align="left">
        <p>#</p></td>
      <td width="*%" valign="top" align="left">
        <p>czyli ten przyk³ad te¿ jest poprawny</p>
        </td>
    </tr>
    <tr>
      <td width="233" valign="top" align="left"><p>&nbsp</p></td>
      <td width="11" valign="top" align="left">
        <p>&nbsp</p></td>
      <td width="*%" valign="top" align="left">
        <p>&nbsp</p></td>
    </tr>
    <tr>
      <td width="233" valign="top" align="left"><p>WAVSource(&quot;f:/soundtrack.wav&quot;)&nbsp;</p></td>
      <td width="11" valign="top" align="left">
        <p>#</p></td>
      <td width="*%" valign="top" align="left">
        <p>i ten równie¿</p></td>
    </tr>
    <tr>
      <td width="233" valign="top" align="left"><p>&nbsp</p></td>
      <td width="11" valign="top" align="left">
        <p>&nbsp</p></td>
      <td width="*%" valign="top" align="left">
        <p>&nbsp</p></td>
    </tr>
    <tr>
      <td width="233" valign="top" align="left"><p>AVISource(&quot;cap1.avi&quot;,&quot;cap2.avi&quot;)</p></td>
      <td width="11" valign="top" align="left">
        <p>#</p></td>
      <td width="*%" valign="top" align="left">
        <p>tak
        samo jak: AVISource(&quot;cap1.avi&quot;)+AVISource(&quot;cap2.avi&quot;)</p></td>
    </tr>
    <tr>
      <td width="233" valign="top" align="left"><p>&nbsp</p></td>
      <td width="11" valign="top" align="left">
        <p>&nbsp</p></td>
      <td width="*%" valign="top" align="left">
        <p>&nbsp</p></td>
    </tr>
    <tr>
      <td width="233" valign="top" align="left"><p>AVISource(&quot;cap.avi&quot;,false,&quot;RGB32&quot;)</p></td>
      <td width="11" valign="top" align="left">
        <p>#</p></td>
      <td width="*%" valign="top" align="left">
        <p>wy³±czona ¶cie¿ka audio i za¿yczona dekompresja do
        RGB32</p></td>
    </tr>
  </table>
<hr>

<h3>translated by Slim</h3>
</HTML>