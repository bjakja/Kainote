<!doctype html public "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>Resize Avisynth Filter</title>
<link rel="stylesheet" type="text/css" href="../../avisynth.css">
</head>
<body>
<h2>BicubicResize / BilinearResize / LanczosResize / Lanczos4Resize / PointResize</h2>
<p><code>BicubicResize </code>(<var>clip, int target_width, int target_height, float
  &quot;b&quot;, float &quot;c&quot;</var>)<br>
  <code>BilinearResize </code>(<var>clip, int target_width, int target_height</var>)<br>
  <code>LanczosResize </code>(<var>clip, int target_width, int target_height</var>)<br>
  <code>Lanczos4Resize </code>(<var>clip, int target_width, int target_height</var>)<br>
  <code>PointResize </code>(<var>clip, int target_width, int target_height</var>)</p>
<p>Per tutte le forme di resize si può usare una sintassi estesa che croppa prima
  di ridimensionare. Sono eseguite le stesse operazioni come se si mettesse Crop
  prima di Resize, ci può essere una piccola differenza di velocità.</p>

<pre>Crop(10,10,200,300).BilinearResize(100,150)
  &egrave; la stessa cosa di
BilinearResize(100,150,10,10,200,300)</pre>

<p><code>BicubicResize </code>(<var>clip, int target_width, int target_height, float
  &quot;b&quot;, float &quot;c&quot;, float &quot;src_left&quot;, float &quot;src_top&quot;,
  float &quot;src_width&quot;, float &quot;src_height&quot;</var>)<br>
  <code>BilinearResize </code>(<var>clip, int target_width, int target_height, float
  &quot;src_left&quot;, float &quot;src_top&quot;, float &quot;src_width&quot;,
  float &quot;src_height&quot;</var>)<br>
  <code>LanczosResize </code>(<var>clip, int target_width, int target_height, float
  "src_left", float "src_top", float "src_width", float "src_height"</var>)<br>
<code>Lanczos4Resize </code>(<var>clip, int target_width, int target_height, float
  "src_left", float "src_top", float "src_width", float "src_height"</var>)<br>
  <code>PointResize </code>(<var>clip, int target_width, int target_height, float "src_left",
  float "src_top", float "src_width", float "src_height"</var>)</p>
<p>Importante: AviSynth ha resizers orizzontali e verticali completamente separati.
  Se su un asse l'input &egrave; lo stesso dell'output , quel resizer verr&agrave;
  saltato. Quale dei due sia chiamato per primo, &egrave; determinato da quello
  che ha il pi&ugrave; piccolo rapporto di ridimensionamento. Questo &egrave;
  fatto per salvaguardare il massimo della qualit&agrave;, sicch&egrave; i 2 resizers
  hanno la miglior immagine possibile su cui lavorare.</p>
<h3><b> <a href="filters/blur.html"></a></b>
Bilinear
</h3>
<p>Il filtro <code>BilinearResize</code> ridimensiona i video frames a qualsiasi
  nuova risoluzione. Se si forniscono i parametri opzionali, il risultato &egrave;
  identico a quello che si avrebbe applicando il <code><a href="crop.htm">Crop</a></code>
  con quei valori prima del <code>BilinearResize</code> (eccetto la maggior velocit&agrave;).
</p>
<p><code>BilinearResize</code> usa un filtraggio bilineare standard ed &egrave;
  quasi identico all' opzione "precise bilinear" di VirtualDub. Lo &egrave; solo
  "quasi" perch&eacute; il filtro di <a href="<?php echo "indice_frames.php?CallingPage=$CallingPage &page="; ?>"></a>
  di VirtualDub sembra assumere il fattore di scala in modo leggermente errato,
  col risultato che i pixels della parte superiore e destra dell'immagine vengono
  o tagliati o duplicati. (Questo errore &egrave; apprezzabile quando si allarga
  la dimensione del frame di 2 o pi&ugrave; volte, ma &egrave; altrimenti insignificante,
  cosicch&egrave; non mi preoccuperei troppo.) </p>

<pre>Examples:
# Caricamento di un file video e resize a  240x180 (da qualunque dimensione
    originaria)
AVISource(&quot;video.avi&quot;).BilinearResize(240,180)

# Caricamento di un video 720x480 (CCIR601) e resize a 352x240 (VCD),
# mantenendo la corretta aspect ratio
AVISource(&quot;dv.avi&quot;).BilinearResize(352,240,8,0,704,480)

# Estrazione del quadrante superiore destro di un video 320x240 e zoom
# per riempire l'intero frame
BilinearResize(320,240,160,0,160,120)
</pre>
<h3>Bicubic
</h3>
<p><tt><code>BicubicResize</code></tt> &egrave; simile al <tt><code>BilinearResize</code></tt>,
  eccetto che al posto di una funzione lineare di filtraggio usa la funzione Mitchell-Netravali
  two-part cubic. I parametri b e c si usano per tarare le propriet&agrave; del
  cubic, e sono chiamate a volte "blurring" e "ringing".</p>
<p>Co <i>b</i> = 0 e <i>c</i> = 0.75 il filtro &egrave; identico al "precise bicubic&quot;
  di VirtualDub "precise bicubic," ed i risultati sono identici salvo il fatto
  del problema di scaling cui si accennava prima. Il default &egrave; <i>b</i>
  = 1/3 e <i>c</i> = 1/3, che erano i valori raccomandati da Mitchell e Netravali
  come quelli che forniscono i risultati pi&ugrave; piacevoli nei tests soggettivi
  con esseri umani. Valori pi&ugrave; grandi di <i>b</i> e <i>c</i> producono
  interessanti effetti &quot;op-art&quot; --ad esempio provate b = 0 e c = -5.
</p>
<p>Se si vogliono ingrandire i video, si ottengono migliori risultati visivi col
  <tt><code>BicubicResize</code></tt> che con <tt><code>BilinearResize</code></tt>.
  Tuttavia, se lo si vuole restringere, i risultati migliori si hanno col <tt><code>BilinearResize</code></tt>.
  Sebbene il filtro bicubico di VirtualDub 'produca immagini migliori alla vista
  del bilinear , questo &egrave; principalmente dovuto al fatto che il bicubico
  contrasta l'immagine, non perch&egrave; sia migliore. Le immagini contrastate
  sono piacevoli da guardare--fino al momento in cui non si cerca di comprimerle,
  al che esse ridiventano sgradevoli e molto alla svelta :-((. Il valore di default
  del <tt><code>BicubicResize</code></tt> non contrasta cos&igrave; tanto quanto
  il bicubic di VirtualDub ma in ogni caso contrasta pi&ugrave; del Bilinear.
  Se si pianifica di encodare un video a basso bitrate, non mi sorprenderei del
  tutto se il <tt><code>BilinearResize</code></tt> ottenesse una maggior qualit&agrave;.
</p>
<p> Si deve impostare<br>
  b + 2 * c = 1<br>
  per il filtraggio pi&ugrave; accurato. Questo d&agrave; per b = 0 un valore
  max per c = 0.5, che &egrave; un valore buono di contrasto.</p>
<p>Da c>0.6 il filtro comincia a produrre effetto "ring". Non si ottiene un reale
  contrasto, quello che si ottiene &egrave; un effetto TV.<br />
  Non sono ammessi valori negativi per b. </p>
<h3>Lanczos
</h3>
<p><tt><code>LanczosResize</code></tt> &egrave; una alternativa al <tt><code>BicubicResize</code></tt>
  con alti valori di c (circa 0.6 ... 0.75) che produce un contrasto ancora maggiore.
  Normalmente produce una miglior qualit&agrave; (meno artifatti) ed una immagine
  ben definita.</p>
<h3>Lanczos4</h3>
<p><code>Lanczos4Resize</code> (aggiunto in <em>v2.55</em>) &egrave; strettamente
  imparentato con <code>LanczosResize</code> (nome corretto: Lanczos3Resize).
  Quest'ultimo usa un filtro 6-tap mentre il primo un filtro 8-tap . Il risultato
  &egrave; che <code>Lanczos4Resize</code> produce immagini pi&ugrave; nitide.
  Utile in special modo quando si ingrandiscono le immagini.</p>
<h3>Point
</h3>
<p><tt><code>PointResize</code></tt> &egrave; il resizer pi&ugrave; semplice possibile.
  Usa un algoritmo Point Sampler o Nearest Neighbour , che normalmente produce
  immagini &quot;blocchettose&quot;. In generale dovrebbe essere usato solo per
  ingrandire piccole aree per esaminarle meglio.<br />
</p>
<p><kbd>$Date: 2004/10/03 21:26:00 $</kbd></p>
<FORM>
  <INPUT TYPE="Button" VALUE="Indietro"
onClick="history.go(-1)">
</form>
</body>
</html>
