<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <title>SpatialSoften / TemporalSoften Avisynth Filter</title>
   <link rel="stylesheet" type="text/css" href="../../avisynth.css">
</head>
<body >
<h2>
<a NAME="Soften"></a>SpatialSoften
/ TemporalSoften
</h2>
<p><code>SpatialSoften </code>(<var>clip, int radius, int luma_threshold, int
chroma_threshold</var>)<br>
  <code>TemporalSoften </code>(<var>clip, int radius, int luma_threshold, int
chroma_threshold, int "scenechange", int "mode"</var>)
<p>I filtri <code>SpatialSoften</code> e <code>TemporalSoften</code> tolgono il
  rumore dal video miscelando selettivamente i pixels. Questi filtri possono fare
  miracoli ed è vivamente consigliato provarli. Ma essi possono anche eliminare
  piccoli dettagli se si settano troppo forti , per cui non conviene strafare.
  In più sono molto lenti, in special modo se usati con un raggio <var>(radius)
  </var>, molto ampio, sicchè non attivateli finchè tutto il resto non è a posto.
<p><code>SpatialSoften</code> sostituisce nel frame ogni campione con la media
  dei campioni vicini che differiscono da quello centrale di non pi&ugrave; di
  un certo valore di soglia ( threshold). "Vicini&quot; significa lontani non
  pi&ugrave; di <var>radius</var> pixels sia in direzione x che y . La soglia
  usata &egrave; <var>luma_threshold</var> per i campioni Y (intensit&agrave;)
  , e <var>chroma_threshold</var> per i campioni U e V (colore) .
<p><code>TemporalSoften</code> è simile, eccetto che cerca lo stesso pixel nei
  frames adiacenti, anzichè pixels adiacenti nello stesso frame. Sono esaminati
  tutti i frames dentro al <var>radius</var>. TQuesto filtro non sembra essere
  così efficace quanto <code>SpatialSoften</code>.
<p>Siete incoraggiati a giocherellare con i parametri per farvi un'idea di quello
  che fanno--ad esempio settando uno dei 3 parametri ad un valore molto alto pur
  lasciando gli altri bassi, e vedere cosa succede. Si noti che settando uno qualsiasi
  dei 3 parametri = 0 il filtro diverrà una palla al piede pur non facendo nulla.
  <input type="Button" value="Indietro"
onClick="history.go(-1)" name="Button">

<p><code>TemporalSoften</code> opera uno smoothing separato su luma e chroma ,
  mentre <code>SpatialSoften</code> opera uno smoothing solo se sia luma che chroma
  hanno superato la soglia.
<p>I filtri <code>SpatialSoften</code> e <code>TemporalSoften</code> lavorano
  solo con input YUY2 . Usare <code><a href="convert.htm">ConvertToYUY2</a></code>
  se l'input non &egrave; YUY2.
<p>Notare che se si usa AviSynth <em>v2.04</em> o superiori, non c'&egrave; pi&ugrave;
  bisogno del plugin TemporalSoften2 , il TemporalSoften interno &egrave; stato
  integrato con questa funzionalit&agrave;.
<p>Ad iniziare dalla<em> v2.50</em>, sono state aggiunte a <code>TemporalSoften</code>
  2 opzioni:
<ul>
  <li> Un parametro opzionale <var>mode</var><i>=2</i> : Ha una nuova e migliore
    modalità di miscelazione dei frames e fornisce maggior qualità. Ed è anche
    più veloce. Necessita di ISSE. <var>mode=1</var> è il valore di default, e
    funziona come prima. </li>
  <li> E stato aggiunto il parametro opzionale <var>scenechange=n</var> : Usando
    questo parametro si evita di miscelare quando c'è un cambio di scena. 'n'
    definisce il cambiamento massimo dei pixel tra i frames. Valori buoni per
    'n' sono compresi tra 5 e 30. Necessita di ISSE.</li>
</ul>
<p>Per cominciare provate: <code>TemporalSoften</code>(4,4,8,15,2)</p>
<p><kbd>$Date: 2004/10/03 21:26:00 $</kbd>
</p>
<form>
</form>
</body>
</html>
