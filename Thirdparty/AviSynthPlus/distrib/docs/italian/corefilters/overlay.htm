<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <title>Overlay Filter</title>
   <link rel="stylesheet" type="text/css" href="../../avisynth.css">
</head>
<body >
<h2>
<a href="#Tone" name="SuperEQ"></a>Overlay
</h2>
<p align="left"><code>Overlay </code>(<var>clip, clip overlay, int ''x'', int
  ''y'', clip ''mask'', float ''opacity'', string ''mode'', bool ''greymask'',
  string ''output'', bool ''ignore_conditional'', bool ''pc_range''</var>)<br>
  <br>
  <code> Overlay</code> sovrappone 2 clips con la possibilit&agrave; di impostare
  la posizione dell'immagine che si sovrappone. In pi&ugrave; si pu&ograve; impostare
  l'opacity del clip.<br>
  <br>
  In input si pu&ograve; avere qualsiasi colorspace e non ha importanza se i colorspaces
  delle clips sono diversi. Le input clips sono convertite internamente in YUV
  ( no chroma subsampling) , sicch&eacute; il filtro pu&ograve; generare un colorspace
  diverso da quello di input. E' anche possibile convertire video di input in
  colorspaces diversi. Tuttavia non si raccomanda di usare overlay ''solo'' per
  leconversioni di colorspace poich&egrave; il filtro oltre che essere lento non
  &egrave; di qualit&agrave; eccelsa.<br>
  <br>
  In generale tutte le clips sono trattate nel range 0->255 . Questo significa
  che i valori non sono tagliati secondo le spcifiche CCIR 601. Per ottenere ci&ograve;
  posporre il filtro <a href="limiter.htm"><code>Limiter</code></a> .<br>
  <i><b> Anche Masks dovrebbe avere valori 0->255.</b></i> Usare <a href="histogram.htm"><code>Histogram</code></a>
  in modalit&agrave; <code>Histogram</code>("levels") per vedere le distribuzioni
  dei colori. Se la vostra Mask &egrave; nel range CCIR 601 , usare <a href="coloryuv.htm"><code>ColorYUV</code></a>(levels=&quot;TV-&gt;PC&quot;)
  per aumentare i livelli dei colori.<br>
  <br>
  Si consiglia di NON sovrapporre materiale interlacciato a meno che non si sappia
  ESATTAMENTE cosa si sta facendo.
<h4 align="left"><b>Parametri:</b></h4>
<p align="left"><b>clip</b><br>
  Clip di base, e la &quot;overlay picture&quot; le sar&agrave; sovrapposta.&nbsp;
<p align="left"><b>overlay<br>
  </b>Questa &egrave; l'immagine che sar&agrave; sovrapposta al clip. Sia colorspace
  che dimensioni possono differire da quelle di base clip.
<p align="left"><b>x &amp;
y<br>
  </b>Queste 2 variabili definiscono in pixels la disposizione dell' overlay image
  eispetto al base clip. Le variabili possono essere sia positive che negative.<br>
  <i>Default = 0.</i>
<p align="left"><b>mask<br>
  </b>Questa sar&agrave; usata come transparency mask per l'overlay image. Mask
  deve avere le stesse dimensioni dell' overlay clip. Di default sono usati solamente
  componenti greyscale (luma). Pi&ugrave; l'immagine &egrave; scura, pi&ugrave;
  trasparente sar&agrave; l'overlay image.<br>
  <i>Non c'&egrave; valore di default, ma non specificarlo equivale a fornire
  un clip con valore 255.</i>
<p align="left"><b>opacity<br>
  </b>Questo definisce quanto l'immagine sar&agrave; trasparente. Il valore va
  da 0.0 a 1.0, dove 0.0 &egrave; transparente ed 1.0 &egrave; completamente opaco
  (se non si usa mask). Usato insieme a mask, questo valore &egrave; moltiplicato
  dal valore di mask.<br>
  <i>Default &egrave; 1.0</i>
<p align="left"><b>mode<br>
  </b>Mode definisce come il clip deve essere ricoperta dall'immagine.&nbsp;
<table border="1" width="100%">
  <tr>
    <td width="8%"><b>Mode</b></td>
    <td width="92%"><b>Descrizione</b></td>
  </tr>
  <tr>
    <td width="8%">Blend</td>
    <td width="92%">Default mode. Quando opacity &egrave; 1.0 e non c'&egrave;
      mask l' overlay image sar&agrave; copiata sull'originale. In caso contrario
      si usa un normale transparent blending.</td>
  </tr>
  <tr>
    <td width="8%">Add</td>
    <td width="92%">Questo aggiunge l'overlay video al base video rendendolo pi&ugrave;
      luminoso. Facendo un paragone con RGB, rendendo pi&ugrave; luminose le aree,
      si influenza anche il chroma rendendolo pi&ugrave; white.</td>
  </tr>
  <tr>
    <td width="8%">Subtract</td>
    <td width="92%">L'opposto di Add. Scurisce le aree.</td>
  </tr>
  <tr>
    <td width="8%">Multiply</td>
    <td width="92%">Anche questo scurisce l'immagine, ma in modo diverso risoetto
      a subtract.</td>
  </tr>
  <tr>
    <td width="8%">Chroma</td>
    <td width="92%">Questo sovrappone le informazioni di colore dell' overlay
      clip alla base image.</td>
  </tr>
  <tr>
    <td width="8%">Luma</td>
    <td width="92%">Questo sovrappone le informazioni di luminosit&agrave; dell'
      overlay clip alla base image.</td>
  </tr>
  <tr>
    <td width="8%">Lighten</td>
    <td width="92%">Questo sovrappone le informazioni di luminosit&agrave; dell'
      overlay clip alla base image, ma solo se l'overlay &egrave; pi&ugrave; chiaro
      della base image.</td>
  </tr>
  <tr>
    <td width="8%">Darken</td>
    <td width="92%">Questo sovrappone le informazioni di luminosit&agrave; dell'
      overlay clip alla base image, ma solo se l'overlay &egrave; pi&ugrave; scuro
      della base image.</td>
  </tr>
  <tr>
    <td width="8%">SoftLight</td>
    <td width="92%">Questo schiarisce o scurisce il base clip, in funzione del
      livello di luminosit&agrave; dell' overlay clip. Se l'overlay &egrave; pi&ugrave;
      scuro di un luma = 128, la base image sar&agrave; pi&ugrave; scura. Se l'overlay
      &egrave; pi&ugrave; chiara di un luma=128, la base image sar&agrave; pi&ugrave;
      chiara. Questo &egrave; utile per aggiungere ombre ad un'immagine. Colorare
      con un nero od un bianco puro produce un'area distintamente pi&ugrave; scura
      o pi&ugrave; chiara, ma non ne risulta un nero od un bianco puro.</td>
  </tr>
  <tr>
    <td width="8%">HardLight</td>
    <td width="92%">Questo schiarisce o scurisce il base clip, in funzione del
      livello di luminosit&agrave; dell' overlay clip. Se l'overlay &egrave; pi&ugrave;
      scuro di un luma = 128, la base image sar&agrave; pi&ugrave; scura. Se l'overlay
      &egrave; pi&ugrave; chiara di un luma=128, la base image sar&agrave; pi&ugrave;
      chiara. Questo &egrave; utile per aggiungere ombre ad un'immagine. Colorare
      con un nero od un bianco puro produce un'area distintamente pi&ugrave; scura
      o pi&ugrave; chiara, ma non ne risulta un nero od un bianco puro.</td>
  </tr>
  <tr>
    <td width="8%">Difference</td>
    <td width="92%">Questo mostra le differenze tra il e l'overlay. Notare che
      in modo analogo a <a href="http://www.avisynth.org/index.php?page=Subtract">Subtract</a>
      nessuna differenze &egrave; mostrata nel caso in cui grey=127. Se si vogliono
      le differenze pure, usare <a href="coloryuv.htm">ColorYUV</a>(off_y=-127).</td>
  </tr>
  <tr>
    <td width="8%">Exclusion</td>
    <td width="92%">Questo inverte l'immagine sulla base della luminosit&agrave;
      dell' overlay image. Mescolando col bianco si invertono i valori dei colori
      di base; mescolando col nero non produce effetti.</td>
  </tr>
</table>
<p align="left"><i>Default &egrave; Blend</i>
<p align="left"><b>greymask<br>
  </b>Questa opzione specifica se il chroma preso da mask debba essere usato per
  il chroma transparency. Per un uso generale questa modalit&agrave; non dovrebbe
  essere disabilitata. Filtri esterni come mSharpen e Masktools sono in grado
  di esportare delle corrette chroma maps.<br>
  <i>Default &egrave; true</i>
<p align="left"><b>output<br>
  </b>E' possibile fare in modo che Overlay restituisca un diverso colorspace.
  Output possibili sono "YUY2", &quot;YV12&quot;, &quot;RGB32&quot; e&quot;RGB24&quot;.<br>
  <i>Default &egrave; l'input colorpace</i>
<p align="left"><b>ignore_conditional<br>
  </b>Questo fa ignorare da Overlay qualsiasi variabile conditionale usata. Per
  un approfondimento vedere la sezione delle "Conditional Variables" .<br>
<i>Default is false</i><p align="left"><b>pc_range<br>
  </b>Quando impostato a true, far&agrave; in modo che ogni conversione interna
  RGB -> YUV -> RGB assuma che il luma range sia da 0 a 255 invece del default
  16->235 . Si raccomanda di cambiare questa impostazione SOLO con cognizione
  di causa. Vedere la sezione "Considerationi su RGB" qui sotto.<br>
  <i>Default &egrave; false</i>
<h3 align="left"> Considerationi su RGB</h3>
<p align="left">Questa sezione fornisce alcune spiegazioni su come si comporta
  Overlay a fronte di una o pi&ugrave; sorgenti RGB .<br>
  In Overlay &egrave; consentito avere una o pi&ugrave; sorgenti RGB-data. Tuttavia,
  siccome Overlay elabora il materiale nel colorspace YUV la cosa implica una
  conversione da RGB a YUV . Ci sono 2 modalit&agrave; per ottenere questa conversione
  gestiti dal parametro "pc_range". Questo parametro estende il range YUV da 16-235
  (range usato da tutti i convertitori di avisynth) a 0-255. Ci sono alcuni casi
  in cui abilitare pc_range &egrave; una buona idea:
<ul>
  <li>
    <p align="left">Quando si sovrappone un RGB-clip usando i modi "add", "subtract"
      o"multiply", &egrave; meglio che il range del clip sovrapposto sia 0-255,
      poich&egrave; questo fa si che le aree completamente nere non influenzino
      il risultato (invece di aggiungere 16 ad ogni valore).
  </li>
  <li>
    <p align="left">Quando NON di deve fare una conversione di colorspace in output.
      Se l'output colorspace (RGB vs. YUV) &egrave; diverso dall'input, la scala
      sar&agrave; sbagliata. Se pc_range &egrave; true, e l'input &egrave; RGB
      con output in YUY2 - YUY2 avr&agrave; un range non valido, e non un range
      CCIR 601.
  </li>
</ul>
<p align="left"><b>Output in RGB</b></p>
<p align="left">Potrebbe essere una buona idea consentire ad Overlay un output
  YUY2 anche se il colorspace di input &egrave; RGB, visto che questo evita una
  riconversione di colorspace in RGB da YUV. Siate consapevoli che il vostro materiale
  potrebbe essere "overscaled", come visto sopra, se si usa pc_range = true. Questo
  si pu&ograve; correggere usando ''ColorYUV(levels="pc->tv")'' per riconvertire
  in un range 16-235.</p>
<p align="left"><b>Input RGB per il mask clip</b></p>
<p align="left">Il mask clip in RGB si comporta in modo leggermente diverso da
  come ci si apetterebbe. Se si usa sempre una greyscale mask, e non si disabilita
  ''greymask'' i risultati sono quelli attesi. Si noti che i valore di mask clip
  non sono mai scalati sicch&eacute; saranno automaticamente nel range 0->255,
  copiati direttamente dai valori RGB.</p>
<p><strong>Uso di RGB32 alpha channel</strong></p>
<p>Overlay non usa mai l'alpha channel presente in un clip RGB32. Se si vuole
  estrarre l' alpha channel da un clip RGB32 si pu&ograve; usare il comando <a href="showalpha.htm"><code>ShowAlpha</code></a>
  . Al fine di mantenere la qualit&agrave; massima, si raccomanda di estrarre
  l' alpha come RGB.</p>
<h3 align="left">Variabili Conditionali </h3>
<p align="left">Le global variables &quot;<i>OL_opacity_offset</i>&quot;, &quot;<i>OL_x_offset</i>&quot;
  e &quot;<i>OL_y_offset</i>&quot; sono lette per ogni each frame, quindi applicate.
  E' possibile modificare queste variabili usando <a href="ConditionalFilter.htm"><code>FrameEvaluate</code></a>.
  I valori di queste variabili saranno aggiunti ad ogni frame dell'originale.
  Se quindi si specifica "x = 100" come parametro del filtro, e la global variable
  &quot;<i>OL_x_offset</i>&quot; &egrave; impostata a 50, l' overlay sar&agrave;
  piazzato ad x = 150.<br>
  <br>
  Nel caso si usino filtri multipli, questo pu&ograve; essere evitato usando il
  parametro "ignore_conditional = true" .</p>
<p align="left">C'&egrave; un esempio alla pagina <a href="conditionalreader.htm"><code>ConditionalReader</code></a>
  .</p>
<h3 align="left">Esempi</h3>
<p align="left"># Prepara alcune sources.</p>
<div align="left">
  <pre align="left">bg = colorbars(512,384).converttoyuy2()
text = blankclip(bg).subtitle(&quot;Colorbars&quot;, size=92, text_color=$ffffff).coloryuv(levels=&quot;tv-&gt;pc&quot;)</pre>
</div>
<p align="left"># Questo sovrappone il testo in 3 modi diversi.</p>
<div align="left">
  <pre align="left">overlay(bg, text, x=50, y=20, mode=&quot;subtract&quot;, opacity=0.25)
overlay(text, x=50, y=120, mode=&quot;add&quot;, opacity=0.5)
overlay(text, x=50, y=240, mode=&quot;blend&quot;, opacity=0.7)</pre>
</div>
<p># Questo sovrapponeun clip yuy2 con un clip rgb usando una mask yuy2 (notare
  che il luma range di mask &egrave; [0-255]).
<pre>Overlay(yuy2clip, rgbclip, mask = rgbclip.ShowAlpha(&quot;yuy2&quot;))</pre>
<p># che equivale a
<pre>mask = rgbclip.ShowAlpha(&quot;rgb&quot;).ConvertToYUY2.ColorYUV(levels=&quot;TV-&gt;PC&quot;)<input type="Button" value="Indietro"
onClick="history.go(-1)" name="Button">
Overlay(yuy2clip, rgbclip, mask)</pre>
<p># ed anche a
<pre>mask = rgbclip.ShowAlpha(&quot;rgb&quot;)
Overlay(yuy2clip, rgbclip, mask)</pre>
<p># Questo ottiene la media di 2 clips. Lo si pu&ograve; usare per combinare
  insieme 2 catture TV per ridurre il rumore. Una discussione relativa a questa
  idea la trovate [<a href="http://forum.doom9.org/showthread.php?s=&amp;threadid=28438">qui</a>].
  Uno script di esempio (naturalmente vi dovete assicurare che i frames dei 2
  clips siano compatibili, usare <a href="deleteframe.htm">DeleteFrame</a> se
  necessario):</p>
<pre>clip1 = AviSource(&quot;F:\shakira-underneath_your_clothes.avi&quot;)
clip2 = AviSource(&quot;F:\shakira-underneath_your_clothes2.avi&quot;)
Overlay(clip1, clip2, mode=&quot;blend&quot;, opacity=0.5)</pre>
<h3>Changelog:</h3>
<table border="1" width="100%">
  <tr>
    <td width="8%"> v2.54</td>
    <td width="92%"> Initial Release</td>
  </tr>
</table>
<p align="left"><kbd>$Date: 2004/10/03 21:26:00 $</kbd></p>
<form>
  <p>&nbsp;</p>
</form>

</body>
</html>
